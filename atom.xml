<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Four&#39;s</title>
  
  <subtitle>一鼓作气，三题暴力</subtitle>
  <link href="http://kqp.world/atom.xml" rel="self"/>
  
  <link href="http://kqp.world/"/>
  <updated>2022-05-31T09:08:48.000Z</updated>
  <id>http://kqp.world/</id>
  
  <author>
    <name>kqp</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【AtCoder Regular 141D】Non-divisible Set 题解</title>
    <link href="http://kqp.world/%E3%80%90AtCoder%20Regular%20141D%E3%80%91Non-divisible%20Set%20%E9%A2%98%E8%A7%A3/"/>
    <id>http://kqp.world/%E3%80%90AtCoder%20Regular%20141D%E3%80%91Non-divisible%20Set%20%E9%A2%98%E8%A7%A3/</id>
    <published>2022-05-31T08:45:50.000Z</published>
    <updated>2022-05-31T09:08:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>&emsp;&emsp;给定长度为 $n$ 的序列 $a_1,\cdots,a_n$ 和一个参数 $m$，对于每个 $i$，问是否能从序列中选出满足如下条件的子集：</p><ul><li>集合包含 $a_i$；</li><li>集合大小为 $m$；</li><li>集合内不存在一个数是另一个数的倍数。</li></ul><p>&emsp;&emsp;$m \le 3 \cdot 10^5,\ m \le n \le 2m$<br>&emsp;&emsp;$1 \le a_1 &lt; a_2 &lt; \cdots &lt; a_n \le 2m$<br>&emsp;&emsp;2s</p><span id="more"></span><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>&emsp;&emsp;如果建出一个“倍数关系图”，那么每次询问就是去掉一个点之后求最大独立集，这就很不可做，所以这个倍数关系一定是要利用的。<br>&emsp;&emsp;子集大小为 $m$ 而每个数最多只有 $2m$，看着就有玄机，只是没想到竟然是这样用的。。。</p><p>&emsp;&emsp;每个 $a_i$ 可以表示成 $2^c \cdot d$，其中 $d$ 为奇数。按照 $d=1,3,\cdots,2m-1$ 把所有的 $a_i$ 分门别类放好，这样总共有 $m$ 个类，且每个类最多只能选 1 个数，又因为最后要选 $m$ 个数，因此每个类恰好选一个数。<br>&emsp;&emsp;考虑如果选了 $2^{c_1}d_1$ 和 $2^{c_2}d_2$，如果 $d_1 | d_2$，那么必须有 $c_1 &gt; c_2$。因此直观来看，$d$ 较小的类 $c$ 应该较大，$d$ 较大的类 $c$ 应该较小。因此可以用 $O(m \log m)$ 的时间从左到右、从右到左分别求出每个类的 $c$ 的上限和下限，那么只要夹在上限和下限之间的数都一定是可行的（比它小的类全部选上限、比它大的类全部选下限即可）。</p><p>&emsp;&emsp;虽然它真的很巧妙，不过似乎只能用于判断 $m$ 为“$d$ 的种类数”是否可行。能用于判断比这更小的 $m$ 是否可行吗？</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">6e5</span>+<span class="number">5</span>, maxm=<span class="number">6e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; V[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Invalid</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> L[maxm],R[maxm],lim[maxm];</span><br><span class="line"><span class="type">bool</span> ans[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line"><span class="type">int</span> er=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!(a&amp;<span class="number">1</span>)) a&gt;&gt;=<span class="number">1</span>, er++;</span><br><span class="line">V[a].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(er,i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">2</span>*m; i+=<span class="number">2</span>) <span class="keyword">if</span> (V[i].<span class="built_in">empty</span>()) <span class="built_in">Invalid</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(lim,<span class="number">127</span>,<span class="built_in">sizeof</span>(lim));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">2</span>*m; i+=<span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (lim[i]&lt;=(V[i].<span class="built_in">begin</span>())-&gt;first) <span class="built_in">Invalid</span>();</span><br><span class="line">R[i]=(<span class="built_in">lower_bound</span>(V[i].<span class="built_in">begin</span>(),V[i].<span class="built_in">end</span>(),<span class="built_in">make_pair</span>(lim[i],<span class="number">0</span>))<span class="number">-1</span>)-&gt;first;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i*<span class="number">3</span>; j&lt;<span class="number">2</span>*m; j+=i+i) lim[j]=<span class="built_in">min</span>(lim[j],R[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>*m<span class="number">-1</span>; i&gt;<span class="number">0</span>; i-=<span class="number">2</span>) &#123;</span><br><span class="line"><span class="type">int</span> lim=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i*<span class="number">3</span>; j&lt;<span class="number">2</span>*m; j+=i+i) lim=<span class="built_in">max</span>(lim,L[j]);</span><br><span class="line"><span class="keyword">if</span> (lim&gt;=(V[i].<span class="built_in">rbegin</span>())-&gt;first) <span class="built_in">Invalid</span>();</span><br><span class="line">L[i]=<span class="built_in">upper_bound</span>(V[i].<span class="built_in">begin</span>(),V[i].<span class="built_in">end</span>(),<span class="built_in">make_pair</span>(lim,n+<span class="number">1</span>))-&gt;first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">2</span>*m; i+=<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p:V[i]) ans[p.second]=(L[i]&lt;=p.first &amp;&amp; p.first&lt;=R[i]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">puts</span>(ans[i] ?<span class="string">&quot;Yes&quot;</span> :<span class="string">&quot;No&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;给定长度为 $n$ 的序列 $a_1,\cdots,a_n$ 和一个参数 $m$，对于每个 $i$，问是否能从序列中选出满足如下条件的子集：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集合包含 $a_i$；&lt;/li&gt;
&lt;li&gt;集合大小为 $m$；&lt;/li&gt;
&lt;li&gt;集合内不存在一个数是另一个数的倍数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;$m \le 3 \cdot 10^5,\ m \le n \le 2m$&lt;br&gt;&amp;emsp;&amp;emsp;$1 \le a_1 &amp;lt; a_2 &amp;lt; \cdots &amp;lt; a_n \le 2m$&lt;br&gt;&amp;emsp;&amp;emsp;2s&lt;/p&gt;</summary>
    
    
    
    <category term="OI/ACM" scheme="http://kqp.world/categories/OI-ACM/"/>
    
    
    <category term="算法_神奇的脑洞" scheme="http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>【AtCoder Grand 037D】Sorting a Grid 题解</title>
    <link href="http://kqp.world/%E3%80%90AtCoder%20Grand%20037D%E3%80%91Sorting%20a%20Grid%20%E9%A2%98%E8%A7%A3/"/>
    <id>http://kqp.world/%E3%80%90AtCoder%20Grand%20037D%E3%80%91Sorting%20a%20Grid%20%E9%A2%98%E8%A7%A3/</id>
    <published>2022-05-07T07:43:17.000Z</published>
    <updated>2022-05-07T08:09:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>&emsp;&emsp;给定一个 $n$ 行 $m$ 列的矩阵，里面的元素是 $1,\cdots,nm$ 每个恰好出现一次。依次执行以下操作：</p><ol><li>对每一行任意重排；</li><li>对每一列任意重排；</li><li>对每一行任意重排，</li></ol><p>使得最后矩阵第 $i$ 行第 $j$ 列恰好是 $i(m-1)+j$。输出一种方案（第 1 步和第 2 步后的结果）。可证明一定有解。</p><p>&emsp;&emsp;$n, m \le 100$<br>&emsp;&emsp;2s</p><span id="more"></span><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>&emsp;&emsp;一些简单的推导：把一个元素属于第几行（即除以 $m$ 上取整）叫做它的颜色。第 3 步对每一行重排，因此第 2 步结束后肯定是每个元素都去到了它所在的行，这时候每一列包含每种颜色恰好一个，这也是第 1 步要达成的效果。因此问题变成：每行重排，使得每列包含每种颜色恰好一个。<br>&emsp;&emsp;这时候就能嗅到匹配的味道了，但具体怎么匹配还是有点技巧。<br>&emsp;&emsp;题解给的做法是一列一列确定。建一个二分图，左边 $n$ 个点表示行，右边 $n$ 个点表示颜色，连边表示这一行有这种颜色。这个二分图是有完美匹配的（证明：Hall 定理，任取左边若干个点，它连向右边的点表示选取的行总共包含了多少种颜色，这不可能比行数少，不然就有颜色超过 $m$ 个了），把这个完美匹配拉出来作为第 1 列，剩下的变成 $(n,m-1)$ 的子问题了，因此总共做 $m$ 次二分图匹配就好了。</p><p>&emsp;&emsp;官方题解给的有完美匹配的证明似乎有点问题，它说二分图每个点的度数都是 $m$ 因此符合 Hall 定理，但这“度数为 $m$”是有重边的，不能直接应用 Hall 定理。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,a[maxn][maxn],b[maxn][maxn],br[maxn][maxn],c[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getr</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x)</span> </span>&#123;<span class="keyword">return</span> (x+m<span class="number">-1</span>)/m;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[maxn],bz[maxn];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Hung</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> tim)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bz[k]==tim) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">bz[k]=tim;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> go:e[k]) <span class="keyword">if</span> (!f[go] || <span class="built_in">Hung</span>(f[go],tim)) &#123;</span><br><span class="line">f[go]=k;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line"><span class="built_in">fo</span>(j,<span class="number">1</span>,m) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line"><span class="built_in">sort</span>(a[i]+<span class="number">1</span>,a[i]+<span class="number">1</span>+m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tm=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">fo</span>(j,<span class="number">1</span>,m) &#123;</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) e[i].<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line"><span class="built_in">fo</span>(k,j,m) <span class="keyword">if</span> (k==j || <span class="built_in">getr</span>(a[i][k])!=<span class="built_in">getr</span>(a[i][k<span class="number">-1</span>])) &#123;</span><br><span class="line"><span class="type">int</span> r=<span class="built_in">getr</span>(a[i][k]);</span><br><span class="line">e[i].<span class="built_in">push_back</span>(r);</span><br><span class="line">br[i][r]=k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">Hung</span>(i,++tm);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line"><span class="type">int</span> ii=f[i];</span><br><span class="line">b[ii][j]=a[ii][br[ii][i]];</span><br><span class="line">a[ii][br[ii][i]]=<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">sort</span>(a[ii]+<span class="number">1</span>,a[ii]+<span class="number">1</span>+m);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line"><span class="built_in">fo</span>(j,<span class="number">1</span>,m) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i][j]);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fo</span>(j,<span class="number">1</span>,m) &#123;</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) c[i]=b[i][j];</span><br><span class="line"><span class="built_in">sort</span>(c+<span class="number">1</span>,c+<span class="number">1</span>+n);</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) b[i][j]=c[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line"><span class="built_in">fo</span>(j,<span class="number">1</span>,m) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i][j]);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;给定一个 $n$ 行 $m$ 列的矩阵，里面的元素是 $1,\cdots,nm$ 每个恰好出现一次。依次执行以下操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对每一行任意重排；&lt;/li&gt;
&lt;li&gt;对每一列任意重排；&lt;/li&gt;
&lt;li&gt;对每一行任意重排，&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使得最后矩阵第 $i$ 行第 $j$ 列恰好是 $i(m-1)+j$。输出一种方案（第 1 步和第 2 步后的结果）。可证明一定有解。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;$n, m \le 100$&lt;br&gt;&amp;emsp;&amp;emsp;2s&lt;/p&gt;</summary>
    
    
    
    <category term="OI/ACM" scheme="http://kqp.world/categories/OI-ACM/"/>
    
    
    <category term="算法_网络流/匹配" scheme="http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BD%91%E7%BB%9C%E6%B5%81-%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>【CF1580E】Railway Construction 题解</title>
    <link href="http://kqp.world/%E3%80%90CF1580E%E3%80%91Railway-Construction-%E9%A2%98%E8%A7%A3/"/>
    <id>http://kqp.world/%E3%80%90CF1580E%E3%80%91Railway-Construction-%E9%A2%98%E8%A7%A3/</id>
    <published>2022-04-25T07:20:49.000Z</published>
    <updated>2022-04-25T09:11:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>&emsp;&emsp;给定一幅 $n$ 个点 $m$ 条边的带权无向图（权值表示距离），现在想要加一些单向边，权值自定（需是正整数），使得：</p><ul><li>从 $1$ 号点到每个点的最短路长度不变；</li><li>从 $1$ 号点到每个点都有至少两条点不相交的最短路径。</li></ul><p>&emsp;&emsp;新建一条从 $u$ 号点出发的单向边代价为 $w_u$。求最小代价。<br>&emsp;&emsp;以及有 $q$ 次修改操作，每次选择一个点 $k$ 把 $w_k$ 增加 $x$。</p><p>&emsp;&emsp;$n \le 2 \times 10^5,\ m \le 3 \times 10^5,\ q \le 2 \times 10^5$<br>&emsp;&emsp;$1 \le w_i \le 10^9$，初始边权 $d$ 满足 $1 \le d \le 10^9$，每次操作增加的代价 $x_i$ 满足 $1 \le x_i \le 4 \times 10^8$。<br>&emsp;&emsp;2.5s</p><span id="more"></span><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>&emsp;&emsp;<del>中国特色数据结构题</del></p><p>&emsp;&emsp;首先考虑无修改怎么做。这种情况的推导是自然流畅的：<br>&emsp;&emsp;原始图做了最短路之后可以得到一幅最短路图（只保留最短路边的 DAG），后面就都在这个最短路图上讨论了。稍加观察可以发现，如果一个点的入度至少为 $2$，那么当它的前驱满足了“至少有两条点不相交的最短路径”之后，它也会自然满足这个条件。简单证明：如下图，对于点 $x$，假设它有前驱 $y$ 和 $z$，其中 $y$ 不是 $z$ 的必经点（否则交换 $y$ 和 $z$），$y$ 有两条点不相交的最短路径 $p_1,p_2$。任取一条从 $1$ 到 $z$ 不经过 $y$ 的路径，假设最后与 $p_1,p_2$ 交在点 $v$，那么 $1 \to p_1 \to y \to x$ 和 $1 \to p_2 \to v \to z \to x$ 就是 $x$ 的两条点不相交的最短路。<br><img src="/images/cf1580e.png" alt=""><br>&emsp;&emsp;这样一来，就只有最短路图上入度为 $1$ 的点是需要关注的关键点了。对于每个关键点，当然是在最短路长度 $dis$ 比它小的点里找 $w$ 最小的连过来了（这样就能使它入度 $&gt;1$ 了），但如果这个点是它的直接父亲且不为 $1$，那就要找 $w$ 次小的了。<br>&emsp;&emsp;所以无修改的版本就是把点按 $dis$ 排序，每个点在前面找 $w$ 的最小和次小。</p><p>&emsp;&emsp;带修改就有点米奇妙妙屋了。<br>&emsp;&emsp;首先倒序处理操作，把增加代价变成减少代价，要好做些，因为增加代价是把最小值和次小值分散出去，而减少代价是把最小值和次小值聚集过来。<br>&emsp;&emsp;这里的分段现象比较明显（连续一段数最(次)小值值相同），考虑用 set 维护这些段，用 $S_1$ 维护最小值相同的连续段及段内需要使用最小值的关键点数量，用 $S_2$ 维护次小值相同的连续段及段内需要使用次小值的关键点数量。当减小点 $k$ 的代价 $w_k$ 时，从第一个 $&gt;dis_k$ 的点开始，先修改 $S_1$，即把最小值 $&gt;w_k$ 的段合并起来并且把这个原最小值变为次小值丢到 $S_2$ 里；再修改 $S_2$，即把次小值 $&gt;w_k$ 的段合并起来。维护关键点数量需要 lower_bound 之类的求一个节点在一个区间内的儿子数量，用关键点数量就可以维护答案了。<br>&emsp;&emsp;分析一下时间复杂度。初始每个 set 最多有 $n$ 个段，每次修改操作，可能要在初始位置把一个段给断开（即新增一个段）。对于 $S_1$，剩下的就都是合并操作了，所以总段数是 $O(n+q)$ 的，复杂度 $O((n+q) \log (n+q))$。对于 $S_2$，还会在更新最小值的时候产生次小值的新段，但每个最小值段最多只会贡献一个次小值段（贡献完它就被合并了），所以总段数仍然是 $O(n+q)$ 的，复杂度 $O((n+q) \log (n+q))$。</p><p>&emsp;&emsp;注意，有一种写法是按“最小值与次小值都相同”对序列分段，只用一个 set。这个复杂度是不对的，如果有很多很多段，这些段的最小值相同，次小值不同，而每次操作都把这个最小值再减小，那就每次操作都要把这些段都遍历一遍了。</p><p>&emsp;&emsp;注意一些细节，比如如果最小值次小值记录的是节点标号而不是具体的值，就要注意最小值来源不变但值减少了的情况；比如答案会爆 long long，要 unsigned long long。</p><h2 id="扯淡"><a href="#扯淡" class="headerlink" title="扯淡"></a>扯淡</h2><p>&emsp;&emsp;可能可以把一些 set 操作换成线段树？就像题解写的那样。</p><p>&emsp;&emsp;比较搞笑的是，在我本地拍的时候，上面说的“只用一个 set 维护最小值和次小值都相同的段”的写法跑得比分开两个 set 的写法还要快。。。不过前者交上去就 T 了。<br>&emsp;&emsp;（并且在拍的过程中还卡 T 了一个跑得飞快的老哥。。。可惜现在不能 hack 了 QAQ</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>// 实现细节比较多，修修补补会变得特别丑，建议少看（x</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,a,b) for(int i=a;i&gt;=b;i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">2e5</span>+<span class="number">5</span>, maxq=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SEG</span> &#123;</span><br><span class="line"><span class="type">int</span> l,r,minw,num;</span><br><span class="line"><span class="built_in">SEG</span>(<span class="type">int</span> l0,<span class="type">int</span> r0,<span class="type">int</span> minw0,<span class="type">int</span> num0) &#123;l=l0, r=r0, minw=minw0, num=num0;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> SEG &amp;a,<span class="type">const</span> SEG &amp;b) &#123;<span class="keyword">return</span> a.r&lt;b.r;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,q,qk[maxq],qx[maxq];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; e[maxn];</span><br><span class="line">ULL w[maxn];</span><br><span class="line"></span><br><span class="line">LL dis[maxn];</span><br><span class="line"><span class="type">int</span> d[maxn],d0;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dis,<span class="number">127</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">priority_queue&lt;pair&lt;LL,<span class="type">int</span>&gt;&gt; Q;</span><br><span class="line">Q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0ll</span>,<span class="number">1</span>));</span><br><span class="line"><span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">auto</span> tp=Q.<span class="built_in">top</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">int</span> cur=tp.second;</span><br><span class="line"><span class="keyword">if</span> (-tp.first!=dis[cur]) <span class="keyword">continue</span>;</span><br><span class="line">d[++d0]=cur;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> go:e[cur]) <span class="keyword">if</span> (dis[go.first]&gt;dis[cur]+go.second) &#123;</span><br><span class="line">dis[go.first]=dis[cur]+go.second;</span><br><span class="line">Q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-dis[go.first],go.first));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; son[maxn];</span><br><span class="line">set&lt;SEG&gt; S1,S2;</span><br><span class="line"><span class="type">int</span> indg[maxn],fa[maxn],st[maxn],keynum[maxn];</span><br><span class="line">ULL ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> go:e[i]) <span class="keyword">if</span> (dis[i]+go.second==dis[go.first]) &#123;</span><br><span class="line">indg[go.first]++;</span><br><span class="line">fa[go.first]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SEG <span class="title">min1</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>)</span>, <span class="title">min2</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(st,<span class="number">127</span>,<span class="built_in">sizeof</span>(st));</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">2</span>,n) &#123;</span><br><span class="line"><span class="type">int</span> cur=d[i];</span><br><span class="line"><span class="type">int</span> minw1=min1.minw, minw2=min2.minw;</span><br><span class="line"><span class="keyword">for</span>(; j&lt;=n &amp;&amp; dis[d[j]]&lt;dis[cur]; j++) &#123;</span><br><span class="line">st[d[j]]=i;</span><br><span class="line"><span class="keyword">if</span> (w[d[j]]&lt;w[minw1]) minw2=minw1, minw1=d[j];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (w[d[j]]&lt;w[minw2]) minw2=d[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (minw1!=min1.minw || minw2!=min2.minw) &#123;</span><br><span class="line"><span class="keyword">if</span> (min2.l&lt;=min2.r) S2.<span class="built_in">insert</span>(min2);</span><br><span class="line">min2=<span class="built_in">SEG</span>(min2.r+<span class="number">1</span>,i,minw2,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (minw1!=min1.minw) &#123;</span><br><span class="line"><span class="keyword">if</span> (min1.l&lt;=min1.r) S1.<span class="built_in">insert</span>(min1);</span><br><span class="line">min1=<span class="built_in">SEG</span>(min1.r+<span class="number">1</span>,i,minw1,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">keynum[i]=keynum[i<span class="number">-1</span>]+(indg[cur]==<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (indg[cur]==<span class="number">1</span>) &#123;</span><br><span class="line">son[fa[cur]].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">if</span> (fa[cur]!=<span class="number">1</span> &amp;&amp; fa[cur]==minw1) &#123;</span><br><span class="line">min2.num++;</span><br><span class="line">ans+=w[minw2];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">min1.num++;</span><br><span class="line">ans+=w[minw1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">min1.r=min2.r=i;</span><br><span class="line">&#125;</span><br><span class="line">S1.<span class="built_in">insert</span>(min1);</span><br><span class="line">S2.<span class="built_in">insert</span>(min2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> minw)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (minw==<span class="number">1</span>) ?<span class="number">0</span> :<span class="built_in">upper_bound</span>(son[minw].<span class="built_in">begin</span>(),son[minw].<span class="built_in">end</span>(),r)-<span class="built_in">upper_bound</span>(son[minw].<span class="built_in">begin</span>(),son[minw].<span class="built_in">end</span>(),l<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cut_cur</span><span class="params">(set&lt;SEG&gt; &amp;S,<span class="type">int</span> pos,<span class="type">int</span> ty)</span> </span>&#123;</span><br><span class="line">set&lt;SEG&gt;::iterator it=S.<span class="built_in">lower_bound</span>(<span class="built_in">SEG</span>(<span class="number">0</span>,pos,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line"><span class="keyword">if</span> (it==S.<span class="built_in">end</span>() || it-&gt;l==pos) <span class="keyword">return</span>;</span><br><span class="line">SEG t=*it;</span><br><span class="line">S.<span class="built_in">erase</span>(it);</span><br><span class="line"><span class="keyword">if</span> (ty==<span class="number">1</span>) &#123;</span><br><span class="line">S.<span class="built_in">insert</span>(<span class="built_in">SEG</span>(t.l, pos<span class="number">-1</span>, t.minw, keynum[pos<span class="number">-1</span>]-keynum[t.l<span class="number">-1</span>]-<span class="built_in">get_num</span>(t.l,pos<span class="number">-1</span>,t.minw)));</span><br><span class="line">S.<span class="built_in">insert</span>(<span class="built_in">SEG</span>(pos, t.r, t.minw, keynum[t.r]-keynum[pos<span class="number">-1</span>]-<span class="built_in">get_num</span>(pos,t.r,t.minw)));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">S.<span class="built_in">insert</span>(<span class="built_in">SEG</span>(t.l, pos<span class="number">-1</span>, t.minw, <span class="built_in">get_num</span>(t.l,pos<span class="number">-1</span>,(S1.<span class="built_in">lower_bound</span>(<span class="built_in">SEG</span>(<span class="number">0</span>,t.l,<span class="number">0</span>,<span class="number">0</span>)))-&gt;minw)));</span><br><span class="line">S.<span class="built_in">insert</span>(<span class="built_in">SEG</span>(pos, t.r, t.minw, <span class="built_in">get_num</span>(pos,t.r,(S1.<span class="built_in">lower_bound</span>(<span class="built_in">SEG</span>(<span class="number">0</span>,pos,<span class="number">0</span>,<span class="number">0</span>)))-&gt;minw)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ULL Ans[maxn],w_old[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">LL x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x);</span><br><span class="line">w[i]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,m) &#123;</span><br><span class="line"><span class="type">int</span> u,v,d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;u,&amp;v,&amp;d);</span><br><span class="line">e[u].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(v,d)), e[v].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(u,d));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,q) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;qk[i],&amp;qx[i]);</span><br><span class="line">w[qk[i]]+=qx[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dijkstra</span>();</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(w_old,w,<span class="built_in">sizeof</span>(w));</span><br><span class="line"><span class="built_in">fd</span>(i,q,<span class="number">1</span>) &#123;</span><br><span class="line">Ans[i]=ans;</span><br><span class="line"><span class="type">int</span> cur=qk[i];</span><br><span class="line">w[cur]-=qx[i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">cut_cur</span>(S1,st[cur],<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cut_cur</span>(S2,st[cur],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// minw1</span></span><br><span class="line"><span class="type">int</span> tl=st[cur], tr=tl<span class="number">-1</span>, tnum=<span class="number">0</span>;</span><br><span class="line">set&lt;SEG&gt;::iterator it=S1.<span class="built_in">lower_bound</span>(<span class="built_in">SEG</span>(<span class="number">0</span>,tl,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line"><span class="keyword">while</span> (it!=S1.<span class="built_in">end</span>() &amp;&amp; w[cur]&lt;w_old[it-&gt;minw]) &#123;</span><br><span class="line">SEG t=*it;</span><br><span class="line"><span class="keyword">if</span> (t.minw==cur) &#123;</span><br><span class="line">ans-=(ULL)t.num*qx[i];</span><br><span class="line">it++;</span><br><span class="line">tl=t.r+<span class="number">1</span>, tr=t.r;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans-=t.num*w_old[t.minw];</span><br><span class="line">S1.<span class="built_in">erase</span>(it++);</span><br><span class="line">set&lt;SEG&gt;::iterator it2=S2.<span class="built_in">lower_bound</span>(<span class="built_in">SEG</span>(<span class="number">0</span>,t.l,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line"><span class="keyword">while</span> (it2!=S2.<span class="built_in">end</span>() &amp;&amp; it2-&gt;l&lt;=t.r) &#123;</span><br><span class="line">ans-=w_old[it2-&gt;minw]*it2-&gt;num;</span><br><span class="line">S2.<span class="built_in">erase</span>(it2++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> num=<span class="built_in">get_num</span>(t.l,t.r,cur);</span><br><span class="line">ans+=w[t.minw]*num;</span><br><span class="line">S2.<span class="built_in">insert</span>(<span class="built_in">SEG</span>(t.l,t.r,t.minw,num));</span><br><span class="line">tnum+=keynum[t.r]-keynum[t.l<span class="number">-1</span>]-num;</span><br><span class="line">tr=t.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tl&lt;=tr) &#123;</span><br><span class="line">ans+=tnum*w[cur];</span><br><span class="line">S1.<span class="built_in">insert</span>(<span class="built_in">SEG</span>(tl,tr,cur,tnum));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// minw2</span></span><br><span class="line">tl=tr+<span class="number">1</span>;</span><br><span class="line">tnum=<span class="number">0</span>;</span><br><span class="line">it=S2.<span class="built_in">lower_bound</span>(<span class="built_in">SEG</span>(<span class="number">0</span>,tl,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line"><span class="keyword">while</span> (it!=S2.<span class="built_in">end</span>() &amp;&amp; w[cur]&lt;w_old[it-&gt;minw]) &#123;</span><br><span class="line">tr=it-&gt;r;</span><br><span class="line">tnum+=it-&gt;num;</span><br><span class="line">ans-=it-&gt;num*w_old[it-&gt;minw];</span><br><span class="line">S2.<span class="built_in">erase</span>(it++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tl&lt;=tr) &#123;</span><br><span class="line">ans+=tnum*w[cur];</span><br><span class="line">S2.<span class="built_in">insert</span>(<span class="built_in">SEG</span>(tl,tr,cur,tnum));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">w_old[cur]-=qx[i];</span><br><span class="line">&#125;</span><br><span class="line">Ans[<span class="number">0</span>]=ans;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">0</span>,q) <span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span>,Ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;给定一幅 $n$ 个点 $m$ 条边的带权无向图（权值表示距离），现在想要加一些单向边，权值自定（需是正整数），使得：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从 $1$ 号点到每个点的最短路长度不变；&lt;/li&gt;
&lt;li&gt;从 $1$ 号点到每个点都有至少两条点不相交的最短路径。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;新建一条从 $u$ 号点出发的单向边代价为 $w_u$。求最小代价。&lt;br&gt;&amp;emsp;&amp;emsp;以及有 $q$ 次修改操作，每次选择一个点 $k$ 把 $w_k$ 增加 $x$。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;$n \le 2 \times 10^5,\ m \le 3 \times 10^5,\ q \le 2 \times 10^5$&lt;br&gt;&amp;emsp;&amp;emsp;$1 \le w_i \le 10^9$，初始边权 $d$ 满足 $1 \le d \le 10^9$，每次操作增加的代价 $x_i$ 满足 $1 \le x_i \le 4 \times 10^8$。&lt;br&gt;&amp;emsp;&amp;emsp;2.5s&lt;/p&gt;</summary>
    
    
    
    <category term="OI/ACM" scheme="http://kqp.world/categories/OI-ACM/"/>
    
    
    <category term="算法_图论" scheme="http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="算法_平衡树/set" scheme="http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%B9%B3%E8%A1%A1%E6%A0%91-set/"/>
    
  </entry>
  
  <entry>
    <title>偶像作品衍生的美学文学哲学 open problems</title>
    <link href="http://kqp.world/%E5%81%B6%E5%83%8F%E4%BD%9C%E5%93%81%E8%A1%8D%E7%94%9F%E7%9A%84%E7%BE%8E%E5%AD%A6%E5%93%B2%E5%AD%A6%20open%20problems/"/>
    <id>http://kqp.world/%E5%81%B6%E5%83%8F%E4%BD%9C%E5%93%81%E8%A1%8D%E7%94%9F%E7%9A%84%E7%BE%8E%E5%AD%A6%E5%93%B2%E5%AD%A6%20open%20problems/</id>
    <published>2022-04-10T08:33:05.000Z</published>
    <updated>2022-05-05T04:08:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;其实偶像作品中也有很多很有趣的美学、哲学、艺术问题可以思考。我逐渐觉得我应该再修一个艺术理论的学位，去读一些书。<br>&emsp;&emsp;<del>博客逐渐变成了奇怪的形状</del></p><span id="more"></span><p>&emsp;&emsp;现在还只是一个理工科学生道听途说了一些美学、哲学概念，然后胡乱做一些思考罢了，书和 paper 也没读过多少。毕竟不是专业，不知道能消耗多少时间在这上面，只能是说读了更多的书和 paper 以后慢慢修正。</p><h2 id="美的创作过程的分离与异化"><a href="#美的创作过程的分离与异化" class="headerlink" title="美的创作过程的分离与异化"></a>美的创作过程的分离与异化</h2><h3 id="一个较长的-intro"><a href="#一个较长的-intro" class="headerlink" title="一个较长的 intro"></a>一个较长的 intro</h3><p>&emsp;&emsp;3 月 3 号 liella 的生放谈了一专里每一个人的 solo，香音那首比较独特，主要是歌词，初读可以说怪得很，不知道什么原因就对着一个人说大嫌い，一整首歌都在讨厌你讨厌你，却又在结尾的时候突然变成大好き了，很难懂的感情。这场生放里小百合似乎是给出了解释，不过我没有听懂生肉，结合弹幕的同传师爷和其他人的表现，看上去是小百合给出了深层次的解读，并不是浮于歌词表面的样子。<br>&emsp;&emsp;所以今天就想要补这场熟肉，想要更好地理解这首歌。然而，却发现小百合并不是在解释歌词内涵，她讲了一堆与此不太相关的东西。她首先提到这个“君”可能不是人类，可以理解成一个香音最喜欢的人，但也说“一千个观众有一千个‘君’”，具体她的理解没有明说。她说以前读了歌词然后按自己的理解唱，但这次行不通，这跟香音的风格差了太多，需要主动走进香音。她说巡演期间录的歌，正好对唱歌思考了很多。她说不是单纯地歌唱低落，不是悲しみ，不是切ない。总之说了一通，大概就是两个重点，一我确乎没有明白这个“君”到底是谁，香音为什么对他大嫌い，又为什么突然转成了大好き；二是小百合明白了吗，不知道，她只是给出了自己的解答。<br>&emsp;&emsp;所以这个出新歌的过程是这样的，作曲人、作词人把作品交给小百合，小百合开始做阅读理解，然后交上一份答卷。答得对不对呢？小百合自己也说，以前就不太管，香音不这么理解但是小百合这么理解的。所以我们说我们在欣赏一首歌的时候，我们到底在欣赏什么呢？欣赏歌曲的旋律，这是对作曲人的；欣赏歌词的文学艺术，这是对作词人的。那么小百合是什么呢？一个发声工具，和一个做阅读理解的考生。那么到底谁才是涉谷香音呢？不是小百合了。<br>&emsp;&emsp;LoveLive 毕竟是偶像企划，绝大多数歌曲其实表意很清晰，没什么能过多分析的。比如“僕らの勢いは四方八方九方”，这种歌词也没法存在第二种解读，结合水水的经历，声优们就能跟作词达成共识，很容易就能把这个内涵表达出来了。这个时候，Aqours 和声优 Aqours 是站在一起的。但是像这次，或者以后作词人还想在歌词中表达些什么更深刻的，更隐晦一点的，那么歌曲、声优、角色就全都分离开了。<br>&emsp;&emsp;记得去年读了一本讲美学和美育的哲学书，里面就提到了美的创作的异化。以前是由创作主体完成整个美的创作过程，因此在过程中主体完成了审美，而现在这个创作过程是分离的，造成审美也是破碎的。一首现代歌曲的作曲、作词、演唱的分离恰恰是此书里的例子，歌手很难把自己的感情、经历等审美要素代入这首歌，因为这首歌压根就不是他参与创作的。<br>&emsp;&emsp;所以尽管小百合很用力去研究香音唱这首歌的心境，总是听着少了真情实感。以前咻卡也这样，夜空知晓一切的现场版也这样，只是在用一些歌唱技巧去制造低落、伤感的情绪，很容易用力过猛，然后变得假起来。在这个过程中她们本应是讲故事的人，但现在只是转述故事的人，这个故事就不是她们的故事。<br>&emsp;&emsp;难免还是要对如今的商业模式做出思考。当然，作词作曲演唱这三者的分离是不可避免的，不这么分化大家都得饿死。但是，如果一味迁就，那就会让偶像的意义越发模糊。要我提出观点的话，我认为偶像本身应该参与创作，至少，作词和偶像应当有一个合作与交流，让歌词成为共同完成的作品，从而得到文学、角色人设、演出者生活经历三者的结合。<br>&emsp;&emsp;回到这首歌本身，最好的解读还是来信里提到的，开始是对歌唱的讨厌，歌唱带给了她不好的经历，但触及心底，发现对于歌唱还是要说热爱。我们所希望的是，这是香音的想法，香音怀着这份心情唱了出来，而不是香音看了别人寄给她的稿子想到了这些然后唱了出来。</p><h2 id="创作与观众的关系"><a href="#创作与观众的关系" class="headerlink" title="创作与观众的关系"></a>创作与观众的关系</h2><p>&emsp;&emsp;虹第二季第二话 Q4 劝岚珠的场景，体现了两种不同的表演理念的冲突。发现这也是我思考的一个问题：表演者应该为自己而创作，还是为粉丝而创作？<br>&emsp;&emsp;这是两种不同的追求。一种是追求艺术本身的，我是为了歌唱，舞蹈，我的艺术理念，展现自我的风格，所以来表演，我不是为了在观众这里获得人气和支持。而一种是我希望带给粉丝一些东西，比如欢乐，感动，坚定的信念，传递各种気持ち，我希望能与观众产生共鸣。<br>&emsp;&emsp;Lovelive 的定位是后者，是偶像和粉丝一起完成的企划，粉丝投票选出了 c 位，选出了歌词中的关键词，选衣服，选一堆东西，所以歌曲也和粉丝结合得很紧密，总是要君と一緒に这样的。所以如果在这些特定的企划里寻找答案，那几乎是唯一的。但相比起来，也正如岚珠所说，前者是更加随心所欲的，它可以在创作上更纯粹，因为审美主体很大程度被创作者选择了，就是自己这一类的主体。<br>&emsp;&emsp;当然岚珠很可能会走到一个矛盾里，她固然是需要受众的，而且是广泛的受众，因为她的目标学园偶像，到底有没有纯粹的表现自我的学园偶像呢？可能这就不是学园偶像的定义了。<br>&emsp;&emsp;但是抛开学园偶像这个追求和身份，这就是艺术和观众的联系问题了。尽管在一定的哲学体系下，这已经是一个相当成熟的问题了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;其实偶像作品中也有很多很有趣的美学、哲学、艺术问题可以思考。我逐渐觉得我应该再修一个艺术理论的学位，去读一些书。&lt;br&gt;&amp;emsp;&amp;emsp;&lt;del&gt;博客逐渐变成了奇怪的形状&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="杂写" scheme="http://kqp.world/categories/%E6%9D%82%E5%86%99/"/>
    
    
  </entry>
  
  <entry>
    <title>Aqours 6th 巨蛋收集计划</title>
    <link href="http://kqp.world/Aqours-6th-%E5%B7%A8%E8%9B%8B%E6%94%B6%E9%9B%86%E8%AE%A1%E5%88%92/"/>
    <id>http://kqp.world/Aqours-6th-%E5%B7%A8%E8%9B%8B%E6%94%B6%E9%9B%86%E8%AE%A1%E5%88%92/</id>
    <published>2022-02-14T02:25:56.000Z</published>
    <updated>2022-05-23T12:22:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;继“Aqours 东蛋之路”后，现在差不多可以开始起草“Aqours 蛋巡之路”了。。。<br><span id="more"></span><br>&emsp;&emsp;2020初宣布五蛋巡，本以为一路顺利在人气巅峰创下声优偶像最高成就，却因为疫情，一度将近两年开不了9人 live。起起落落，开开停停，一路上不断有 live 开催又延期又终止。最终勉强把两次小组 live 开起来（说勉强是因为缺了老王），在声优的请求下开了 dreamy concert，逢田姐甚至直言：“两年不开 live，粉丝都掉了一大半。”五蛋巡被迫向疫情屈服，只剩下两个蛋，千言万语汇成一句话：蛋巡尚未成功，同志仍需努力。</p><h3 id="Ocean-Stage"><a href="#Ocean-Stage" class="headerlink" title="Ocean Stage"></a>Ocean Stage</h3><p>&emsp;&emsp;Ocean Stage Day1 在开学前，学校吃土群组织不起来，只能是去广州转播场。这次是跟漫展认识的雪雪人以及贴吧网友萤火虫 staff 一起。对于广州大场的印象就是虎上加虎，果不其然，这次又见到了经典熟悉的“南方灯光展”“南方动物园”，仿佛回到了两年前的南方剧院里的 5th。</p><p>&emsp;&emsp;而这场 6th，也无处不渗透着 5th 的气息。<br>&emsp;&emsp;不会想到在开场听到 hop stop nonstop，气氛一下就回到了 5th 的剧场版主题了。接连几首动画曲也在告诉大家，动画曲和剧场版曲不是某些数字 live 独有的，以后总会源源不断地听到。姐姐那句俏皮可爱的“デキナカッタコトガデキタリ”仍然使得全场爆发。<br>&emsp;&emsp;天花板上 kurukuru 的那条龙，像个吊死鬼一样飘着。<br>&emsp;&emsp;一二年级分别唱完以后，仍在猜测三年级会唱哪一首，是特典还是剧场版，然而音乐一响，居然是鞠南的泪水化为雪花。明显感受到整个观众席都虎躯一震。这是冬 2223 的第一次现场表演，鞠南的 CD 唱功（sww是没开麦呢还是神速进步了呢？）、高虐拥抱；曜梨的贵妇服装、专业舞蹈、白学对视、奇卡背景；花露的活泼欢快、sif 音效；宫林波的手捧白碟、认真过节、情人节礼物，实在是尽显特色。<br>&emsp;&emsp;两个幕间都是没内容的金曲 medley，十分敷衍。<br>&emsp;&emsp;接下来小姐姐们穿着私服出场了，几位时尚达人（喵香王）的衣服很漂亮，杏似乎是比较保守的。私服打了海盗、白日梦、君瞳三首热气氛的歌，效果非常好，甚至有韩舞的感觉，咻卡抡大旗的动作似乎改了，改得更魅惑了。然而往下的几首动画曲，穿着私服跳，味道却是不对的，水族馆的ゆらゆら的动作非得穿二单服才有鱼的感觉，水蓝没有了脱衣服也丢掉了朝向新世界的寓意。后来换回了 op1 的衣服是挺好的（据说还改新了，增加了亮片），咻卡的样貌回到了 18 年，想起了鲤鱼锐评 op1 袜子。<br>&emsp;&emsp;live 前流传出了彩虹光路企划，果然，安可一开始，彩虹就形成了。这就像是对逢田姐的回应，时隔两年，彩虹仍在，粉丝一个没跑。广播曲一出场，爱爱直接泪目，显然也是被 surprise 了。彩虹让人感受到 LoveLive 的确是一个双向企划，台上的人能让台下的人哭，台下的人也能让台上的人哭。<br>&emsp;&emsp;广州场的观众席也形成了短暂的彩虹，只可惜拍完照就散了。<br><img src="/images/rainbow1.jpg" alt=""><br><img src="/images/rainbow2.jpg" alt=""></p><p>&emsp;&emsp;回想自己，头一次对 live 产生向往，也是在贴吧云 5th 的时候，看到了彩虹，从而十分强烈地想要成为彩虹一员。两年后，正好是下一场数字 live，在 live viewing 里短暂地成为了彩虹，我们的心意，一定要届过去啊。<br>&emsp;&emsp;水水经历了十分艰难的两年，我们都能感受到。运营其实不容易，谁不想等疫情稳一点憋一个大招呢？毕竟是要冲蛋巡的呀。小场也不能开太多，因为 live 的安排还要匀给正在冉冉上升的虹和星，要租场地，要考虑粉丝们的钱包。这场 6th 显然也是硬开的，东京疫情爆炸了，整个霓虹声优界一个一个开盲盒似的感染，台下观众席也不知道藏有什么狼虫虎豹。疫情之下没有完美的决策，只有胆战心惊的博弈。<br>&emsp;&emsp;只不过逢田姐不用再担心粉丝跑掉了，彩虹就是最好的证明。</p><h3 id="Sunny-Stage"><a href="#Sunny-Stage" class="headerlink" title="Sunny Stage"></a>Sunny Stage</h3><p>&emsp;&emsp;有空补。</p><p>&emsp;&emsp;亮点大概就是 AAO 和大新闻重回东蛋了。然后你水现在似乎是超级求稳策略，动不动就关麦放 CD。。。好听是好听了，车祸是少了，不是 live 了。</p><h3 id="Windy-Stage"><a href="#Windy-Stage" class="headerlink" title="Windy Stage"></a>Windy Stage</h3><p>&emsp;&emsp;等待中</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;继“Aqours 东蛋之路”后，现在差不多可以开始起草“Aqours 蛋巡之路”了。。。&lt;br&gt;</summary>
    
    
    
    <category term="玩" scheme="http://kqp.world/categories/%E7%8E%A9/"/>
    
    
  </entry>
  
  <entry>
    <title>【ICPC Camp PTZ-Shanghai 2022 Day2 G】Gross LCS 题解</title>
    <link href="http://kqp.world/%E3%80%90ICPC-Camp-PTZ-Shanghai-2022-Day2-G%E3%80%91Gross-LCS-%E9%A2%98%E8%A7%A3/"/>
    <id>http://kqp.world/%E3%80%90ICPC-Camp-PTZ-Shanghai-2022-Day2-G%E3%80%91Gross-LCS-%E9%A2%98%E8%A7%A3/</id>
    <published>2022-02-11T09:33:59.000Z</published>
    <updated>2022-02-11T10:00:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>&emsp;&emsp;给定两个数组 $A=\langle a_1,\cdots,a_n \rangle$ 和 $B=\langle b_1,\cdots,b_m \rangle$，定义 $A+x$ 表示 $\langle a_1+x,\cdots,a_n+x \rangle$，求 $\sum_{x=-10^{100}}^{10^{100}} LCS(A+x,B)$。</p><p>&emsp;&emsp;$n,m \le 4000,\ \ |a_i|,|b_i| \le 10^8$<br>&emsp;&emsp;10s，<strong>16MB</strong></p><span id="more"></span><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>&emsp;&emsp;首先，这么大的 $x$ 范围里，必定有很多是无贡献的。有贡献的 $x$ 的数量不超过 $nm$ 个，因为 $a_i+x=b_j$ 这样的等式只有 $nm$ 个。<br>&emsp;&emsp;这相当于说，对于一个固定的 $x$，在一个 $n$ 行 $m$ 列的矩阵上，把符合 $a_i+x=b_j$ 的格子 $(i,j)$ 做标记，在每一个标记点可以走到其右下方的任意标记点，问从左上走到右下的最长距离。<br>&emsp;&emsp;再往下想，每一对 $(i,j)$ 对应的 $x$ 是唯一的，也就是每种 $x$ 产生的标记总数也只有 $nm$。那么只要想办法把每种 $x$ 产生的标记弄出来，就可以 dp 了。</p><p>&emsp;&emsp;如果没有空间限制，那么就 $O(nm)$ 枚举所有的数对即可。这个 dp 是个简单的 LIS。<br>&emsp;&emsp;现在有空间限制，那么就需要用一些方法按顺序生成 $(x,i,j)$ 三元组。可以把 $b$ 数组从小到大排序（记为 $b’_1,\cdots,b’_m$），初始在堆里加入所有 $(b’_1-a_i,i,1)$，然后每从堆里取出一个元素，就把 $b’$ 向前推进一位，这样就能顺序生成所有 $(x,i,j)$ 三元组了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pr;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">4005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">2e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="type">int</span> val,i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpB</span><span class="params">(<span class="type">const</span> B &amp;a,<span class="type">const</span> B &amp;b)</span> </span>&#123;<span class="keyword">return</span> a.val&lt;b.val || a.val==b.val &amp;&amp; a.i&gt;b.i;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QST</span> &#123;</span><br><span class="line"><span class="type">int</span> x,i,j;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> QST &amp;a,<span class="type">const</span> QST &amp;b) &#123;</span><br><span class="line"><span class="keyword">return</span> a.x&gt;b.x || a.x==b.x &amp;&amp; a.i&gt;b.i || a.x==b.x &amp;&amp; a.i==b.i &amp;&amp; a.j&lt;b.j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,a[maxn],p[maxn];</span><br><span class="line">B b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c[maxn];</span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; RC;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x)</span> </span>&#123;<span class="keyword">return</span> x&amp;(-x);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> re=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; x; x-=<span class="built_in">lowbit</span>(x)) re=<span class="built_in">max</span>(re,c[x]);</span><br><span class="line"><span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">xg</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">RC.<span class="built_in">insert</span>(x);</span><br><span class="line"><span class="keyword">for</span>(; x&lt;=m; x+=<span class="built_in">lowbit</span>(x)) c[x]=<span class="built_in">max</span>(c[x],z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">c_clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x:RC)</span><br><span class="line"><span class="keyword">for</span>(; x&lt;=m; x+=<span class="built_in">lowbit</span>(x)) c[x]=<span class="number">0</span>;</span><br><span class="line">RC.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,m) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i].val), b[i].i=i;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+m,cmpB);</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,m) p[b[i].i]=i;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;QST&gt; Q;</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) Q.<span class="built_in">push</span>((QST)&#123;b[<span class="number">1</span>].val-a[i],i,b[<span class="number">1</span>].i&#125;);</span><br><span class="line"><span class="type">int</span> lastx=inf, ans=<span class="number">0</span>, curans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">QST cur=Q.<span class="built_in">top</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (lastx!=cur.x &amp;&amp; lastx!=inf) &#123;</span><br><span class="line">ans+=curans;</span><br><span class="line">curans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">c_clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp=<span class="built_in">get</span>(cur.j<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">curans=<span class="built_in">max</span>(curans,dp);</span><br><span class="line"><span class="built_in">xg</span>(cur.j,dp);</span><br><span class="line"></span><br><span class="line">lastx=cur.x;</span><br><span class="line"><span class="keyword">if</span> (p[cur.j]&lt;m) &#123;</span><br><span class="line"><span class="type">int</span> newj=p[cur.j]+<span class="number">1</span>;</span><br><span class="line">Q.<span class="built_in">push</span>((QST)&#123;b[newj].val-a[cur.i],cur.i,b[newj].i&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans+=curans;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;给定两个数组 $A=\langle a_1,\cdots,a_n \rangle$ 和 $B=\langle b_1,\cdots,b_m \rangle$，定义 $A+x$ 表示 $\langle a_1+x,\cdots,a_n+x \rangle$，求 $\sum_{x=-10^{100}}^{10^{100}} LCS(A+x,B)$。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;$n,m \le 4000,\ \ |a_i|,|b_i| \le 10^8$&lt;br&gt;&amp;emsp;&amp;emsp;10s，&lt;strong&gt;16MB&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="OI/ACM" scheme="http://kqp.world/categories/OI-ACM/"/>
    
    
    <category term="算法_DP" scheme="http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"/>
    
  </entry>
  
  <entry>
    <title>LoveLive 三团跨年 live + 72红白</title>
    <link href="http://kqp.world/%E4%B8%89%E5%9B%A2%E8%B7%A8%E5%B9%B4%20live%20+%2072%E7%BA%A2%E7%99%BD/"/>
    <id>http://kqp.world/%E4%B8%89%E5%9B%A2%E8%B7%A8%E5%B9%B4%20live%20+%2072%E7%BA%A2%E7%99%BD/</id>
    <published>2022-01-01T06:00:00.000Z</published>
    <updated>2022-05-23T12:23:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>12.31 已经成为每年最期待的日子了 qaq</p><span id="more"></span><h2 id="LoveLive-Countdown"><a href="#LoveLive-Countdown" class="headerlink" title="LoveLive Countdown"></a>LoveLive Countdown</h2><p>&emsp;&emsp;老实说我不希望 LL 自己办跨年，我希望有朝一日能在红白看见 LL series special，或者像さだまさし那样的在自己的 live 上连线红白。<br>&emsp;&emsp;今年这种线上线下并行的 live 已经成熟了，各种 live 依次宣布，加上也有过 fes 先例了，所以听见三团跨年其实也没多大惊奇。惊奇的是今年的民间组织竟然这么给力，全国上下二三十个城市几乎都有正规的民间组织观影，还做宣传视频，仿佛 live 开到家门口一样。总策划真的辛苦了。<br>&emsp;&emsp;一开始还纠结是去广州的大场还是吃土群自己的小场，后来因为带上了 sif 网友和贴吧网友（叫我传销头子），网友喜欢小场，又看到广州场标题叫 live with a tiger 感觉很可怕，就选择了一带三去吃土群小场。遗憾的是某位帅气小哥哥受伤没来。<br>&emsp;&emsp;这场 live 最担心的是 liella 特别是小百合，18场高强度巡演已经让她们嗓子很辛苦了，这个1st巡演过后，要么报废，要么成神。</p><p>&emsp;&emsp;看了红白的歌单，五木大叔不上了，松田圣子亡女不上了，岚停止活动了，有些许失望。あいみょん常驻了，几位老叔叔老阿姨还在，杰尼斯搬出了今年的雪皇桶三巨头（去年的 imitation rain 真的好听），yoasobi 两年都是现象级的歌，所以也十分期待。但是预计着只能够在 LL 开场前那一小会儿看一看，比如看到了雪人杂技团（</p><p>&emsp;&emsp;开场先放日天歌，一波烟雾弹。<br>&emsp;&emsp;星一单虹一专开场，水一转攻势来了个 dreamy color。这里最令人激动的当然是看到菜宝的大红旗袍和过膝靴。<br>&emsp;&emsp;然后来到星专场，像是简化的 1st 巡演，有给 pay 子发挥的nonfiction，有给小百合展现的symphony，拍手歌一如既往跳协调操，星光序曲将成为新的光路企划。mc可以看鲤鱼乱摸小百合。<br>&emsp;&emsp;接下来是虹专场，上来12个solo短版，似乎是各自选曲。我虽然虹听得少，但还是识得一些亮点，哀温之诗三专封神，岚珠米娅首秀，萌p绝育之光，兔兔可爱充满活力的开花宣言。最后11人版LLL，我喜欢这个摆字造型。<br>&emsp;&emsp;然后出现了146与167并肩的名场面。<br>&emsp;&emsp;时间来到水专场，开场竟然是水蓝，现在水live已经能源源不断地重新看到动画歌曲了非常感动。后面几首则是近期live比较常规的曲子，亮点反而偏少（也可能是我看得多），情怀多，比如水蓝的衣服。<br>&emsp;&emsp;三个专场之后是听广播坐牢，跟相似度调查一样感觉都是在硬凑时间，所以这一段跑去看红白了，看到红组ゲスト吃零蛋竟然还能优胜，实属宅男人气优势。中途LL有三首广播曲，这是live的焦点之一，水水轻快海边曲，虹虹炫酷rap，星星用网友的话叫“意外地成熟”。大家的衣服都改得很漂亮，尤其是某十四岁少女米娅，太成熟了。<br>&emsp;&emsp;最后的跨年倒数，最精彩的部分，网卡了直接错过，新年第一寄，成为本场最大遗憾。<br>&emsp;&emsp;倒数完后只有主题曲了，三团leader向系列致敬。没有021这样的新寓意。有点戛然而止的感觉。</p><p>&emsp;&emsp;于是又一年过去了。这年也发生了很多事，最大的感想就是，看着小姐姐们年龄渐长，真的很希望在水水退役前来一次现地。不会想到LL有如今这般发展，后辈实力越来越猛，而且都是逐梦成功的远古拉拉人。如果再展望，我希望的是一路平稳，不需要搞大事，只求长久，一代又一代的传承，把羽毛接好。如果还有祝愿，那就是星星能实现她们动画里的目标——新国立。</p><p>&emsp;&emsp;live还有很多，所以并没有太强烈的“结束了”的感觉。fes，以后还会有。</p><p>&emsp;&emsp;写这篇东西写着写着看到里p结婚了。只能说，恭喜，你怎么会有女朋友嘛.jpg伤害提升十倍。</p><h2 id="72届红白"><a href="#72届红白" class="headerlink" title="72届红白"></a>72届红白</h2><p>&emsp;&emsp;终于在过年期间有时间补了红白，甚至还是熟肉。</p><p>&emsp;&emsp;还是那句话：“不得不说跟红白一对比都要感慨你拉是怎么活到现在的”。偶像live看多了，还是要看点红白修正一下品味，至少不能认为天天翻车是正常的。</p><p>&emsp;&emsp;郷ひろみ 67 了你敢信，气息真的厚足，身体健壮，活力四射。<br>&emsp;&emsp;dish 出场前有 あいみょん 跟主持人的互动，あいみょん 竟然还能这么娇小活泼可爱，全靠大泉洋衬托。<br>&emsp;&emsp;特别影片提到了 アイゴ 褐蓝子鱼，以为是什么高档鱼类，一百度竟然是泥猛，好家伙还隔这吹生态破坏呢，台山人来了全吃了。煲汤不知多鲜！<br>&emsp;&emsp;小孩子的歌很可爱啊啊啊，小小的人总是有大大的和平梦想，但是这个作曲就一股夜に駆ける味，果然还是你 yoasobi。<br>&emsp;&emsp;纯烈清洁工上线。<br>&emsp;&emsp;来到了筒就顺带把雪皇筒都说一说。筒翻车率较高，没有去年 imitation rain 那番冷艳；king 中规中矩的偶像男团表现；雪人杂技团，秀多过唱了。<br>&emsp;&emsp;天童奶奶经典花道，不过乐队动作有点骚。<br>&emsp;&emsp;上白石萌音长得好可爱啊~<br>&emsp;&emsp;まふまふ这首是惊艳，首先布景把人带入一个很梦幻虚无的境界，然后高音特别猛，比上一个 milet 还猛，麦克风还用绷带跟手绑起来。歌词初读觉得很没头绪，怎么描述了一通生命的无意义，嘲讽了劝活的人，最后自己还拼命喊生きて呢？倒回去再读了两三遍，大约理解了，在生不如死的情感面前，歌词反对的是那些轻浮说教的劝活，转而以撕心裂肺的呐喊表达出内心对生命的尊重。<br>&emsp;&emsp;水森かおり的歌配上旅行画面，真的让人感到很舒服。<br>&emsp;&emsp;マツケンサンバ，日式桑巴，从报幕到结尾都是整活的气息。<br>&emsp;&emsp;没有指汇的交响乐团，对这位游戏音乐人的纪念。<br>&emsp;&emsp;年年晨间剧主题歌都吸引我，但是年年都不知道去哪里找晨间剧看。<br>&emsp;&emsp;这个bish是怎么被选上红白的。。。全场唯一一首听到头皮发麻的，质量似乎比水水live还差（<br>&emsp;&emsp;剑玉队打破规律魔咒，二连胜了，可喜可贺。以后选首长点的歌唱吧，队伍越来越长了。<br>&emsp;&emsp;决明子的 rap 很棒，节奏适中，歌词很鼓舞人，很温柔又很能届到明天的勇气。<br>&emsp;&emsp;perfume打造的元宇宙很有现代感，有迷失在科技空间的感觉。美中不足是只有三个女生唱歌气息很弱，bgm太强，整首歌就会感觉很虚。<br>&emsp;&emsp;宫本浩次，这唱得面目狰狞的，一副“我特么跟你安利我家乡你敢不去？”的样子，感觉这首歌温柔一点会更贴合。<br>&emsp;&emsp;紫团这次是生田绘梨花的毕业live，温暖的毕业歌总是很触动人。不仅联想到kon，还联想到逢田姐（x<br>&emsp;&emsp;細川たかし这个演歌够味，小街欢腾感，不过津轻都这么冷感伤感的吗？以及大泉洋水平高啊。<br>&emsp;&emsp;坂本阿姨今年借助樱吹雪的背景也特别美，给这首歌换上了不同的风格。<br>&emsp;&emsp;拖鞋睡衣战神藤井风，整首歌曲也是充满了随性的气息，包括旋律变化、唱法、眼神。<br>&emsp;&emsp;yoasobi 又一现象级歌曲，<del>最初是在鬼畜区认识这首歌的</del>。歌难度很高但是唱得很稳，不过感觉现场不如 CD 有气势？<br>&emsp;&emsp;铃木大叔这首摇滚又有点爵士风的小曲，配上几个老爷子扭来扭去的动作，真的太有大叔味了！去年初识铃木大叔，被特有的大叔磁性声音吸引，这次由深情思念变为活泼欢快，充满中年男人的魅力。<br>&emsp;&emsp;ゆず护花使者一般，歌曲轻快像rap，和声很棒！<br>&emsp;&emsp;gen桑同样是一首很安静舒服的歌曲。<br>&emsp;&emsp;あいみょん这首把乐队live的feel发挥到极致了，自由的衣服，标准的乐队站位和灯光，あいみょん特有的低沉和像甩出去一样的滑音。<br>&emsp;&emsp;出现了！さだまさし这个形式，在自己的live中途接入红白，一石二鸟，是我最希望出现在LL跨年live上的形式！自己跨年跟上红白两不误！歌曲的话，跟まふまふ的劝活又是两种风格，这种是很慈祥的老爷爷用毕生的阅历鼓励你笑って。<br>&emsp;&emsp;苹果姐姐拿个喇叭唱歌是要做什么？这歌词倒也确实适合播广播（<br>&emsp;&emsp;石川小百合的摇滚rap，香香辣辣你见过没！！还是要靠津轻拉回风格qaq。<br>&emsp;&emsp;福山大叔的歌是想把人间看透，并赞美生命的延续。<br>&emsp;&emsp;奥运会片段体现出的是互相尊重的价值观，展现了很多比赛之上的爱。稍有别于国内价值观，例如因心理原因退赛的体操选手，这样的事迹至少不会在国内被公开宣传，我们宣传的是拼尽全力为国争光，而他们如他们所说：“他选择的不是运动员的立场，而是人类的立场。”<br>&emsp;&emsp;高音战神misia，第一首破音和粗嗓比较严重，第二首跟拖鞋战神合作的歌就挺好，充分发挥了高音战神的魅力。<br>&emsp;&emsp;最后红组在审查员评分吃零蛋的情况下奇迹般赢了。要分析起来的话可能需要考虑如下因素：红组会不会因为 bish 而一票否决；杰尼斯和坂道系在宅女宅男中的人气对比；现象级歌曲的人气因素；审查员似乎都偏年轻因此老歌的地位会不会下降。</p><p>&emsp;&emsp;今年没有像前几年一样发现特别令我眼前一亮的歌曲，有点可惜。不过，也是各位霓虹音乐人一年又一年努力呈现的舞台。抱以欣赏和学习的态度去观看，身心愉悦。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;12.31 已经成为每年最期待的日子了 qaq&lt;/p&gt;</summary>
    
    
    
    <category term="玩" scheme="http://kqp.world/categories/%E7%8E%A9/"/>
    
    
  </entry>
  
  <entry>
    <title>2021ICPC南京站大杂记</title>
    <link href="http://kqp.world/2021ICPC%E5%8D%97%E4%BA%AC%E7%AB%99%E5%A4%A7%E6%9D%82%E8%AE%B0/"/>
    <id>http://kqp.world/2021ICPC%E5%8D%97%E4%BA%AC%E7%AB%99%E5%A4%A7%E6%9D%82%E8%AE%B0/</id>
    <published>2021-12-04T15:24:08.000Z</published>
    <updated>2022-01-26T07:34:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;发现自己真的好久没写游记了啊。。。<del>倒是各式各样的其他小作文写了不少。。。</del></p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;真没想到吧，大四了还没退役。以前中学说“五年 OI 一场空”，或者“十年 OI 一场空”，今年，都第 11 个年头了。。。<br>&emsp;&emsp;大一打完了没想过会有大二，结果被郭老拉去毛营；大二打完了没想过会有大三，结果被 zayin 哥哥盛情邀请；大三打完了线也出了杯也捧了更不会想到有大四，结果暑假校队选拔的时候被拉进小黑屋谈话，说今年金牌数量危，出线名额危，让我们来救救场，甚至还要拆了我们队变成两个抢出线的队来着。。。最后大概就是以“final 还没来”为理由又续了一年。</p><p>&emsp;&emsp;算法竞赛这个东西，说真的，我现在大概不是很有资格说我很热爱它，无论从想法上还是行动上。放到大二及以前我认为我是有资格的。转折是大三以来，出现了更多的兴趣爱好，有了想投入精力的课程，有了对科研生活、TCS research 的向往 <del>，有了想要追的女生</del>。补题时间骤减，训练补题时的厌烦情绪骤升，想不出题目被人智商碾压时的痛苦骤升。逐渐发现，比赛打久了，真的会累。</p><p>&emsp;&emsp;这一年波波折折也算是把学校定了，预计着大四就混在实验室，读 paper，想问题，喝茶（x）暑假去校选帮忙，去小黑屋谈话，给学弟队伍凑个人头好训练，回过神来才发现又被忽悠上了赛道。</p><h2 id="开学"><a href="#开学" class="headerlink" title="开学"></a>开学</h2><p>&emsp;&emsp;当然这个赛季无人之境有多拉大家也都看到了。最好的可能就是第一场 CCPC 网络赛，凭运气挤进了 hdu 土豆服务器抢了个第 9。后面的三场网络赛每场都是两个人打、另一人实习，全部都 rk70+。<br>&emsp;&emsp;打校赛拿了个第一，尚能饭。仔细分析了与最后的午餐的差距，他们做后期题比我们更有潜力，但是前中期我们更稳，所以在日常难度较大的训练里他们总要超我们一两个题，但也通常要到 3h-4h 以后才翻上去，校赛这种 90% 简单题的场我们自然也更有优势。<br>&emsp;&emsp;这样一分析，其实我们就像是当年的穷游中国，靠前中期优势取胜。</p><p>&emsp;&emsp;排赛站的时候，我们想着把小赛区留给冲出线的队，我们去大赛区旅游，结果几个来回全线上了，旅游泡汤。<br>&emsp;&emsp;队友实习结束后大概一周能有 4 场训练。没怎么补题倒是真的。</p><p>&emsp;&emsp;很快 11 月就到了。<br>&emsp;&emsp;CCPC 广州，完全是老年人随心所欲流派打法，zayin 卡 C 题，邓老板写几何题，两人直接从 1h 卡到 5h，期间不换题也不看榜，F 板刷了什么的根本不知道。我最后把数论题搞出来了没机时，赛后 10min 才卡完常。颁奖的时候十分希望直接打铁，这样我们名字就不会被念到，结果很不幸铜了。<br>&emsp;&emsp;ICPC 上海，体面了一点，至少会开题、会跟榜了。遗憾的是我开场摸的全是中后期题，一个签到都没抢到，最后全程躺，一题都没写，就看着队友输出，给他们小黄鸭。<br>&emsp;&emsp;可见这两场其实没什么游记可写。。。<br>&emsp;&emsp;CCPC 威海，出题历程大概有 3 个月，几经风雨，呕心沥血，在挖精妙的 idea、不停地叉做法改进做法、控难度等方面下了很大功夫。最后功亏一篑，H 题 generator 写错导致数据弱了，被很弱智的水法冲了过去，荣登 XCPC 比烂表。关于出题我也有很多想说的，等后面的 OI 出题任务过了以后再开篇。</p><p>&emsp;&emsp;好几场打崩的场恰好都有锅，然后就可以在一些群里看到：“无人之境都打成这样，总不能是无人之境有问题吧”“不会以为无人之境不训练了就很弱吧”……赫然发现我们的表现竟然成了判断一场比赛区分度好坏的标准之一了。感谢你们对我们过往成绩的认可，不过我们也十分惭愧，我们打崩了基本上都是自身原因，我们尚不足以用于评判区分度的好坏。</p><p>&emsp;&emsp;然后就到南京了。</p><h2 id="南京"><a href="#南京" class="headerlink" title="南京"></a>南京</h2><p>&emsp;&emsp;星期三得知正赛竟然是周六，又赶上周六大一的同学有军理考试，于是含有大一的队伍突然间全寄了，紧急换人。对着校赛榜抓壮丁，抓了个打得很好的研究生队（两个我校退役选手，一个来自 csu 进过小米邀请赛的大神），再抓了校队里还没打满 2 场里的唯一不含大一的一支队伍。</p><p>&emsp;&emsp;周五热身前看到 cjb 哥哥发了个死亡笔记，不幸榜上有名。热身完了以后回去看到某 C 开头的学会以“代码含有暴戾语言”为由禁赛了 5 个人，血压拉满。</p><p>&emsp;&emsp;周六早上，第一趟出门，到机房发现忘带电脑；回宿舍拿电脑第二趟出门，到机房发现忘带板子，回宿舍拿板子第三趟出门，到机房离开始只有 10 min 了。阿尔茨海默症晚期选手。还没开场先跑个 2km 感觉很淦。</p><p>&emsp;&emsp;开场，邓老板抢了个 G 一血。我玩 M 题猜了个错结论，也没判 $n=1$，WA 了两发，罚时大概从一开始就没有了。<br>&emsp;&emsp;然后读过几个题之后我就开始想 J，队友陆续过掉 CD，zayin 开始快乐线段树历史和。我的 J 转化了模型却一直没进展。邓老板被迫开计数题。<br>&emsp;&emsp;2.5h 后 E 过了。zayin 一边救 J 一边听计数题，机位空了一万年。<br>&emsp;&emsp;最后我突然发现每一步操作结果一定是一段连续的区间，zayin 听了马上补充说不是连续区间而是恰好只有两个相邻的数，于是 dp 做法就出来了。最终 4h18min 过了 J。<br>&emsp;&emsp;我写 J 的时候他们 IG 都会了，但是一开始以为 I 要 cdq 所以决定先写 G。最后两题都没写完。</p><p>&emsp;&emsp;苟在金区。想比上海更体面一点，想能够给这篇游记起个标题叫“体面记”，但结果不算很体面。就这样吧。<br>&emsp;&emsp;这场主要问题就是我的 J 卡了半个场，节奏全部拖慢了。这个 J 的套路应该是老套路了，所幸最后能想起来。I 比较歪。</p><p>&emsp;&emsp;发现我校稳定每场一个金，这样下去金牌数和出线还真的很危。求求下一任中大之光赶紧出线呀。。。</p><h2 id="结束了"><a href="#结束了" class="headerlink" title="结束了"></a>结束了</h2><p>&emsp;&emsp;现在是处于一种退役了但又没完全退役的状态。<br>&emsp;&emsp;已有的比赛确实打完了，两场 ICPC，一场 CCPC。神不知鬼不觉被拉上的大四赛道，也算是走完了。大四打完，这下是真不会有下一年了。<br>&emsp;&emsp;但是很大概率将来还要被拉去打 EC，下周还有个毛营想要试着去旅游去抢钱，一年后还有一个状态未知的 WF2021。</p><p>&emsp;&emsp;竞赛就是这样子，前面无论多累多不想做，恨不得没有比赛天天过科研生活，可是真的比赛完了，真的到退役的时候了，就总会觉得还远远不够，还应该再做几个题，再打上几年。<br>&emsp;&emsp;没有完全把实力发挥出来，当然会意犹未尽。不过，我相信不只是因为赛场的遗憾，这么多年的投入，不可能不在说再见的时候牵动心弦。<br>&emsp;&emsp;所幸这次又又又只是暂别。atcoder，codeforces，太多没补完的东西，暂时要放一放，去读 paper 做毕设了。总会在 EC、WF 之前，又捡起来再打。不过可以肯定的是，一大段时间内，不会再有一周四训这样热火朝天的行为了。</p><p>&emsp;&emsp;EC 确定日期之前大概也不会康复了。现在可以开始你想要的生活了，它还是你期待的样子吗？<br>&emsp;&emsp;希望是的。</p><p>&emsp;&emsp;更多的话，等下一篇年终总结来说吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;发现自己真的好久没写游记了啊。。。&lt;del&gt;倒是各式各样的其他小作文写了不少。。。&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="总结与游记" scheme="http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"/>
    
    <category term="OI/ACM" scheme="http://kqp.world/categories/OI-ACM/"/>
    
    
  </entry>
  
  <entry>
    <title>【AtCoder Grand 030E】Less than 3 题解</title>
    <link href="http://kqp.world/%E3%80%90AtCoder%20Grand%20030E%E3%80%91Less%20than%203%20%E9%A2%98%E8%A7%A3/"/>
    <id>http://kqp.world/%E3%80%90AtCoder%20Grand%20030E%E3%80%91Less%20than%203%20%E9%A2%98%E8%A7%A3/</id>
    <published>2021-11-25T11:45:14.000Z</published>
    <updated>2022-01-26T09:46:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>&emsp;&emsp;给定两个长度为 $n$ 的 01 串 $s,t$，每个串都不会有连续三个相同的字符。现在每次操作可以将 $s$ 的一位反转，但反转之后也要保证没有连续三个相同的字符，求最少的步数使得 $s$ 变成 $t$。</p><p>&emsp;&emsp;$n \le 5000$<br>&emsp;&emsp;2s</p><span id="more"></span><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>&emsp;&emsp;题解这个模型转化非常 nice。</p><p>&emsp;&emsp;给 $0$ 和 $1$ 之间画一条红线，给 $1$ 和 $0$ 之间画一条蓝线，这样这个 01 串就变成了：</p><ul><li>有很多红蓝相间的线；（开头和结尾可以补充无限条红蓝相间的线）</li><li>相邻的线间隔为 1 或 2；</li><li>每次操作可以将一条线往左或者往右移 1 位，不能与别的线重合，线的间隔仍然要为 1 或 2。</li></ul><p>&emsp;&emsp;可以发现这样就变成了线的匹配问题。$O(n)$ 枚举 $s$ 串开头的线匹配 $t$ 的哪一条线，然后再 $O(n)$ 算出匹配代价即可，总共 $O(n^2)$。整个过程用些数据结构或者 trick 可以优化成 $O(n)$，不过意义不大。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pr;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">5005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,ps0,ps1,pt0,pt1,ps2,pt2;</span><br><span class="line">pr ps[<span class="number">4</span>*maxn],pt[<span class="number">4</span>*maxn];</span><br><span class="line"><span class="type">char</span> s[maxn],t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pre</span><span class="params">(<span class="type">char</span> *t,pr *p,<span class="type">int</span> &amp;p0,<span class="type">int</span> &amp;p1,<span class="type">int</span> &amp;p2)</span> &#123;</span><br><span class="line">fo(i,<span class="number">0</span>,n+<span class="number">5</span>) p[++p0]=<span class="built_in">make_pair</span>(<span class="number">0</span>,i&amp;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (p[p0].second!=(t[<span class="number">0</span>]&gt;t[<span class="number">1</span>])) p[++p0]=<span class="built_in">make_pair</span>(<span class="number">0</span>,(t[<span class="number">0</span>]&gt;t[<span class="number">1</span>]));</span><br><span class="line">p1=p0+<span class="number">1</span>;</span><br><span class="line">fo(i,<span class="number">1</span>,n<span class="number">-1</span>) <span class="keyword">if</span> (t[i]!=t[i+<span class="number">1</span>]) p[++p0]=<span class="built_in">make_pair</span>(i,(t[i]&gt;t[i+<span class="number">1</span>]));</span><br><span class="line">p2=p0;</span><br><span class="line"><span class="type">int</span> cur=(t[n]==<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">fo(i,<span class="number">0</span>,n+<span class="number">5</span>) p[++p0]=<span class="built_in">make_pair</span>(n,cur), cur^=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (n&lt;=<span class="number">2</span>) &#123;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">fo(i,<span class="number">1</span>,n) ans+=(s[i]!=t[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">s[<span class="number">0</span>]=(s[<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span> ?<span class="string">&#x27;0&#x27;</span> :<span class="string">&#x27;1&#x27;</span> );</span><br><span class="line">t[<span class="number">0</span>]=(t[<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span> ?<span class="string">&#x27;0&#x27;</span> :<span class="string">&#x27;1&#x27;</span> );</span><br><span class="line"></span><br><span class="line">pre(s,ps,ps0,ps1,ps2);</span><br><span class="line">pre(t,pt,pt0,pt1,pt2);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans=n*n*<span class="number">10</span>;</span><br><span class="line">fo(i,<span class="number">1</span>,pt2) <span class="keyword">if</span> (ps[ps1].second==pt[i].second) &#123;</span><br><span class="line"><span class="type">int</span> bs=ps1-max(<span class="number">0</span>,i-pt1), be=ps2+max(<span class="number">0</span>,pt2-(i+ps2-ps1)), bt=i-(ps1-bs), len=be-bs+<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> ans1=<span class="number">0</span>;</span><br><span class="line">fo(j,<span class="number">1</span>,len) ans1+=<span class="built_in">abs</span>(ps[bs+j<span class="number">-1</span>].first-pt[bt+j<span class="number">-1</span>].first);</span><br><span class="line">ans=min(ans,ans1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;给定两个长度为 $n$ 的 01 串 $s,t$，每个串都不会有连续三个相同的字符。现在每次操作可以将 $s$ 的一位反转，但反转之后也要保证没有连续三个相同的字符，求最少的步数使得 $s$ 变成 $t$。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;$n \le 5000$&lt;br&gt;&amp;emsp;&amp;emsp;2s&lt;/p&gt;</summary>
    
    
    
    <category term="OI/ACM" scheme="http://kqp.world/categories/OI-ACM/"/>
    
    
    <category term="算法_神奇的脑洞" scheme="http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>【2021 ICPC Gran Premio de Mexico 2da Fecha F】Flipped Factorization 题解</title>
    <link href="http://kqp.world/%E3%80%902021%20ICPC%20Gran%20Premio%20de%20Mexico%202da%20Fecha%20F%E3%80%91Flipped%20Factorization%20%E9%A2%98%E8%A7%A3/"/>
    <id>http://kqp.world/%E3%80%902021%20ICPC%20Gran%20Premio%20de%20Mexico%202da%20Fecha%20F%E3%80%91Flipped%20Factorization%20%E9%A2%98%E8%A7%A3/</id>
    <published>2021-11-09T04:11:15.000Z</published>
    <updated>2022-06-07T04:14:25.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>&emsp;&emsp;设 $x$ 的质因数分解为 $p_1^{c_1}p_2^{c_2}\cdots p_m^{c_m}$，记 $f(x) = c_1^{p_1}c_2^{p_2}\cdots c_m^{p_m}$，给定 $n$，求 $\sum_{i=1}^n f(n) \bmod 10^9+7$。</p><p>&emsp;&emsp;$n \le 10^{14}$<br>&emsp;&emsp;10s</p><span id="more"></span><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>&emsp;&emsp;$n$ 的这个范围没法筛，但却很根号。<br>&emsp;&emsp;因此用 powerful number 求积性函数和。</p><p>&emsp;&emsp;观察到对质数来说 $f(p)=1$，能对上这个形式的，马上想到全 1 函数 $1(n)=1$。然后观察 $h = \frac{f}{1} = f \ast \mu$，得到</p><script type="math/tex; mode=display">h(p^c)=\begin{cases}c^p-(c-1)^p, &c>1 \\ 0, &c=1\end{cases}</script><p>&emsp;&emsp;然后推式子</p><script type="math/tex; mode=display">\begin{aligned}& f = h \ast 1 \\ \Rightarrow & \sum_{i=1}^n f(i) = \sum_{i=1}^n \sum_{j=1}^{\lfloor \frac ni \rfloor} h(i)1(j) = \sum_{i=1}^n h(i) \lfloor \frac ni \rfloor \\ \end{aligned}</script><p>&emsp;&emsp;又由于 $h$ 只在 powerful number 处有值，因此用 dfs 把 $O(\sqrt n)$ 个 powerful number 都找出来算答案就行了。dfs 的过程中要维护 $h$ 的值，$c^p$ 可以用快速幂算。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxp0=<span class="number">1e7</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> LL mo=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">LL n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[maxp0],p0;</span><br><span class="line"><span class="type">bool</span> bz[maxp0];</span><br><span class="line"><span class="type">void</span> <span class="title function_">Prime</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">fo(i,<span class="number">2</span>,n) &#123;</span><br><span class="line"><span class="keyword">if</span> (!bz[i]) p[++p0]=i;</span><br><span class="line">fo(j,<span class="number">1</span>,p0) &#123;</span><br><span class="line"><span class="keyword">if</span> (i*p[j]&gt;n) <span class="keyword">break</span>;</span><br><span class="line">bz[i*p[j]]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i%p[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL <span class="title function_">Pow</span><span class="params">(LL x,LL y)</span> &#123;</span><br><span class="line">LL re=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; y; y&gt;&gt;=<span class="number">1</span>, x=x*x%mo) <span class="keyword">if</span> (y&amp;<span class="number">1</span>) re=re*x%mo;</span><br><span class="line"><span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL ans;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> k,LL h,LL i)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (k&gt;p0) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (n/i&lt;(LL)p[k]*p[k]) <span class="keyword">return</span>;</span><br><span class="line">dfs(k+<span class="number">1</span>,h,i);</span><br><span class="line">LL last=<span class="number">1</span>;</span><br><span class="line">i*=p[k];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">2</span>; ; c++) &#123;</span><br><span class="line">LL cur=Pow(c,p[k]);</span><br><span class="line">LL newh=h*(cur-last+mo)%mo;</span><br><span class="line">i*=p[k];</span><br><span class="line">(ans+=(n/i)%mo*newh)%=mo;</span><br><span class="line">dfs(k+<span class="number">1</span>,newh,i);</span><br><span class="line"><span class="keyword">if</span> (n/i&lt;p[k]) <span class="keyword">break</span>;</span><br><span class="line">last=cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">Prime(<span class="number">1e7</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">ans=n%mo;</span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;设 $x$ 的质因数分解为 $p_1^{c_1}p_2^{c_2}\cdots p_m^{c_m}$，记 $f(x) = c_1^{p_1}c_2^{p_2}\cdots c_m^{p_m}$，给定 $n$，求 $\sum_{i=1}^n f(n) \bmod 10^9+7$。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;$n \le 10^{14}$&lt;br&gt;&amp;emsp;&amp;emsp;10s&lt;/p&gt;</summary>
    
    
    
    <category term="OI/ACM" scheme="http://kqp.world/categories/OI-ACM/"/>
    
    
    <category term="算法_数论" scheme="http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>TCS papers 阅读记录</title>
    <link href="http://kqp.world/TCS%20papers%20%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"/>
    <id>http://kqp.world/TCS%20papers%20%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/</id>
    <published>2021-10-27T14:04:08.000Z</published>
    <updated>2022-05-23T12:58:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>大概就随便记一记读过的有亮点的东西，觉得很牛逼的东西就分享一下，随缘更新。</p><p>当然也不是教程或者阅读笔记。</p><p>TCS 是指 Theoretical Computer Science。</p><span id="more"></span><h2 id="Fine-Grained-Complexity-and-Cryptography"><a href="#Fine-Grained-Complexity-and-Cryptography" class="headerlink" title="Fine-Grained Complexity and Cryptography"></a>Fine-Grained Complexity and Cryptography</h2><p><a href="https://people.csail.mit.edu/virgi/6.s078/">这是 MIT 的 Fine-Grained Complexity 课</a>，可以用它的 lecture note 简单学一学。以及它的<a href="https://people.csail.mit.edu/virgi/6.s078/paperlist.html">大作业的 paper list</a> 作为起点我认为是不错的。</p><h4 id="Marshall-Ball-Alon-Rosen-Manuel-Sabin-and-Prashant-Nalini-Vasudevan-Average-Case-Fine-Grained-Hardness-In-STOC-2017"><a href="#Marshall-Ball-Alon-Rosen-Manuel-Sabin-and-Prashant-Nalini-Vasudevan-Average-Case-Fine-Grained-Hardness-In-STOC-2017" class="headerlink" title="Marshall Ball, Alon Rosen, Manuel Sabin, and Prashant Nalini Vasudevan. Average-Case Fine-Grained Hardness. In STOC 2017."></a>Marshall Ball, Alon Rosen, Manuel Sabin, and Prashant Nalini Vasudevan. Average-Case Fine-Grained Hardness. In STOC 2017.</h4><p>&emsp;&emsp;以下称为 [avg-fg]<br>&emsp;&emsp;声称是第一篇将 fine-grained complexity 与 cryptography 结合起来的工作。<br>&emsp;&emsp;先推导一个重要的 Lemma 1，就是将传统的 random self-reducibility 改造了一下，原本的归约只要多项式复杂度就好了，现在要求复杂度更精细，因此要用比较牛逼的点值和插值。<br>&emsp;&emsp;然后基于这个做出了几个基本问题的 average-case hardness。<br>&emsp;&emsp;然后针对 OV 问题，给出了只用 $\tilde O(n)$ 的验证方法（灵活运用多点求值和快速插值），这样就给出了一个 MA 协议和 Proof of Work。<del>虽然是老竞赛选手了，但还是被秀得头皮发麻</del><br>&emsp;&emsp;然后它说用 OV 构造的 instance-solution pair 作为 OWF 会证伪 NSETH，因此 OV 的这个 hardness 不太能用来做 OWF。</p><h4 id="Marco-L-Carmosino-Jiawei-Gao-Russell-Impagliazzo-Ivan-Mihajlin-Ramamohan-Paturi-and-Stefan-Schneider-Nondeterministic-extensions-of-the-strong-exponential-time-hypothesis-and-consequences-for-non-reducibility-In-TCS-2016"><a href="#Marco-L-Carmosino-Jiawei-Gao-Russell-Impagliazzo-Ivan-Mihajlin-Ramamohan-Paturi-and-Stefan-Schneider-Nondeterministic-extensions-of-the-strong-exponential-time-hypothesis-and-consequences-for-non-reducibility-In-TCS-2016" class="headerlink" title="Marco L. Carmosino, Jiawei Gao, Russell Impagliazzo, Ivan Mihajlin, Ramamohan Paturi, and Stefan Schneider. Nondeterministic extensions of the strong exponential time hypothesis and consequences for non-reducibility. In TCS 2016."></a>Marco L. Carmosino, Jiawei Gao, Russell Impagliazzo, Ivan Mihajlin, Ramamohan Paturi, and Stefan Schneider. Nondeterministic extensions of the strong exponential time hypothesis and consequences for non-reducibility. In TCS 2016.</h4><p>&emsp;&emsp;以下称为 [NSETH]<br>&emsp;&emsp;[avg-fg] 在构建 one-way function 的时候说，如果他设计的 one-way function 存在，就会证伪 NSETH 猜想。这篇就是讲 NSETH 猜想。<br>&emsp;&emsp;简单来说，SETH 是说 k-SAT 需要指数时间，而 NSETH 是说 k-UNSAT 在非确定图灵机上也要指数时间。<br>&emsp;&emsp;然后他说证伪 NSETH 会得到一些 circuit lower bound，所以很难证伪。由于不懂电路就先跳过了。<br>&emsp;&emsp;NSETH 推导出来最有趣的结果应当是，SETH-hard 不能说明 3-SUM-hard 和 APSP-hard。</p><h4 id="Rio-LaVigne-Andrea-Lincoln-and-Virginia-VassilevskaWilliams-Public-Key-Cryptography-in-the-Fine-Grained-Setting-In-CRYPTO-2019"><a href="#Rio-LaVigne-Andrea-Lincoln-and-Virginia-VassilevskaWilliams-Public-Key-Cryptography-in-the-Fine-Grained-Setting-In-CRYPTO-2019" class="headerlink" title="Rio LaVigne, Andrea Lincoln, and Virginia VassilevskaWilliams. Public-Key Cryptography in the Fine-Grained Setting. In CRYPTO 2019."></a>Rio LaVigne, Andrea Lincoln, and Virginia VassilevskaWilliams. Public-Key Cryptography in the Fine-Grained Setting. In CRYPTO 2019.</h4><p>&emsp;&emsp;以下称为 [pubkey]<br>&emsp;&emsp;<del>老板：“如果 public key 做出来了，那数字签名之类的全套都有了，你代码实现一下，假装数字签名那些是很难很创新的东西，不就把毕设水出来了吗？反正你校的老师都水平低看不懂。”</del><br>&emsp;&emsp;这篇想要基于 [avg-fg] 继续深入，搞 public key 和 key exchange，顺便深入研究 one-way function。<br>&emsp;&emsp;开局 27 个 definition 让人为之震撼，这套东西居然要基于这么强的限制，花拳绣腿。<br>&emsp;&emsp;而后面基于 Merkle Puzzle 设计具体协议的那部分，特别是证明，还没读懂。要么是我水平低领悟不了她们的奥妙，要么是她们喝了假酒在那乱写。已知有部分证明肯定是错的。<br>&emsp;&emsp;然后老板的想法大概也是要 fail 的，像“均匀采样一个 3-SUM 问题无解的例子”这样的东西就很不可实现。</p><h4 id="Marshall-Ball-Alon-Rosen-Manuel-Sabin-and-Prashant-Nalini-Vasudevan-Proofs-of-Work-From-Worst-Case-Assumptions-In-CRYPTO-2018"><a href="#Marshall-Ball-Alon-Rosen-Manuel-Sabin-and-Prashant-Nalini-Vasudevan-Proofs-of-Work-From-Worst-Case-Assumptions-In-CRYPTO-2018" class="headerlink" title="Marshall Ball, Alon Rosen, Manuel Sabin, and Prashant Nalini Vasudevan. Proofs of Work From Worst-Case Assumptions. In CRYPTO 2018."></a>Marshall Ball, Alon Rosen, Manuel Sabin, and Prashant Nalini Vasudevan. Proofs of Work From Worst-Case Assumptions. In CRYPTO 2018.</h4><p>&emsp;&emsp;以下称为 [PoW]<br>&emsp;&emsp;原班人马对 [avg-fg] 的延续。<br>&emsp;&emsp;前半部分是把 OV 问题换成了 kOV 问题重新推了一遍 Proof of Work，但是复杂度算得很假，包括但不限于多点求值和快速插值的复杂度竟然离谱地达到了 $O(n \log^3 n \log p)$、一些步骤细节写得不清不楚。<br>&emsp;&emsp;后面比较有趣的是搞了一个 Zero Knowledge Proof of Work，美中不足的是它根据 ElGamal 来改的，因此用了 Decisional Diffie-Hellman 假设，违背了 Fine-Grained Cryptography 的初衷（使用 Fine-Grained Complexity 中的 hardness）。</p><h4 id="Improved-Merlin-Arthur-Protocols-for-Central-Problems-in-Fine-Grained-Complexit"><a href="#Improved-Merlin-Arthur-Protocols-for-Central-Problems-in-Fine-Grained-Complexit" class="headerlink" title="Improved Merlin-Arthur Protocols for Central Problems in Fine-Grained Complexit"></a>Improved Merlin-Arthur Protocols for Central Problems in Fine-Grained Complexit</h4><h4 id="Matching-Triangles-and-Basing-Hardness-on-an-Extremely-Popular-Conjecture"><a href="#Matching-Triangles-and-Basing-Hardness-on-an-Extremely-Popular-Conjecture" class="headerlink" title="Matching Triangles and Basing Hardness on an Extremely Popular Conjecture"></a>Matching Triangles and Basing Hardness on an Extremely Popular Conjecture</h4><h2 id="Interactive-Protocals"><a href="#Interactive-Protocals" class="headerlink" title="Interactive Protocals"></a>Interactive Protocals</h2><h4 id="DOES-eo-NP-HAVE-SHORT-INTERACTIVE-PROOFS"><a href="#DOES-eo-NP-HAVE-SHORT-INTERACTIVE-PROOFS" class="headerlink" title="DOES eo-NP HAVE SHORT INTERACTIVE PROOFS?"></a>DOES eo-NP HAVE SHORT INTERACTIVE PROOFS?</h4><h2 id="Zero-Knowledge-Proof"><a href="#Zero-Knowledge-Proof" class="headerlink" title="Zero Knowledge Proof"></a>Zero Knowledge Proof</h2><h4 id="Rafail-Ostrovsky-One-Way-Functions-Hard-on-Average-Problems-and-Statistical-Zero-Knowledge-Proofs-In-CCC-1991"><a href="#Rafail-Ostrovsky-One-Way-Functions-Hard-on-Average-Problems-and-Statistical-Zero-Knowledge-Proofs-In-CCC-1991" class="headerlink" title="Rafail Ostrovsky. One-Way Functions, Hard on Average Problems, and Statistical Zero-Knowledge Proofs. In CCC 1991."></a>Rafail Ostrovsky. One-Way Functions, Hard on Average Problems, and Statistical Zero-Knowledge Proofs. In CCC 1991.</h4><p>&emsp;&emsp;以下称为 [SZK-OWF]<br>&emsp;&emsp;如果一个问题 $L$ 是属于 $\mathsf{SZK}$ 的，并且是 hard on average 的，那么就可以通过这个 SZK 构造出 one-way function。这个 one-way function 的输入是 SZK 里的 simulator 所需的 random tape，输出是 simulator 产生的 view of verifier。<br>&emsp;&emsp;证明大致是，假设这个函数不是 one-way 的，即输入 view 可以快速求出 random tape。那么用 simulator 充当 prover，与 verifier 交互（每得到一条 verifier 的消息就重新算 random tape，再用 simulator 计算出 prover 要发的消息），这样就得到了 $L$ 的快速判定算法，从而 $L$ 不是 hard on average。<br>&emsp;&emsp;为什么限定是 SZK 呢？因为 SZK 证明 correctness 的时候会方便很多。后续论文 [ZKP-OWF] 把这个思想拓展到一般 ZKP 上了。<br>&emsp;&emsp;为什么是 hard on average 呢？我认为这个条件是不准确的，它用反证法推翻的结论是“$L$ 没有高效的概率算法”，所以应该跟 [ZKP-OWF] 一样，是“不属于 $\mathsf{BPP}$”。</p><h4 id="Rafail-Ostrovsky-and-Avi-Wigdersony-One-Way-Functions-are-Essential-for-Non-Trivial-Zero-Knowledge-In-Israel-Symposium-on-Theory-and-Computing-Systems-1993"><a href="#Rafail-Ostrovsky-and-Avi-Wigdersony-One-Way-Functions-are-Essential-for-Non-Trivial-Zero-Knowledge-In-Israel-Symposium-on-Theory-and-Computing-Systems-1993" class="headerlink" title="Rafail Ostrovsky, and Avi Wigdersony. One-Way Functions are Essential for Non-Trivial Zero-Knowledge. In Israel Symposium on Theory and Computing Systems 1993."></a>Rafail Ostrovsky, and Avi Wigdersony. One-Way Functions are Essential for Non-Trivial Zero-Knowledge. In Israel Symposium on Theory and Computing Systems 1993.</h4><p>&emsp;&emsp;以下称为 [ZKP-OWF]<br>&emsp;&emsp;这篇要先读前序论文 [SZK-OWF]。思路都是一样的，只要“simulator 输入 random tape 输出 view of verifier”这个函数可逆，就可以用 simulator 充当 prover 与 verifier 交互，得到一个快速的判定算法，从而使得 $\mathsf{ZKP \subset BPP}$。</p><h4 id="How-to-Construct-Constant-Round-Zero-Knowledge-Proof-Systems-for-NP"><a href="#How-to-Construct-Constant-Round-Zero-Knowledge-Proof-Systems-for-NP" class="headerlink" title="How to Construct Constant-Round Zero-Knowledge Proof Systems for NP"></a>How to Construct Constant-Round Zero-Knowledge Proof Systems for NP</h4><h4 id="Random-Self-Reducibility-and-Zero-Knowledge-Interactive-Proofs-of-Possession-of-Information"><a href="#Random-Self-Reducibility-and-Zero-Knowledge-Interactive-Proofs-of-Possession-of-Information" class="headerlink" title="Random Self-Reducibility and Zero Knowledge Interactive Proofs of Possession of Information"></a>Random Self-Reducibility and Zero Knowledge Interactive Proofs of Possession of Information</h4>]]></content>
    
    
    <summary type="html">&lt;p&gt;大概就随便记一记读过的有亮点的东西，觉得很牛逼的东西就分享一下，随缘更新。&lt;/p&gt;
&lt;p&gt;当然也不是教程或者阅读笔记。&lt;/p&gt;
&lt;p&gt;TCS 是指 Theoretical Computer Science。&lt;/p&gt;</summary>
    
    
    
    <category term="TCS" scheme="http://kqp.world/categories/TCS/"/>
    
    
    <category term="complexity" scheme="http://kqp.world/tags/complexity/"/>
    
    <category term="ZKP" scheme="http://kqp.world/tags/ZKP/"/>
    
  </entry>
  
  <entry>
    <title>【2018 NWERC D】Date Pickup 题解</title>
    <link href="http://kqp.world/%E3%80%902018%20NWERC%20D%E3%80%91Date%20Pickup%20%E9%A2%98%E8%A7%A3/"/>
    <id>http://kqp.world/%E3%80%902018%20NWERC%20D%E3%80%91Date%20Pickup%20%E9%A2%98%E8%A7%A3/</id>
    <published>2021-10-09T05:59:34.000Z</published>
    <updated>2022-01-26T09:46:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>&emsp;&emsp;有一幅 $n$ 个点 $m$ 条边的有向图，边有边权（代表通过所需时间），你在 $1$ 号点，女朋友在 $n$ 号点。<br>&emsp;&emsp;你可以选择在 $1$ 号点延迟任意时间之后，选定一条路线开始游走，一旦开始游走就不能停下来。你的女朋友会在时间区间 $[a,b]$ 中的任意一个实数时间点 call 你，你一旦被 call 就要马上过去 $n$ 号点，女朋友的等待时间就是她 call 了之后到你到达所用的时间。<br>&emsp;&emsp;求女朋友的最坏等待时间最小。</p><p>&emsp;&emsp;$n,m \le 10^5,\ \ 0 \le a \le b \le 10^{12}$，边权 $\le 10^6$<br>&emsp;&emsp;保证每个点至少有一条出边，即总是可以无限游走的。</p><p>&emsp;&emsp;6s</p><span id="more"></span><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>&emsp;&emsp;官方题解有很多细节不是很懂，不过对我考场上的想法有很大的启发，于是完成了我考场上的想法。</p><p>&emsp;&emsp;二分答案 $mid$。<br>&emsp;&emsp;首先，如果到了 $[a,b]$ 这个时间段，我们必须随叫随到，因此我们可以知道这时候哪些点哪些边是能走的：对于点 $u$ 需满足 $dis(u,n) \le mid$，对于边 $(u,v,w)$ 需满足 $w+dis(v,n) \le mid$。这个时间段内我们只能在这个子图上走，除了开始的一点点（$a$ 时刻我们可能还在去这个子图的路上）。<br>&emsp;&emsp;如果我们能从 $1$ 号点去到这个子图，那么接下来要做的事情就是：如果这个子图有环，我们就一直沿着环走，就合法了；如果这个子图没有环，它就是个 DAG，就可以在上面 dp 出一个最久逗留时间，让它 $\ge b$ 就好了。<br>&emsp;&emsp;所以现在就是要判断从 $1$ 号点能不能到达这个子图，即会不会在 $a$ 时刻还没走到子图但是被 call 了然后去不了 $n$ 号点。<br>&emsp;&emsp;假设在 $[a,b]$ 时间段我们最先到达的节点是 $x$，它的充要条件就是：1、$x$ 是子图上的点；2、$dis(1,x) \le a+mid-dis(x,n)$（即 $a$ 时刻 call 合法）。这样就相当于筛选出了子图的合法起点，可以做一个 bfs 筛去子图里起点不能到的点，然后做上面的拓扑找环和 dp。</p><p>&emsp;&emsp;关于 DAG 上的 dp，初值是对于子图起点 $x$，$dp_x=a+mid-dis(x,n)$（即越晚出发越好，但要满足 $a$ 时刻 call 合法），然后按拓扑序求最长路径。</p><p>&emsp;&emsp;注意一些特殊情况，比如 $1$ 号点本身是子图里的点的时候，只需判断 $dis(1,n) \le mid$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pr;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">LL a,b;</span><br><span class="line"><span class="built_in">vector</span>&lt;pr&gt; e[maxn],ef[maxn];</span><br><span class="line"></span><br><span class="line">LL dis1[maxn],disn[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="type">void</span> <span class="title function_">dijkstra</span><span class="params">(<span class="type">int</span> st,<span class="built_in">vector</span>&lt;pr&gt; *e,LL *dis)</span> &#123;</span><br><span class="line"><span class="built_in">memset</span>(dis,<span class="number">127</span>,<span class="keyword">sizeof</span>(LL)*(n+<span class="number">2</span>));</span><br><span class="line">dis[st]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;LL,<span class="type">int</span>&gt;&gt; Q;</span><br><span class="line">Q.push(<span class="built_in">make_pair</span>(<span class="number">0</span>,st));</span><br><span class="line">fo(i,<span class="number">1</span>,n) &#123;</span><br><span class="line"><span class="keyword">while</span> (!Q.empty() &amp;&amp; vis[Q.top().second]) Q.pop();</span><br><span class="line"><span class="keyword">if</span> (Q.empty()) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">auto</span> tp=Q.top(); Q.pop();</span><br><span class="line">vis[tp.second]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(pr go:e[tp.second]) <span class="keyword">if</span> (!vis[go.first] &amp;&amp; dis[go.first]&gt;-tp.first+go.second) &#123;</span><br><span class="line">dis[go.first]=-tp.first+go.second;</span><br><span class="line">Q.push(<span class="built_in">make_pair</span>(-dis[go.first],go.first));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> valid[maxn],arrived[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;pr&gt; et[maxn];</span><br><span class="line">LL dp[maxn];</span><br><span class="line"><span class="type">int</span> dg[maxn];</span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">(LL mid)</span> &#123;</span><br><span class="line"><span class="built_in">memset</span>(dg,<span class="number">0</span>,<span class="keyword">sizeof</span>(dg));</span><br><span class="line"><span class="built_in">memset</span>(arrived,<span class="number">0</span>,<span class="keyword">sizeof</span>(arrived));</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">fo(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">et[i].clear();</span><br><span class="line"><span class="keyword">if</span> (valid[i] &amp;&amp; dis1[i]&lt;=a+mid-disn[i]) &#123;</span><br><span class="line">Q.push(i);</span><br><span class="line">arrived[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line"><span class="type">int</span> cur=Q.front(); Q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> go:e[cur]) <span class="keyword">if</span> (go.second+disn[go.first]&lt;=mid) &#123;</span><br><span class="line"><span class="keyword">if</span> (!arrived[go.first]) Q.push(go.first), arrived[go.first]=<span class="number">1</span>;</span><br><span class="line">et[cur].push_back(go);</span><br><span class="line">dg[go.first]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">topo</span><span class="params">(LL mid)</span> &#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0xbf</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">fo(i,<span class="number">1</span>,n) <span class="keyword">if</span> (arrived[i] &amp;&amp; !dg[i]) Q.push(i);</span><br><span class="line"><span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line"><span class="type">int</span> cur=Q.front(); Q.pop();</span><br><span class="line"><span class="keyword">if</span> (dis1[cur]&lt;=a+mid-disn[cur]) dp[cur]=max(dp[cur],a+mid-disn[cur]);</span><br><span class="line"><span class="keyword">if</span> (dp[cur]&gt;=b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> go:et[cur]) &#123;</span><br><span class="line">dp[go.first]=max(dp[go.first],dp[cur]+go.second);</span><br><span class="line"><span class="keyword">if</span> (--dg[go.first]==<span class="number">0</span>) Q.push(go.first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fo(i,<span class="number">1</span>,n) <span class="keyword">if</span> (arrived[i] &amp;&amp; dg[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(LL mid)</span> &#123;</span><br><span class="line">fo(i,<span class="number">1</span>,n) valid[i]=(disn[i]&lt;=mid);</span><br><span class="line"><span class="keyword">if</span> (valid[<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">bfs(mid);</span><br><span class="line"><span class="keyword">return</span> topo(mid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">fo(i,<span class="number">1</span>,m) &#123;</span><br><span class="line"><span class="type">int</span> x,y,z;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">e[x].push_back(<span class="built_in">make_pair</span>(y,z));</span><br><span class="line">ef[y].push_back(<span class="built_in">make_pair</span>(x,z));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dijkstra(<span class="number">1</span>,e,dis1);</span><br><span class="line">dijkstra(n,ef,disn);</span><br><span class="line"></span><br><span class="line">LL l=<span class="number">0</span>, r=dis1[n];</span><br><span class="line"><span class="keyword">while</span> (l&lt;=r) &#123;</span><br><span class="line">LL mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (check(mid)) r=mid<span class="number">-1</span>; <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,r+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;有一幅 $n$ 个点 $m$ 条边的有向图，边有边权（代表通过所需时间），你在 $1$ 号点，女朋友在 $n$ 号点。&lt;br&gt;&amp;emsp;&amp;emsp;你可以选择在 $1$ 号点延迟任意时间之后，选定一条路线开始游走，一旦开始游走就不能停下来。你的女朋友会在时间区间 $[a,b]$ 中的任意一个实数时间点 call 你，你一旦被 call 就要马上过去 $n$ 号点，女朋友的等待时间就是她 call 了之后到你到达所用的时间。&lt;br&gt;&amp;emsp;&amp;emsp;求女朋友的最坏等待时间最小。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;$n,m \le 10^5,\ \ 0 \le a \le b \le 10^{12}$，边权 $\le 10^6$&lt;br&gt;&amp;emsp;&amp;emsp;保证每个点至少有一条出边，即总是可以无限游走的。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;6s&lt;/p&gt;</summary>
    
    
    
    <category term="OI/ACM" scheme="http://kqp.world/categories/OI-ACM/"/>
    
    
    <category term="算法_DP" scheme="http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"/>
    
    <category term="算法_最短路模型" scheme="http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>【2021 Multi-University 4 E】Didn‘t I Say to Make My Abilities Average in the Next Life?! 题解</title>
    <link href="http://kqp.world/%E3%80%902021%20Multi-University%204%20E%E3%80%91Didn%E2%80%98t%20I%20Say%20to%20Make%20My%20Abilities%20Average%20in%20the%20Next%20Life!%20%E9%A2%98%E8%A7%A3/"/>
    <id>http://kqp.world/%E3%80%902021%20Multi-University%204%20E%E3%80%91Didn%E2%80%98t%20I%20Say%20to%20Make%20My%20Abilities%20Average%20in%20the%20Next%20Life!%20%E9%A2%98%E8%A7%A3/</id>
    <published>2021-08-14T06:11:29.000Z</published>
    <updated>2022-01-26T09:46:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>&emsp;&emsp;定义一个序列的 average 为 $\frac{最大值+最小值}{2}$。<br>&emsp;&emsp;给定一个序列 $a_1,\cdots,a_n$，有 $m$ 次询问，每次问这个区间的所有子区间的 average 期望。</p><p>&emsp;&emsp;$n,m \le 2 \times 10^5,\ 1 \le a_i \le 10^9$<br>&emsp;&emsp;多测，$\sum n,\sum m \le 3 \times 10^5$<br>&emsp;&emsp;8s</p><span id="more"></span><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><h2 id="扯淡"><a href="#扯淡" class="headerlink" title="扯淡"></a>扯淡</h2><p>&emsp;&emsp;考场上脑补了个 $O(m \sqrt n)$ 的只增莫队巨难写，写到最后又 WA 又 T。<br>&emsp;&emsp;第二天牛爷爷说这是个原题，上网搜了一下大家说这个题是【HNOI2016 序列】，于是就去学习了一下，老年选手被这个神奇的技巧秀得头皮发麻。。。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>&emsp;&emsp;首先 $\mathbb E[\frac{\max+\min}{2}]=\frac{\mathbb E[\max]+\mathbb E[\min]}{2}$，所以问题变成每次求一个区间所有子区间的 $\max$ 和以及 $\min$ 和。这就是【HNOI2016 序列】了。</p><p>&emsp;&emsp;做法多种多样，莫队和在线 $O(n \log n+m)$ 的都有，但其实本质相同的，莫队到在线也就多一步小转化而已。下面就讲在线的。<br>&emsp;&emsp;考虑这样一个数组：$f_i$ 表示右端点为 $i$、左端点 $\in [1,i]$ 的所有区间的 $\max$ 和。它的转移很简单，就是找到 $i$ 上一个比它大的数 $L_i$，那么左端点 $\le L_i$ 的区间的 $\max$ 都保持不变，左端点 $\in (L_i,i]$ 的区间的 $\max$ 等于 $a_i$，因此</p><script type="math/tex; mode=display">f_i=f_{L_i}+a_i(i-L_i)</script><p>&emsp;&emsp;这东西怎么用呢？变形得到 $f_i-f_{L_i}=a_i(i-L_i)$，也就是说，知道了 $i$ 的转移点 $L_i$，那么就知道了左端点 $\in(L_i,i]$、右端点为 $i$ 的所有区间的 $\max$ 和。<br>&emsp;&emsp;更进一步，$i$ 从 $L_i$ 转移来，$L_i$ 从 $L_{L_i}$ 转移来……这样形成一个转移路径（实际上就是以 $i$ 结尾的单调栈），在这条路径上的任何一个 $j$，都满足 $f_i-f_j$ 等于左端点 $\in(j,i]$、右端点为 $i$ 的所有区间的 $\max$ 和。</p><p>&emsp;&emsp;接下来就可以做这题了。<br>&emsp;&emsp;询问一个区间 $[l,r]$ 的所有子区间的 $\max$ 和，先找到这个区间的最大值所在位置 $mx$，那么凡是左端点 $\in [l,mx]$、右端点 $\in (mx,r]$ 的子区间，最大值都是 $a_{mx}$。因此问题转化成 $[l,mx)$、$(mx,r]$ 的子问题。<br>&emsp;&emsp;考虑 $(mx,r]$，重要的性质是，$mx$ 一定在 $r$ 的转移路径上，因此 $f_r-f_{mx}$ 就是左端点 $\in (mx,r]$、右端点为 $r$ 的子区间的 $\max$ 和；同理，$mx$ 一定也在 $r-1$ 的转移路径上，所以 $f_{r-1}-f_{mx}$ 就是左端点 $\in (mx,r-1]$、右端点为 $r-1$ 的子区间的 $\max$ 和……<br>&emsp;&emsp;因此 $(mx,r]$ 的贡献就是</p><script type="math/tex; mode=display">(f_r-f_{mx})+(f_{r-1}-f_{mx})+\cdots+(f_{mx+1}-f_{mx})=\left(\sum_{i=mx+1}^rf_i\right)-f_{mx}(r-mx)</script><p>&emsp;&emsp;所以求个 $f$ 的前缀和就做好了。<br>&emsp;&emsp;同理可求 $[l,mx)$ 的贡献，以及 $\min$ 和。</p><p>&emsp;&emsp;时间复杂度，预处理 rmq 需要 $O(n \log n)$，预处理 $f$ 需要 $O(n)$，每个询问是 $O(1)$ 的，因此是 $O(n \log n + m)$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,a,b) for(int i=a;i&gt;=b;i--)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">2e5</span>+<span class="number">5</span>, MX=<span class="number">17</span>;</span><br><span class="line"><span class="type">const</span> LL mo=<span class="number">1e9</span>+<span class="number">7</span>, inv2=(mo+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> st_mx[MX+<span class="number">2</span>][maxn],st_mn[MX+<span class="number">2</span>][maxn],Log[maxn];</span><br><span class="line"><span class="type">void</span> <span class="title function_">rmq_pre</span><span class="params">()</span> &#123;</span><br><span class="line">fo(i,<span class="number">1</span>,n) st_mx[<span class="number">0</span>][i]=st_mn[<span class="number">0</span>][i]=i;</span><br><span class="line">fo(i,<span class="number">2</span>,n) Log[i]=Log[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">fo(j,<span class="number">1</span>,MX)</span><br><span class="line">fo(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">st_mx[j][i]=st_mx[j<span class="number">-1</span>][i];</span><br><span class="line">st_mn[j][i]=st_mn[j<span class="number">-1</span>][i];</span><br><span class="line"><span class="type">int</span> t=i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">if</span> (t&lt;=n) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[st_mx[j][i]]&lt;a[st_mx[j<span class="number">-1</span>][t]]) st_mx[j][i]=st_mx[j<span class="number">-1</span>][t];</span><br><span class="line"><span class="keyword">if</span> (a[st_mn[j][i]]&gt;=a[st_mn[j<span class="number">-1</span>][t]]) st_mn[j][i]=st_mn[j<span class="number">-1</span>][t];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title function_">rmq</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> &#123;</span><br><span class="line"><span class="type">int</span> t=Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> mx=(a[st_mx[t][l]]&gt;=a[st_mx[t][r-(<span class="number">1</span>&lt;&lt;t)+<span class="number">1</span>]]) ?st_mx[t][l] :st_mx[t][r-(<span class="number">1</span>&lt;&lt;t)+<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> mn=(a[st_mn[t][l]]&lt;a[st_mn[t][r-(<span class="number">1</span>&lt;&lt;t)+<span class="number">1</span>]]) ?st_mn[t][l] :st_mn[t][r-(<span class="number">1</span>&lt;&lt;t)+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_pair</span>(mx,mn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL f_l_mx[maxn],f_l_mn[maxn],f_r_mx[maxn],f_r_mn[maxn];</span><br><span class="line">LL s_l_mx[maxn],s_l_mn[maxn],s_r_mx[maxn],s_r_mn[maxn];</span><br><span class="line"><span class="type">int</span> z0,z[maxn];</span><br><span class="line"><span class="type">void</span> <span class="title function_">f_pre</span><span class="params">()</span> &#123;</span><br><span class="line">z0=<span class="number">0</span>;</span><br><span class="line">fo(i,<span class="number">1</span>,n) &#123;</span><br><span class="line"><span class="keyword">while</span> (z0 &amp;&amp; a[z[z0]]&lt;a[i]) z0--;</span><br><span class="line">f_l_mx[i]=(f_l_mx[z[z0]]+(LL)a[i]*(i-z[z0]))%mo;</span><br><span class="line">s_l_mx[i]=(s_l_mx[i<span class="number">-1</span>]+f_l_mx[i])%mo;</span><br><span class="line">z[++z0]=i;</span><br><span class="line">&#125;</span><br><span class="line">z0=<span class="number">0</span>;</span><br><span class="line">fo(i,<span class="number">1</span>,n) &#123;</span><br><span class="line"><span class="keyword">while</span> (z0 &amp;&amp; a[z[z0]]&gt;=a[i]) z0--;</span><br><span class="line">f_l_mn[i]=(f_l_mn[z[z0]]+(LL)a[i]*(i-z[z0]))%mo;</span><br><span class="line">s_l_mn[i]=(s_l_mn[i<span class="number">-1</span>]+f_l_mn[i])%mo;</span><br><span class="line">z[++z0]=i;</span><br><span class="line">&#125;</span><br><span class="line">z0=<span class="number">0</span>;</span><br><span class="line">s_r_mx[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">fd(i,n,<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (z0 &amp;&amp; a[z[z0]]&lt;=a[i]) z0--;</span><br><span class="line">f_r_mx[i]=(f_r_mx[z[z0]]+(LL)a[i]*(z[z0]-i))%mo;</span><br><span class="line">s_r_mx[i]=(s_r_mx[i+<span class="number">1</span>]+f_r_mx[i])%mo;</span><br><span class="line">z[++z0]=i;</span><br><span class="line">&#125;</span><br><span class="line">z0=<span class="number">0</span>;</span><br><span class="line">s_r_mn[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">fd(i,n,<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (z0 &amp;&amp; a[z[z0]]&gt;a[i]) z0--;</span><br><span class="line">f_r_mn[i]=(f_r_mn[z[z0]]+(LL)a[i]*(z[z0]-i))%mo;</span><br><span class="line">s_r_mn[i]=(s_r_mn[i+<span class="number">1</span>]+f_r_mn[i])%mo;</span><br><span class="line">z[++z0]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL <span class="title function_">Pow</span><span class="params">(LL x,LL y)</span> &#123;</span><br><span class="line">LL re=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; y; y&gt;&gt;=<span class="number">1</span>, x=x*x%mo) <span class="keyword">if</span> (y&amp;<span class="number">1</span>) re=re*x%mo;</span><br><span class="line"><span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL <span class="title function_">sum</span><span class="params">(LL x)</span> &#123;<span class="keyword">return</span> x*(x+<span class="number">1</span>)%mo*inv2%mo;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">fo(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"></span><br><span class="line">rmq_pre();</span><br><span class="line">f_pre();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line"></span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; p=rmq(l,r);</span><br><span class="line"><span class="type">int</span> mx=p.first, mn=p.second;</span><br><span class="line">LL ans_mx=a[mx]*(LL)(mx-l+<span class="number">1</span>)%mo*(r-mx+<span class="number">1</span>)%mo;</span><br><span class="line">(ans_mx+=s_l_mx[r]-s_l_mx[mx]+mo-f_l_mx[mx]*(r-mx)%mo+mo)%=mo;</span><br><span class="line">(ans_mx+=s_r_mx[l]-s_r_mx[mx]+mo-f_r_mx[mx]*(mx-l)%mo+mo)%=mo;</span><br><span class="line">LL ans_mn=a[mn]*(LL)(mn-l+<span class="number">1</span>)%mo*(r-mn+<span class="number">1</span>)%mo;</span><br><span class="line">(ans_mn+=s_l_mn[r]-s_l_mn[mn]+mo-f_l_mn[mn]*(r-mn)%mo+mo)%=mo;</span><br><span class="line">(ans_mn+=s_r_mn[l]-s_r_mn[mn]+mo-f_r_mn[mn]*(mn-l)%mo+mo)%=mo;</span><br><span class="line">LL ans=(ans_mx+ans_mn)%mo*inv2%mo*Pow(sum(r-l+<span class="number">1</span>),mo<span class="number">-2</span>)%mo;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;定义一个序列的 average 为 $\frac{最大值+最小值}{2}$。&lt;br&gt;&amp;emsp;&amp;emsp;给定一个序列 $a_1,\cdots,a_n$，有 $m$ 次询问，每次问这个区间的所有子区间的 average 期望。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;$n,m \le 2 \times 10^5,\ 1 \le a_i \le 10^9$&lt;br&gt;&amp;emsp;&amp;emsp;多测，$\sum n,\sum m \le 3 \times 10^5$&lt;br&gt;&amp;emsp;&amp;emsp;8s&lt;/p&gt;</summary>
    
    
    
    <category term="OI/ACM" scheme="http://kqp.world/categories/OI-ACM/"/>
    
    
    <category term="算法_神奇的脑洞" scheme="http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"/>
    
    <category term="算法_莫队/分块" scheme="http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E8%8E%AB%E9%98%9F-%E5%88%86%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>【2021 Multi-University 4 G】Increasing Subsequence 题解</title>
    <link href="http://kqp.world/%E3%80%902021%20Multi-University%204%20G%E3%80%91Increasing%20Subsequence%20%E9%A2%98%E8%A7%A3/"/>
    <id>http://kqp.world/%E3%80%902021%20Multi-University%204%20G%E3%80%91Increasing%20Subsequence%20%E9%A2%98%E8%A7%A3/</id>
    <published>2021-08-13T02:54:40.000Z</published>
    <updated>2022-01-26T09:46:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>&emsp;&emsp;给定一个排列 $a_1,\cdots,a_n$，求极长上升子序列的数量。</p><p>&emsp;&emsp;$n \le 10^5$</p><span id="more"></span><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>&emsp;&emsp;设 $dp_i$ 表示以 $i$ 结尾的极长上升子序列数量，那么关键就是找到 $dp_i$ 能从哪些 $dp_j$ 转移过来，需要满足 $a_i&gt;a_j$ 且 $j$ 到 $i$ 之间没有 $\in [a_j,a_i]$ 的数了。<br>&emsp;&emsp;这种前面的数贡献到后面的数的模型，还要想到 cdq 这种！<br>&emsp;&emsp;假设当前分治区间 $[l,r]$，中间是 $mid$。把 $a_l,\cdots,a_r$ 从小到大排序，然后左半边维护一个位置单调递减的栈，右半边维护一个位置单调递增的栈，大概长这样：</p><script type="math/tex; mode=display">7\ 6\ 3\ 1\ |\ 2\ 4\ 5\ 8</script><p>&emsp;&emsp;（中线代表 $mid$，两边分别是向左向右增长的栈，数字是 $a$ 值，保持了原序列的相对位置关系）<br>&emsp;&emsp;左边的单调栈的含义是，如果有一个很大的数放在了很右的位置，显然它左边的小的数都不再能转移出去了；右边的单调栈的含义是，因为右边是代表询问的，因此如果有一个很大的数放在了很左的位置，那么它会对以后的询问构成更紧的限制，它右边的小的数就没用了。<br>&emsp;&emsp;那么比如 $8$ 插入到右边的栈，它的栈里下一个元素是 $5$，意思就是左边 $5$ 及以下的数都不能转移到 $8$，因此能转移到 $8$ 的只有 $6,7$。那么这就是个在左边栈里二分的过程。<br>&emsp;&emsp;复杂度 $O(n \log ^2 n)$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,a,b) for(int i=a;i&gt;=b;i--)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> LL mo=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,a[maxn];</span><br><span class="line"><span class="type">bool</span> canBeInit[maxn];</span><br><span class="line"></span><br><span class="line">LL dp[maxn],Sl[maxn];</span><br><span class="line"><span class="type">int</span> b0,zl0,zl[maxn],zr0,zr[maxn];</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; b[maxn];</span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line"><span class="type">int</span> l=<span class="number">1</span>, r=zl0;</span><br><span class="line"><span class="keyword">while</span> (l&lt;=r) &#123;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (a[zl[mid]]&lt;x) l=mid+<span class="number">1</span>; <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">cdq</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (l==r) &#123;</span><br><span class="line">(dp[l]+=canBeInit[l])%=mo;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">cdq(l,mid);</span><br><span class="line"></span><br><span class="line">b0=<span class="number">0</span>;</span><br><span class="line">fo(i,l,r) b[++b0]=<span class="built_in">make_pair</span>(a[i],i);</span><br><span class="line">sort(b+<span class="number">1</span>,b+<span class="number">1</span>+b0);</span><br><span class="line">zl0=zr0=<span class="number">0</span>;</span><br><span class="line">fo(i,<span class="number">1</span>,b0) <span class="keyword">if</span> (b[i].second&lt;=mid) &#123;</span><br><span class="line"><span class="keyword">while</span> (zl0 &amp;&amp; zl[zl0]&lt;b[i].second) zl0--;</span><br><span class="line">zl[++zl0]=b[i].second;</span><br><span class="line">Sl[zl0]=(Sl[zl0<span class="number">-1</span>]+dp[b[i].second])%mo;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (zr0 &amp;&amp; zr[zr0]&gt;b[i].second) zr0--;</span><br><span class="line"><span class="type">int</span> t=find(a[zr[zr0]]);</span><br><span class="line">(dp[b[i].second]+=Sl[zl0]-Sl[t]+mo)%=mo;</span><br><span class="line">zr[++zr0]=b[i].second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cdq(mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">fo(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> last=n+<span class="number">1</span>;</span><br><span class="line">fo(i,<span class="number">1</span>,n) <span class="keyword">if</span> (a[i]&lt;last) &#123;</span><br><span class="line">canBeInit[i]=<span class="number">1</span>;</span><br><span class="line">last=a[i];</span><br><span class="line">&#125; <span class="keyword">else</span> canBeInit[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(LL)*(n+<span class="number">2</span>));</span><br><span class="line">cdq(<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">last=<span class="number">0</span>;</span><br><span class="line">LL ans=<span class="number">0</span>;</span><br><span class="line">fd(i,n,<span class="number">1</span>) <span class="keyword">if</span> (a[i]&gt;last) &#123;</span><br><span class="line">last=a[i];</span><br><span class="line">(ans+=dp[i])%=mo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;给定一个排列 $a_1,\cdots,a_n$，求极长上升子序列的数量。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;$n \le 10^5$&lt;/p&gt;</summary>
    
    
    
    <category term="OI/ACM" scheme="http://kqp.world/categories/OI-ACM/"/>
    
    
    <category term="算法_分治" scheme="http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>【SEERC 2020 H】AND = OR 题解</title>
    <link href="http://kqp.world/%E3%80%90SEERC%202020%20H%E3%80%91AND%20=%20OR%20%E9%A2%98%E8%A7%A3/"/>
    <id>http://kqp.world/%E3%80%90SEERC%202020%20H%E3%80%91AND%20=%20OR%20%E9%A2%98%E8%A7%A3/</id>
    <published>2021-08-12T08:10:36.000Z</published>
    <updated>2022-01-26T09:46:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>&emsp;&emsp;定义一个序列是好的，当且仅当能把这个序列里的数划分成两个非空集合，使得一个集合的 and 等于另一个集合的 or。<br>&emsp;&emsp;给定 $a_1,\cdots,a_n$，有 $q$ 个询问，每次询问 $a_l,\cdots,a_r$ 是否是好的。</p><p>&emsp;&emsp;$n,q \le 10^5,\ 0 \le a_i &lt; 2^{30}$<br>&emsp;&emsp;3s</p><span id="more"></span><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>&emsp;&emsp;and 会把数字越 and 越小，or 会把数字越 or 越大，所以应该让“大”的数去 and，“小”的数去 or。<br>&emsp;&emsp;怎么定义“大”和“小”呢？如果就按数值来分，是可以的，可以证明如果询问一个区间 $[l,r]$，一定是把这个区间从小到大排序后从某个位置切开，小的部分 or，大的部分 and，但似乎不太能做这题。。。<br>&emsp;&emsp;另一种“大”和“小”的定义是二进制下 1 的个数。对于每个询问，假设最终答案有 $x$ 个 1，那么比 $x$ 多的 $a_i$ 就应当 and，比 $x$ 小的 $a_i$ 就应当 or。而恰好有 $x$ 个 1 的 $a_i$，要么全都扔向同一边，要么它们全都相等（都等于答案）然后分到两边。<br>&emsp;&emsp;所以对于每个询问，用主席树求出这个区间以 1 的数量为下标的前缀 or 以及后缀 and，然后枚举 $x$ 判断即可。注意如果要把恰好有 $x$ 个 1 的 $a_i$ 扔到两边的话，那么这样的 $a_i$ 的数量要 $\ge 2$。因此主席树要记录区间 or、区间 and、区间元素数量。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,a,b) for(int i=a;i&gt;=b;i--)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>, MX=<span class="number">30</span>, maxtot=<span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AST</span>&#123;</span></span><br><span class="line"><span class="type">int</span> val,num,i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmpA</span><span class="params">(<span class="type">const</span> AST &amp;a,<span class="type">const</span> AST &amp;b)</span> &#123;<span class="keyword">return</span> a.num&lt;b.num;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line">AST a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> totOr,totAnd,tr_or[maxtot],tr_and[maxtot],tr_cnt[maxtot],son_or[maxtot][<span class="number">2</span>],son_and[maxtot][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> rootOr[MX+<span class="number">2</span>],rootAnd[MX+<span class="number">2</span>],resOr,resAnd,resCnt;</span><br><span class="line"><span class="type">void</span> <span class="title function_">tr_xg_or</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> last,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> z)</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">tr_or[k]=tr_or[last]|z;</span><br><span class="line">tr_cnt[k]=tr_cnt[last]+<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (x&lt;=mid) &#123;</span><br><span class="line">son_or[k][<span class="number">1</span>]=son_or[last][<span class="number">1</span>];</span><br><span class="line">son_or[k][<span class="number">0</span>]=++totOr;</span><br><span class="line">k=totOr, last=son_or[last][<span class="number">0</span>], r=mid;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">son_or[k][<span class="number">0</span>]=son_or[last][<span class="number">0</span>];</span><br><span class="line">son_or[k][<span class="number">1</span>]=++totOr;</span><br><span class="line">k=totOr, last=son_or[last][<span class="number">1</span>], l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">tr_or[k]=tr_or[last]|z;</span><br><span class="line">tr_cnt[k]=tr_cnt[last]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">tr_xg_and</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> last,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> z)</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">tr_and[k]=tr_and[last]&amp;z;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (x&lt;=mid) &#123;</span><br><span class="line">son_and[k][<span class="number">1</span>]=son_and[last][<span class="number">1</span>];</span><br><span class="line">son_and[k][<span class="number">0</span>]=++totAnd;</span><br><span class="line">k=totAnd, last=son_and[last][<span class="number">0</span>], r=mid;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">son_and[k][<span class="number">0</span>]=son_and[last][<span class="number">0</span>];</span><br><span class="line">son_and[k][<span class="number">1</span>]=++totAnd;</span><br><span class="line">k=totAnd, last=son_and[last][<span class="number">1</span>], l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">tr_and[k]=tr_and[last]&amp;z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">tr_cx</span><span class="params">(<span class="type">int</span> kOr,<span class="type">int</span> lastOr,<span class="type">int</span> kAnd,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (x&lt;=l &amp;&amp; r&lt;=y) &#123;</span><br><span class="line">resOr|=tr_or[kOr];</span><br><span class="line">resAnd&amp;=tr_and[kAnd];</span><br><span class="line">resCnt+=tr_cnt[kOr]-tr_cnt[lastOr];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (x&lt;=mid) tr_cx(son_or[kOr][<span class="number">0</span>],son_or[lastOr][<span class="number">0</span>],son_and[kAnd][<span class="number">0</span>],l,mid,x,y);</span><br><span class="line"><span class="keyword">if</span> (mid&lt;y) tr_cx(son_or[kOr][<span class="number">1</span>],son_or[lastOr][<span class="number">1</span>],son_and[kAnd][<span class="number">1</span>],mid+<span class="number">1</span>,r,x,y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sumOr[MX+<span class="number">5</span>],sumAnd[MX+<span class="number">5</span>],cnt[MX+<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;q);</span><br><span class="line">fo(i,<span class="number">1</span>,n) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i].val);</span><br><span class="line">a[i].num=__builtin_popcount(a[i].val);</span><br><span class="line">a[i].i=i;</span><br><span class="line">&#125;</span><br><span class="line">sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmpA);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">fo(w,<span class="number">0</span>,MX) &#123;</span><br><span class="line"><span class="keyword">if</span> (w) rootOr[w]=rootOr[w<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(; i&lt;=n &amp;&amp; a[i].num==w; i++) &#123;</span><br><span class="line"><span class="type">int</span> last=rootOr[w];</span><br><span class="line">tr_xg_or(rootOr[w]=++totOr,last,<span class="number">1</span>,n,a[i].i,a[i].val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">tr_and[<span class="number">0</span>]=(<span class="number">1</span>&lt;&lt;<span class="number">30</span>)<span class="number">-1</span>;</span><br><span class="line">i=n;</span><br><span class="line">fd(w,MX,<span class="number">0</span>) &#123;</span><br><span class="line">rootAnd[w]=rootAnd[w+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(; i &amp;&amp; a[i].num==w; i--) &#123;</span><br><span class="line"><span class="type">int</span> last=rootAnd[w];</span><br><span class="line">tr_xg_and(rootAnd[w]=++totAnd,last,<span class="number">1</span>,n,a[i].i,a[i].val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q--) &#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sumCnt=<span class="number">0</span>;</span><br><span class="line">fo(w,<span class="number">0</span>,MX) &#123;</span><br><span class="line">resOr=<span class="number">0</span>, resAnd=(<span class="number">1</span>&lt;&lt;<span class="number">30</span>)<span class="number">-1</span>, resCnt=<span class="number">0</span>;</span><br><span class="line">tr_cx(rootOr[w],(w==<span class="number">0</span> ?<span class="number">0</span> :rootOr[w<span class="number">-1</span>]),rootAnd[w],<span class="number">1</span>,n,l,r);</span><br><span class="line">sumOr[w]=resOr;</span><br><span class="line">sumAnd[w]=resAnd;</span><br><span class="line">cnt[w]=resCnt;</span><br><span class="line">sumCnt+=resCnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> numLess=<span class="number">0</span>;</span><br><span class="line">fo(w,<span class="number">0</span>,MX) &#123;</span><br><span class="line"><span class="keyword">if</span> (numLess &amp;&amp; numLess&lt;sumCnt &amp;&amp; sumOr[w<span class="number">-1</span>]==sumAnd[w]) &#123;ans=<span class="number">1</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">if</span> (sumOr[w]==sumAnd[w] &amp;&amp; cnt[w]&gt;=<span class="number">2</span>) &#123;ans=<span class="number">1</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">numLess+=cnt[w];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(ans ?<span class="string">&quot;YES&quot;</span> :<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;定义一个序列是好的，当且仅当能把这个序列里的数划分成两个非空集合，使得一个集合的 and 等于另一个集合的 or。&lt;br&gt;&amp;emsp;&amp;emsp;给定 $a_1,\cdots,a_n$，有 $q$ 个询问，每次询问 $a_l,\cdots,a_r$ 是否是好的。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;$n,q \le 10^5,\ 0 \le a_i &amp;lt; 2^{30}$&lt;br&gt;&amp;emsp;&amp;emsp;3s&lt;/p&gt;</summary>
    
    
    
    <category term="OI/ACM" scheme="http://kqp.world/categories/OI-ACM/"/>
    
    
    <category term="算法_位运算" scheme="http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>【编译原理大作业】Tiny+的三地址码</title>
    <link href="http://kqp.world/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%A7%E4%BD%9C%E4%B8%9A%E3%80%91Tiny+%E7%9A%84%E4%B8%89%E5%9C%B0%E5%9D%80%E7%A0%81/"/>
    <id>http://kqp.world/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%A7%E4%BD%9C%E4%B8%9A%E3%80%91Tiny+%E7%9A%84%E4%B8%89%E5%9C%B0%E5%9D%80%E7%A0%81/</id>
    <published>2021-08-11T08:32:19.000Z</published>
    <updated>2022-01-25T07:56:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<del>咕得有点久了</del><br>&emsp;&emsp;这是编译原理大作业的第二步：进行语义分析，生成三地址码。<br><span id="more"></span><br>&emsp;&emsp;三地址码是一种平台无关的中间代码（类似汇编，但没到 x86、MIPS 那么具体），特点是：1、变量和 label 无需换成具体的地址，能区分清楚就行（例如嵌套作用域的同名变量要区分开）；2、寄存器无限量，不需要考虑有限的寄存器池；3、没有关于 CPU、操作系统的对接细节。这还是一个比较中间层次的东西，要生成具体的可执行代码时，不同平台可以直接拿三地址码来翻译。<br>&emsp;&emsp;有了上一步的语法树之后，这一部分就不需要额外的工具了，就在语法树上完成需要的操作。尽管语义分析可以在语法分析的过程中完成，但是建出树以后再操作会好写一点，反正时间复杂度是不变的。<br>&emsp;&emsp;参考书用龙书即可（Compilers Principles, Techniques, Tools. second version），龙书已经把框架给得很清楚了，虽然略去了一堆坑 b 的细节。。。<br>&emsp;&emsp;三地址码的格式也用龙书的。</p><p>&emsp;&emsp;<a href="https://github.com/l2l7l9p/Tiny">项目地址</a></p><h2 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h2><p>&emsp;&emsp;语义分析是比较大的概念，对于不同的程序有不同的语义分析内容，例如，基于<a href="https://github.com/l2l7l9p/Tiny/blob/master/Tiny+EBNF.md">我的语言定义</a>，可以进行包括但不限于如下的语义分析：</p><ul><li>检查整个程序是否有且仅有一个 <code>MAIN</code> 标识的函数；</li><li>检查变量、函数引用前是否声明；</li><li>检查变量、函数是否重定义；</li><li>类型检查与类型强制转换。目前 Tiny+ 程序可用的类型只有 <code>BOOL</code>,<code>CHAR</code>,<code>INT</code>,<code>REAL</code>，它们之间都可以强制转换，且已按优先级从低到高排好。因此可以不用进行类型检查，只需在类型不匹配时强制类型转换（低优先级转换到高优先级）；</li><li>调用函数时检查参数及类型是否匹配；</li><li>检查函数是否以 <code>RETURN</code> 结尾，若不是，需提出 warning。</li></ul><p>&emsp;&emsp;我们可以在生成三地址码的过程中顺便做这些事情。</p><h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><p>&emsp;&emsp;符号表是一个栈结构，用于记录生成代码中遇到的各种符号，以便在真正的编译中替换成地址。本次的符号表需记录以下内容：</p><ul><li>定义的变量；</li><li>定义的函数；</li><li>控制流跳转用的 label</li></ul><p>&emsp;&emsp;具体实现，在基类 <code>node</code> 中定义符号表：(26 行)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Symbol_t</span>&#123;</span></span><br><span class="line">    SB_VAR,</span><br><span class="line">    SB_FUNC,</span><br><span class="line">    SB_LABEL,</span><br><span class="line">    SB_NOTFOUND</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Symbol</span> &#123;</span></span><br><span class="line">    Symbol_t type;</span><br><span class="line">    <span class="built_in">string</span> label;</span><br><span class="line">    Var_t varType;</span><br><span class="line">    node *ref;        <span class="comment">// reference to that symbol</span></span><br><span class="line"></span><br><span class="line">    Symbol(Symbol_t ty,<span class="built_in">string</span> lb=<span class="string">&quot;&quot;</span>,Var_t vt=V_BOOL,node *rf=nullptr) &#123;</span><br><span class="line">        type=ty, varType=vt, label=lb, ref=rf;</span><br><span class="line">    &#125;</span><br><span class="line">    Symbol() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,Symbol&gt; SymbolTabType;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    public:</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">static</span> <span class="built_in">vector</span>&lt;SymbolTabType&gt; symbolTab;         <span class="comment">// symbol table. It is a stack</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> EOCFCnt, elseCnt, loopCnt, varCnt;   <span class="comment">// label count</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;用 <code>std::vector</code> 来模拟符号表的栈（为了可以遍历栈元素而不用 <code>std::stack</code>）；栈的每一项是一个 <code>unordered_map&lt;string,Symbol&gt;</code>，用于映射符号到其信息；信息用 <code>struct Symbol</code> 来记录，内容包括符号类型、符号的 label、符号的运算类型（<code>BOOL,INT</code> 等）、代表该符号的语法树节点。<br>&emsp;&emsp;在实际编译中，只有跨文件的符号需要记录 label 以用于链接，其余符号可直接记录其内存地址，因为符号最终就是要替换成地址的。<br>&emsp;&emsp;另使用 <code>EOCFCnt, elseCnt, loopCnt, varCnt</code> 四个计数器来生成控制流跳转 label 标号、else 跳转 label 标号、循环跳转 label 标号、变量及寄存器唯一标号。使用计数器的目的就是使得 label、变量和寄存器标号变得唯一。</p><h3 id="从符号表中查找符号"><a href="#从符号表中查找符号" class="headerlink" title="从符号表中查找符号"></a>从符号表中查找符号</h3><p>&emsp;&emsp;从符号表中查找一个符号，就从栈顶往栈底依次查找，找到了返回相应的 <code>Symbol</code> 信息，找不到就返回 <code>NOTFOUND</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Symbol <span class="title function_">find_symbol</span><span class="params">(<span class="built_in">string</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=node::symbolTab.size()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (node::symbolTab[i].count(s)) <span class="keyword">return</span> node::symbolTab[i][s];</span><br><span class="line">    <span class="keyword">return</span> Symbol(SB_NOTFOUND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="控制流结束跳转-label"><a href="#控制流结束跳转-label" class="headerlink" title="控制流结束跳转 label"></a>控制流结束跳转 label</h3><p>&emsp;&emsp;If、For 等控制流需要一个继承属性 label 表示该控制流结束之后跳转到何处。这个继承属性在符号表中实现，用 <code>%EOCF</code> 符号（End Of Control Flow）来表示该语句结束后应跳转到的 label。这样 If、For 等节点具体生成代码的时候，只要从符号表中查找最近的 <code>%EOCF</code>，就知道如何跳转了。</p><h2 id="三地址码"><a href="#三地址码" class="headerlink" title="三地址码"></a>三地址码</h2><p>&emsp;&emsp;在基类 <code>node</code> 中定义虚函数 <code>generate_3addr_code()</code>，即每个节点类实现自己的三地址码生成过程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;&gt; Codes;      <span class="comment">// format: pair&lt;label,instruction&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span>&#123;</span></span><br><span class="line">public:</span><br><span class="line">...</span><br><span class="line">Codes codes;</span><br><span class="line">virtual <span class="type">bool</span> <span class="title function_">generate_3addr_code</span><span class="params">()</span> &#123;&#125;      <span class="comment">// return 0 if compiled successfully</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;三地址码形如 <code>vector&lt;pair&lt;string,string&gt;&gt;</code>，每条指令代码用两个 <code>string</code> 表示，前一个 <code>string</code> 表示 label，后一个 <code>string</code> 表示指令。<br>&emsp;&emsp;本次实验中，label 和指令是多对一的关系，即相同名称的 label 一定指向同一条指令，但一条指令可以对应多个 label。这在实际编译中也是可行的，因为 label 的本质是内存地址，如果用内存地址代替 label 的记录，那么 label 和指令就是一一对应的了。<br>&emsp;&emsp;接下来分不同的节点类来说明 <code>generate_3addr_code()</code> 的实现，以及相应的语法检查。</p><h3 id="Program"><a href="#Program" class="headerlink" title="Program"></a>Program</h3><p>&emsp;&emsp;Program 是整个语法树的根，它新建一层符号表用于标记全局 label，调用它的子节点（MethodDecls）生成代码，并在整份代码开头补充一句 <code>goto mainFuncLabel</code> 使得程序跳到 <code>MAIN</code> 函数入口。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">node_Program::generate_3addr_code</span><span class="params">()</span> &#123;</span><br><span class="line">    symbolTab.push_back(SymbolTabType());                   <span class="comment">// global label</span></span><br><span class="line">    <span class="type">bool</span> err=son[<span class="number">0</span>]-&gt;generate_3addr_code();</span><br><span class="line">    codes.push_back(<span class="built_in">make_pair</span>(<span class="string">&quot;&quot;</span>,<span class="string">&quot;goto &quot;</span>+mainFuncLabel));   <span class="comment">// goto main function</span></span><br><span class="line">    add_codes(codes,son[<span class="number">0</span>]-&gt;codes);</span><br><span class="line">    symbolTab.pop_back();</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;<code>add_codes(a,b)</code> 是把 <code>b</code> 的代码加到 <code>a</code> 的末尾。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_codes</span><span class="params">(Codes &amp;a,Codes &amp;b)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (a.empty()) a=b;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">auto</span> code:b) a.push_back(code);</span><br><span class="line">b.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="MethodDecls"><a href="#MethodDecls" class="headerlink" title="MethodDecls"></a>MethodDecls</h3><p>&emsp;&emsp;该节点可以得到整个程序的函数列表。因此先把函数标识符添加到符号表中，生成它们的跳转 label（”__” 加函数名），这样就可以做到函数的调用与声明顺序无关。<br>&emsp;&emsp;此处顺便找出 <code>MAIN</code> 标识的函数，并检查是否唯一。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> node::mainFuncLabel=<span class="string">&quot;NO&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">node_MethodDecls::generate_3addr_code</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">bool</span> err=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// add function names to symbol table, and find &#x27;main&#x27;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> xp:son) &#123;</span><br><span class="line">        node_MethodDecl *x=(node_MethodDecl*)xp;</span><br><span class="line">        <span class="built_in">string</span> &amp;funcName=((node_Id*)(x-&gt;son[<span class="number">1</span>]))-&gt;name;</span><br><span class="line">        symbolTab.back()[funcName]=Symbol(SB_FUNC,<span class="string">&quot;__&quot;</span>+funcName,((node_Type*)(x-&gt;son[<span class="number">0</span>]))-&gt;varType,xp);</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;isMain) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mainFuncLabel!=<span class="string">&quot;NO&quot;</span>) semantic_error(<span class="string">&quot;more than one main function&quot;</span>)</span><br><span class="line">                <span class="keyword">else</span> mainFuncLabel=<span class="string">&quot;__&quot;</span>+funcName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mainFuncLabel==<span class="string">&quot;NO&quot;</span>) semantic_error(<span class="string">&quot;no main function&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> xp:son) &#123;     <span class="comment">// enumerate each method</span></span><br><span class="line">        <span class="comment">// each method generates its codes and add to this-&gt;codes</span></span><br><span class="line">        node_MethodDecl *x=(node_MethodDecl*)xp;</span><br><span class="line">err|=x-&gt;generate_3addr_code();</span><br><span class="line">add_codes(codes,x-&gt;codes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里用到了语义报错操作。简单地在节点类里记录一下当前节点对应的代码的行号（新建节点时保存 flex 的 <code>yylineno</code> 即可），就可以报错时输出行号了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> semantic_error(message) &#123;\</span></span><br><span class="line"><span class="meta">cout &lt;&lt; lineno &lt;&lt; <span class="string">&quot;: semantic error: &quot;</span> &lt;&lt; message &lt;&lt; endl;\</span></span><br><span class="line"><span class="meta">err=1;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> semantic_warning(message) &#123;\</span></span><br><span class="line"><span class="meta">cout &lt;&lt; lineno &lt;&lt; <span class="string">&quot;: warning: &quot;</span> &lt;&lt; message &lt;&lt; endl;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="MethodDecl"><a href="#MethodDecl" class="headerlink" title="MethodDecl"></a>MethodDecl</h3><p>&emsp;&emsp;该节点是具体的一个函数。首先新建一层符号表，表示新一层的局部变量，以及在表里记录当前所在的函数信息（<code>return</code> 要用）；然后处理形参表，将形参加入局部变量；接着生成函数内的 statements 的具体代码；最后检查代码的最后一条指令是否是 <code>return</code>。<br>&emsp;&emsp;这里需要新建一个 <code>%EOCF</code> 符号，指向最后的 <code>return</code>，即如果该函数最后一条语句是 If 等控制流，那么这个 If 语句就知道它要跳转到最后的 <code>return</code> 了。（如果代码自己生成了 <code>return</code>，那么这个符号也是用不上的。）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">node_MethodDecl::generate_3addr_code</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">bool</span> err=<span class="number">0</span>;</span><br><span class="line">    symbolTab.push_back(SymbolTabType());                            <span class="comment">// local label</span></span><br><span class="line">    symbolTab.back()[<span class="string">&quot;%EOCF&quot;</span>]=Symbol(SB_LABEL,<span class="string">&quot;EOCF_&quot;</span>+to_string(EOCFCnt++));    <span class="comment">// &#x27;End Of Control Flow&#x27; label</span></span><br><span class="line">    <span class="comment">// mark which function we are in</span></span><br><span class="line">    symbolTab.back()[<span class="string">&quot;%FUNC&quot;</span>]=Symbol(SB_LABEL,<span class="string">&quot;&quot;</span>,((node_Type*)son[<span class="number">0</span>])-&gt;varType,(node*)this);</span><br><span class="line">    err|=((node_FormalParams*)son[<span class="number">2</span>])-&gt;add_formal_params();        <span class="comment">// formal parameters</span></span><br><span class="line">    <span class="keyword">if</span> (son.size()&gt;=<span class="number">4</span>) &#123;</span><br><span class="line">        err|=son[<span class="number">3</span>]-&gt;generate_3addr_code();                        <span class="comment">// statements</span></span><br><span class="line">        add_codes(codes,son[<span class="number">3</span>]-&gt;codes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check if the last instruction is return</span></span><br><span class="line">    <span class="keyword">if</span> (codes.empty() || codes.back().second!=<span class="string">&quot;return&quot;</span>) &#123;</span><br><span class="line">        semantic_warning(<span class="string">&quot;lack of return at the end of function&quot;</span>);</span><br><span class="line">        codes.push_back(<span class="built_in">make_pair</span>(<span class="string">&quot;&quot;</span>,<span class="string">&quot;return&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    codes.back().first.insert(<span class="number">0</span>,symbolTab.back()[<span class="string">&quot;%EOCF&quot;</span>].label+<span class="string">&quot;: &quot;</span>);</span><br><span class="line">    codes[<span class="number">0</span>].first.insert(<span class="number">0</span>,<span class="string">&quot;__&quot;</span>+((node_Id*)son[<span class="number">1</span>])-&gt;name+<span class="string">&quot;: &quot;</span>);    <span class="comment">// mark the entrance of function</span></span><br><span class="line">    symbolTab.pop_back();</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Statements"><a href="#Statements" class="headerlink" title="Statements"></a>Statements</h3><p>&emsp;&emsp;该节点表示语句的集合，同时也表示被 <code>BEGIN, END</code> 包起来的一个区块。所以逻辑就是先新建一层符号表表示局部变量，然后每条语句依次生成。<br>&emsp;&emsp;但是遇到控制流语句的时候，要判断该语句是否是最后一句，如果是，那么 <code>%EOCF</code> 沿用祖先的（即控制流结束后跳转到祖先指定的地方），否则新建一个 <code>%EOCF</code> 指向下一条语句，并在下一条语句的第一个指令加上这个 label。</p><p>&emsp;&emsp;听起来很简单</p><p>&emsp;&emsp;但实际上。。。细思极恐，所谓“<code>%EOCF</code>指向下一条语句，并在下一条语句的第一个指令加上这个 label”，它可能需要处理这样的代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">IF (z==1) BEGIN</span><br><span class="line">IF (i==1) BEGIN</span><br><span class="line">IF (y==2) BEGIN</span><br><span class="line">END</span><br><span class="line">BEGIN</span><br><span class="line">END</span><br><span class="line">BEGIN</span><br><span class="line">BEGIN</span><br><span class="line">END</span><br><span class="line">END</span><br><span class="line">END</span><br><span class="line">BEGIN</span><br><span class="line">BEGIN</span><br><span class="line">END</span><br><span class="line">END</span><br><span class="line">BEGIN</span><br><span class="line">END</span><br><span class="line">END</span><br><span class="line">BEGIN</span><br><span class="line">INT a;</span><br><span class="line">END</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这里的三个 if 全部都有“下一条语句”，但由于“下一条语句”为空，因此它们最终全都要使用祖先的 <code>%EOCF</code>，而不能新建 label 然后加到“下一条语句”。<br>&emsp;&emsp;有同学说，既然这是空语句产生的 bug，那在生成语法树时就把这些空语句规避掉，不建立节点，不就好了？其一，空语句结构可能很复杂（比如这样嵌套的），从语法上处理它是比较麻烦的；其二，空语句不一定是形式上的空语句，还可以是实质空语句（就是写了非平凡的代码但生成的是空语句，例如因代码优化导致的空语句，例如局部变量定义也是不产生代码的），这导致一个不可规避的问题。</p><p>&emsp;&emsp;解决方法是，遇到控制流，就把这一段连续的控制流语句抠出来，然后倒着做，相当于先要找到真正的非空的“下一条语句”在哪，然后倒序依次在这条语句的开头新建 <code>%EOCF</code>（或是决定用祖先的）给上一条语句用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isControlFlow</span><span class="params">(node *x)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (!x-&gt;son.empty() &amp;&amp; (x-&gt;son[<span class="number">0</span>]-&gt;nodeType==IFSTMT || x-&gt;son[<span class="number">0</span>]-&gt;nodeType==FORSTMT));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">node_Statements::generate_3addr_code</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">bool</span> err=<span class="number">0</span>;</span><br><span class="line">symbolTab.push_back(SymbolTabType());<span class="comment">// local label</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;son.size(); i++) &#123;</span><br><span class="line">node_Statement *x=(node_Statement*)son[i];</span><br><span class="line"><span class="keyword">if</span> (isControlFlow(x)) &#123;</span><br><span class="line"><span class="comment">// for continuous control flows, generate codes in reverse order,</span></span><br><span class="line"><span class="comment">// to avoid bugs of EOCF label with empty statement</span></span><br><span class="line"><span class="built_in">vector</span>&lt;node*&gt; CFlist;</span><br><span class="line"><span class="type">int</span> j=i;<span class="comment">// i: the first CF;   j: after the last CF</span></span><br><span class="line"><span class="keyword">for</span>(; ; j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(; j&lt;son.size() &amp;&amp; isControlFlow(son[j]); j++) CFlist.push_back(son[j]);</span><br><span class="line"><span class="keyword">if</span> (j&gt;=son.size()) <span class="keyword">break</span>;</span><br><span class="line">err|=son[j]-&gt;generate_3addr_code();</span><br><span class="line"><span class="keyword">if</span> (!son[j]-&gt;codes.empty()) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j&lt;son.size()) &#123;</span><br><span class="line"><span class="built_in">string</span> eocf=<span class="string">&quot;EOCF_&quot;</span>+to_string(EOCFCnt++);</span><br><span class="line">symbolTab.back()[<span class="string">&quot;%EOCF&quot;</span>]=Symbol(SB_LABEL,eocf);</span><br><span class="line">son[j]-&gt;codes[<span class="number">0</span>].first.insert(<span class="number">0</span>,eocf+<span class="string">&quot;: &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=CFlist.size()<span class="number">-1</span>; k&gt;=<span class="number">0</span>; k--) &#123;</span><br><span class="line">err|=CFlist[k]-&gt;generate_3addr_code();</span><br><span class="line"><span class="keyword">if</span> (k&gt;i) &#123;</span><br><span class="line"><span class="built_in">string</span> eocf=<span class="string">&quot;EOCF_&quot;</span>+to_string(EOCFCnt++);</span><br><span class="line">symbolTab.back()[<span class="string">&quot;%EOCF&quot;</span>]=Symbol(SB_LABEL,eocf);</span><br><span class="line">CFlist[k]-&gt;codes[<span class="number">0</span>].first.insert(<span class="number">0</span>,eocf+<span class="string">&quot;: &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">symbolTab.back().erase(<span class="string">&quot;%EOCF&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(; i&lt;=j; i++) <span class="keyword">if</span> (i&lt;son.size()) add_codes(codes,son[i]-&gt;codes);</span><br><span class="line">i--;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">err|=x-&gt;generate_3addr_code();<span class="comment">// each statement</span></span><br><span class="line">add_codes(codes,x-&gt;codes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">symbolTab.pop_back();</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h3><p>&emsp;&emsp;<code>LocalVarDecl, AssignStmt, ReturnStmt, ReadStmt, WriteStmt</code> 都是单条简单语句，它们生成的代码都较为简单，代码不赘述。<br>&emsp;&emsp;<code>ReturnStmt</code> 需要注意若返回表达式的类型与函数类型不匹配，则要强制类型转换。<br>&emsp;&emsp;<code>ReadStmt, WriteStmt</code> 当作函数调用处理。</p><p>&emsp;&emsp;以 <code>AssignStmt</code> 为例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">node_AssignStmt::generate_3addr_code</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">bool</span> err=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> &amp;leftName=((node_Id*)son[<span class="number">0</span>])-&gt;name;</span><br><span class="line">Symbol left=find_symbol(leftName);</span><br><span class="line"><span class="keyword">if</span> (left.type==SB_NOTFOUND) semantic_error(<span class="string">&quot;undeclared identifier &#x27;&quot;</span>+leftName+<span class="string">&quot;&#x27;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left.type!=SB_VAR) semantic_error(<span class="string">&quot;identifier &#x27;&quot;</span>+leftName+<span class="string">&quot;&#x27; is not a variable&quot;</span>);</span><br><span class="line">err|=son[<span class="number">1</span>]-&gt;generate_3addr_code();</span><br><span class="line">add_codes(codes,son[<span class="number">1</span>]-&gt;codes);</span><br><span class="line">codes.push_back(<span class="built_in">make_pair</span>(<span class="string">&quot;&quot;</span>,left.label+<span class="string">&quot; = &quot;</span>+((node_Expression*)son[<span class="number">1</span>])-&gt;resultLabel));</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="IfStmt"><a href="#IfStmt" class="headerlink" title="IfStmt"></a>IfStmt</h3><p>&emsp;&emsp;If 是一个控制流，有 else 和没 else 的生成规则分别为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;codes of expression of condition&gt;</span><br><span class="line">ifFalse &lt;condition&gt; goto %EOCF</span><br><span class="line">&lt;codes of ifTrue&gt;</span><br><span class="line">%EOCF: ...</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;和<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;codes of expression of condition&gt;</span><br><span class="line">ifFalse &lt;condition&gt; goto else</span><br><span class="line">&lt;codes of ifTrue&gt;</span><br><span class="line">goto %EOCF</span><br><span class="line">else: &lt;codes of else&gt;</span><br><span class="line">%EOCF: ...</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;注意 ifTrue 和 else 的语句都要新建一层符号表。这里的 else label 要用 <code>elseCnt</code> 计数器来生成唯一标号。具体代码翻译该逻辑即可，不赘述。</p><h3 id="ForStmt"><a href="#ForStmt" class="headerlink" title="ForStmt"></a>ForStmt</h3><p>&emsp;&emsp;For 语句共 4 个部分：初始化语句 <code>init</code>、循环条件 <code>condition</code>、每次循环结束后执行的操作 <code>afterLoop</code>、循环体 <code>loop</code>。生成规则为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;codes of init&gt;</span><br><span class="line">&lt;codes of condition&gt;</span><br><span class="line">loop: ifFalse &lt;condition&gt; goto %EOCF</span><br><span class="line">&lt;codes of loop&gt;</span><br><span class="line">&lt;codes of afterLoop&gt;</span><br><span class="line">goto loop</span><br><span class="line">%EOCF: ...</span><br></pre></td></tr></table></figure></p><h3 id="Expression"><a href="#Expression" class="headerlink" title="Expression"></a>Expression</h3><p>&emsp;&emsp;每个 Expression 类要得到它的代码、返回类型、存放结果的 label。</p><ul><li>若为二元算术运算，则先生成左右两个子 Expression 的代码，然后两个返回值取类型优先级较高的作为最终结果类型，接着对两边进行强制类型转换，最后进行左右两个返回值的运算；</li><li>若为二元逻辑运算，则同上，但最后结果类型是 <code>BOOL</code></li><li>若为一元运算，则先生成子 Expression 的代码，然后进行运算；</li><li>若为立即数，则结果直接赋为该立即数；</li><li>若为变量，则从符号表中寻找该变量的 label 作为结果 label；</li><li>若为函数调用，则先生成实参的 Expression 的代码（并检查是否与形参匹配），接着用 <code>param</code> 语句传递参数，然后调用函数，最后取出返回值放到一个寄存器。</li></ul><p>&emsp;&emsp;这里是把布尔表达式和算数表达式等同对待了，但实际编译器是区别对待的，比如 or 运算，前件成立了是不判断后件的。本来这只是个代码优化，但它已经形成一种编程规范了，如果前件成立仍然判断后件会导致很多程序出错的。</p><p>&emsp;&emsp;至此，三地址码的生成就基本说完了。</p><h2 id="后续内容"><a href="#后续内容" class="headerlink" title="后续内容"></a>后续内容</h2><p>&emsp;&emsp;做一做前端交互，用 <code>-o</code> 选项把代码输出到指定文件啥的，改一下上次的代码不要因为存在语法错误就把整棵树析构了，使其能够同时检查语法错误和语义错误，最好再按行号排个序输出。<br>&emsp;&emsp;我现在的语言定义里还有很多东西没做，例如数组、指针、break、continue 之类的，因此这个语言还不是很完备。<br>&emsp;&emsp;再后续，就是代码优化了，平台无关代码优化的部分龙书讲了很多，都挺有趣的。<br>&emsp;&emsp;<del>但是学期结束了哈哈哈哈哈哈哈哈哈哈</del></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;&lt;del&gt;咕得有点久了&lt;/del&gt;&lt;br&gt;&amp;emsp;&amp;emsp;这是编译原理大作业的第二步：进行语义分析，生成三地址码。&lt;br&gt;</summary>
    
    
    
    <category term="project" scheme="http://kqp.world/categories/project/"/>
    
    
    <category term="编译器" scheme="http://kqp.world/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>【2021 Multi-University 2 J】I love permutation 题解</title>
    <link href="http://kqp.world/%E3%80%902021%20Multi-University%202%20J%E3%80%91I%20love%20permutation%20%E9%A2%98%E8%A7%A3/"/>
    <id>http://kqp.world/%E3%80%902021%20Multi-University%202%20J%E3%80%91I%20love%20permutation%20%E9%A2%98%E8%A7%A3/</id>
    <published>2021-07-25T02:32:45.000Z</published>
    <updated>2022-01-26T09:46:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>&emsp;&emsp;给定一个 $a$ 和一个奇质数 $p$（$1 \le a&lt;p$），令 $b_x=ax\bmod p,\ x=1,2,\cdots,p-1$，则 $b$ 序列形成一个 $1$ 到 $p-1$ 的排列，求这个排列的逆序对数量 $\bmod 2$。</p><p>&emsp;&emsp;$p \le 10^{18}$<br>&emsp;&emsp;多测，$T \le 10^5$<br>&emsp;&emsp;1s</p><span id="more"></span><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>&emsp;&emsp;排列 $b_1,\cdots,b_n$ 的逆序对数量的奇偶性用这个式子表示，奇数就得到 $-1$，偶数就得到 $1$：</p><script type="math/tex; mode=display">sign=\frac{\prod_{1 \le j < i \le n}b_i-b_j}{\prod_{1\le j < i \le n}i-j}</script><p>&emsp;&emsp;这是因为，分子的 $(b_j,b_i)$ 如果是正序对，那么会跟分母的 $b_i-b_j$ 约掉；如果是逆序对，那么跟分母约掉之后还会多出一个 $-1$。</p><p>&emsp;&emsp;式子代入这题：</p><script type="math/tex; mode=display">sign = \frac{\prod_{1 \le j < i <p}b_i-b_j}{\prod_{1\le j < i <p}i-j} \equiv \frac{\prod_{1 \le j < i <p}ai-aj}{\prod_{1\le j < i <p}i-j}\equiv a^{\frac{(p-1)(p-2)}{2}}\equiv \left(a^{\frac{p-1}{2}}\right)^{-1} \pmod p</script><p>&emsp;&emsp;所以就只需判断 $a^{\frac{p-1}{2}}$ 是 $1$ 还是 $-1$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line">LL <span class="title function_">mul</span><span class="params">(LL a,LL b,LL n)</span> &#123;<span class="keyword">return</span>(a*b-(LL)(a/(<span class="type">long</span> <span class="type">double</span>)n*b+<span class="number">1e-3</span>)*n+n)%n;&#125;</span><br><span class="line"></span><br><span class="line">LL <span class="title function_">Pow</span><span class="params">(LL x,LL y,LL mo)</span> &#123;</span><br><span class="line">LL re=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; y; y&gt;&gt;=<span class="number">1</span>, x=mul(x,x,mo)) <span class="keyword">if</span> (y&amp;<span class="number">1</span>) re=mul(re,x,mo);</span><br><span class="line"><span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line">LL a,p;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;a,&amp;p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(Pow(a,(p<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>,p)&amp;<span class="number">1</span>)^<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;给定一个 $a$ 和一个奇质数 $p$（$1 \le a&amp;lt;p$），令 $b_x=ax\bmod p,\ x=1,2,\cdots,p-1$，则 $b$ 序列形成一个 $1$ 到 $p-1$ 的排列，求这个排列的逆序对数量 $\bmod 2$。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;$p \le 10^{18}$&lt;br&gt;&amp;emsp;&amp;emsp;多测，$T \le 10^5$&lt;br&gt;&amp;emsp;&amp;emsp;1s&lt;/p&gt;</summary>
    
    
    
    <category term="OI/ACM" scheme="http://kqp.world/categories/OI-ACM/"/>
    
    
    <category term="算法_数学" scheme="http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【长更】杂写</title>
    <link href="http://kqp.world/%E3%80%90%E9%95%BF%E6%9B%B4%E3%80%91%E6%9D%82%E5%86%99/"/>
    <id>http://kqp.world/%E3%80%90%E9%95%BF%E6%9B%B4%E3%80%91%E6%9D%82%E5%86%99/</id>
    <published>2021-07-21T14:10:05.000Z</published>
    <updated>2022-05-28T15:19:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>$\ \ $</p><span id="more"></span><h3 id="2021-7-18"><a href="#2021-7-18" class="headerlink" title="2021.7.18"></a>2021.7.18</h3><p>只要每天跑五公里<br>我就可以健步如飞<br>穿过农讲所 省实 南越王宫 骑楼<br>还有步行街<br>半路碰见唐可可<br>她也在跑步<br>她累趴下了<br>香音在支持她</p><p>虽然不知道步行街里还有佛寺<br>不过阿梓喵还在动星<br>我仍然想去上野公园<br>uchi，emi，还有大佛<br>其实大家都在<br>燃火人没有完全燃尽而是保护了大家<br>只是我一个人在吃萨莉亚</p><h3 id="2021-7-19"><a href="#2021-7-19" class="headerlink" title="2021.7.19"></a>2021.7.19</h3><p>追寻梦想的人<br>一批一批地来了<br>风作勇气 湛蓝的勇气<br>我也借一点罢<br>让歌声简单些<br>仿佛看到每日开动的细胞之城<br>抱起血小板<br>生命初生之时 一定无比欣喜 满怀笑意</p><p>雪菜偷偷笑着焦急挖星石的小朋友<br>爱丽丝拉着小忍奔向田野<br>麦秸帽盖着金盏花<br>孩子们在树林里追跑<br>硕大的鲸鱼明年就要游回来了<br>在一天的阳光完全收敛以后<br>我像佛陀一样死去</p><h3 id="2021-7-19-1"><a href="#2021-7-19-1" class="headerlink" title="2021.7.19"></a>2021.7.19</h3><p>楼宇繁灯间自有摇滚<br>却也是山河中生 山河而归<br>也许我想去的只是无名小溪<br>谁不想得到那纯洁无瑕的<br>弯弯的月牙呢<br>谁又能得到呢</p><h3 id="2021-8-1"><a href="#2021-8-1" class="headerlink" title="2021.8.1"></a>2021.8.1</h3><p>过去 我欣赏雨日的朦胧<br>而今 压抑的黑云却要按住我的呼吸<br>惨白的风雨要抹去矗立的高楼<br>是谁 把这厌雨喜晴传染给了我</p><p>过去 我搏击沉重的任务<br>而今 微小的压力就要打碎我的身体<br>望不尽的辛劳要盖过苦中作乐<br>是谁 教我贪上了只需玩耍的假期</p><p>过去 我享受一人的孤独<br>而今 空荡的周围似要吞掉我的灵魂<br>满街满天的欢声笑语也不告诉我我是过客<br>是谁 让已经成长的我重新变回小孩</p><p>原来 我也会在雨天悲伤<br>原来 我也倾向躲避压力<br>原来 我也喜欢跟人说话<br>纵使生活会让我重新投入它<br>也不免在回头时发现<br>我变成了你<br>你变成了我想象中的你</p><h3 id="2021-10-1"><a href="#2021-10-1" class="headerlink" title="2021.10.1"></a>2021.10.1</h3><p>&emsp;&emsp;这两天所思有点多，意识流一下。<br>&emsp;&emsp;昨晚给gyg发了一个恭喜役满解放，然后就聊开了，很大一部分是她在讲她如何地焦虑，又如何在焦虑中找到一个好的心态。她节奏太紧了，以至于我好几次想插话都插不上。<br>&emsp;&emsp;不得不说跟gyg聊天真的有一个神奇的功效，就是会让我变得想要沉下心学习，我羡慕她一直保持着高中时的那种学习状态，所以聊完之后也会让我感染一点这种状态，就会变得想要学习。<br>&emsp;&emsp;但这一天晚上还有新的收获。她说她成绩不太能保研，师妹离开也令她消沉，最后一个人去了教室看书。我想起这个情景对我很熟悉，好像我高中的时候也很喜欢到一个人的地方去学习，这时忽然就闪过一个词：“一无所有”。我好像忽然又找到了曾经努力的动机——正是因为一无所有，所以才得以什么也不用顾虑地努力。高中时，没有协议，竞赛最终也没有带来成果，文化课成绩掉得厉害，没有十分亲密的朋友，没有发生爱情，对 LL 的认识非常浅并没有深度厨的概念也没有条件深度厨。正如同之前安慰学弟，他问怎样摆脱省选考差了的郁闷，我说回去考个文化课期中考，发现更差，你的郁闷就转移了(x)。所以，只有失败了，失去了，想要努力改变的心情才会变得无比坚定。高中不停地失败，真正地一无所有，所以不但沉着地学习，而且沉着得可怕，沉着得跟现在不是同一个人。<br>&emsp;&emsp;“正是因为一无所有，所以才得以不用顾虑地努力。”这句话很熟悉，LL 里这句话再多不过了，再看来，其实 LL 也一直是在讲这样的故事，缪自然不用说，水第一次参加东京的比赛不也是零蛋，虹的开局完全就是缪的开局。有趣的是，改变了一无所有的局面之后呢，也就是这句话的反面，却都是轻描淡写的，不是功成名就解散引退，就是废校了，当然还有刚刚兴盛起来的。<br>&emsp;&emsp;突然发现她就很像是高中的我。唯一不同的可能就是，她等的人，还有三年就可以等到了，而我等的人，等了五年，最终无果。<br>&emsp;&emsp;本来计划好的 10 月 1 号这天随大流放假，先找一个野生 lovelive fes 资源补掉，然后补掉感谢祭表演赛、liella op 发售 live 等“稍后再看”，最后剩余的时间补 clannad。但是因为临时受到感染，想要找回一点感觉。看一下现在的我，其实也还是一无所有——竞赛题不会做，实验室师兄的任务搞不出来，想做 complexity 但自己还是 newbie，看上了美帝的老师也没去套瓷。于是又有了一无所有的感觉，可以开始竞争了。<br>&emsp;&emsp;只不过到了下午还是重新审视了一下计划，毕竟国庆假是仅有的全天有空的机会了，过了之后下一个假期就是元旦了，像 live 这种东西要补就得挑全天有空的机会补。思想斗争了很久最后决定还是执行娱乐版计划。<br>&emsp;&emsp;然后把 fes 和积攒的“稍后再看”补了，主要是 fes。感动自然不用说，因为学会了一点日语，歌词也能听懂七七八八了，于是现在对于歌词本身有了更多的感触。LL 的歌曲除去情歌，大抵就是这么些主题：突然找到梦想了我悸动了、不要害怕不要犹豫干就完了、好想去到你的身边、给自己好吃好喝的好快乐。最对我有感触的大概就是“干就完了”这一类的主题，印象最深的是花丸两首 solo，都是对明天充满了期待，不要犹豫直接尝试，我被这两首歌激励了无数次，唯一失败的就是套美帝（这还是有太多别的要考虑了）。<br>&emsp;&emsp;然而悸动多了之后，心态似乎又变了。说不上来的感觉就是，它跟“一无所有”的心态总是有区别，或许是后者天生带有一丝消极，而前者一定是积极的。我尝试哲学思考，但并不能找到这两种心态的融合点。这令我在 live 被某几句歌词触发思考之后，回过神来发现歌都唱完了。<br>&emsp;&emsp;所以到头来依然是一个矛盾。不知“一无所有”的心态能保持多久，只能尝试在接下来的工作日里，翻看与 gyg 的聊天记录，重新感受。也不知道该怎么把这两年所思的心态融合起来，我并不希望每隔一段时间就提出一个哲学概念。<br>&emsp;&emsp;矛盾的也不仅是心态，还有规划，明天究竟要抓住一无所有的心态竞争，还是抓住全天有空的机会补番，还是抓住全天有空的机会来一次追寻内心的散步。</p><h3 id="2022-3-14"><a href="#2022-3-14" class="headerlink" title="2022.3.14"></a>2022.3.14</h3><p>&emsp;&emsp;未来也变得十分奇怪。<br>&emsp;&emsp;complexity 这条路是我自己选的。选的理由其中一条，我想要证明，sysu 也是有人能做高深的理论研究的。<br>&emsp;&emsp;我觉得我以前不是那种会对未来产生恐惧的人，不考虑会不会失败，也是干就完了的。第一次产生了对未来、对失败的恐惧，大概是做申请美国学校的计划的时候，让我对我曾经的决心、以及我到底喜欢怎样的生活，感到很迷惑，我看到了与以往所有坚定信念都不同的想法，倒不如说，让我分不清到底哪个才是心底的想法。<br>&emsp;&emsp;做 complexity 也是，一次次看见自己的对手都是些什么人，是学军那帮 ioi 冠军，是一帮 noi 知名人物，姚班图班 ACM 班求班大佬，也会很破防。这时候，也大抵是偶尔的跟人聊天恢复信心，以及听一些歌曲，从歌词中突然振奋。例如花丸的 solo，Aqours 许多歌，群青，这一类。</p><blockquote><p>好きなものを好きだと言う<br>怖くて仕方ないけど<br>本当の自分<br>出会えた気がしたんだ<br>——《群青》</p><p>ランラランわかった<br>ランラランわかった<br>まずはやっちゃうね<br>勢いってきっと大事だって思うから<br>ときめいた気持ちが消えないうちに<br>——《あこがれランララン》</p></blockquote><p>&emsp;&emsp;于是我的未来好像就是，选了个大目标，然后靠听歌走了下去。回过头来的时候，就会觉得很不靠谱。</p><h3 id="2022-4-9"><a href="#2022-4-9" class="headerlink" title="2022.4.9"></a>2022.4.9</h3><p>&emsp;&emsp;看了小百合对「青空をまってる」歌词的解释，本来想写一小篇感想，结果越写越多，涌现出很多题材，决定开个<a href="/%E5%81%B6%E5%83%8F%E4%BD%9C%E5%93%81%E8%A1%8D%E7%94%9F%E7%9A%84%E7%BE%8E%E5%AD%A6%E5%93%B2%E5%AD%A6%20open%20problems/" title="合集">合集</a>。</p><h3 id="2022-4-28"><a href="#2022-4-28" class="headerlink" title="2022.4.28"></a>2022.4.28</h3><p>&emsp;&emsp;惊闻 Liella 加了 4 个人。<br>&emsp;&emsp;然后也跟朋友们聊了很久，围观了贴吧、b 站的各路吐槽。<br>&emsp;&emsp;其实加人不会影响羁绊的发展，旧的羁绊也不会消失，按动画剧情，缪最初还是果海鸟三人呢，水最初还是千曜梨三人呢，还不是加成 9 人的，虹这 12 人也说明了旧的记忆和新的路程可以共存。只是官方的“9人の少女達の物語”“初5人の物語”这样的宣传和建设是越来越没有公信力了，这也是粉丝们对 LL 这个企划的信仰的瓦解的一小步，以后会有更多精神内核崩塌吗？不知道，但危机感有了。<br>&emsp;&emsp;我也比较庆幸，经过大三大四这么多事情的冲击，我逐渐懂得“人不能把全部信仰建立在一个商业构建的故事上”这个道理了，把 LL 作为人生最多一半的信仰即可，这样既可以把 LL 有益的精神内核结合进来，也可以避免在企划发生骚操作时崩溃。</p><p>&emsp;&emsp;但是无论如何，这毕竟是我最喜欢的企划，我有认真参与的企划。我真正感到害怕的是，看着 LL 从“大家一起实现梦想”变成“梦想的流水线工厂”，看着它变成 LL48，快速更替，缺乏沉淀；看着它毫无初始过程地加塞，直接就上 fmt，撞水东蛋，心浮气躁；看着它打人海战术，现在四代六团 43 人了，秋天还要加皮套人，“台下早已座无虚席，台上比台下还挤。”<br>&emsp;&emsp;很难说这样还能用心经营好每一个人。live 档期混乱甚至撞车，有人被埋没了近两年，有人歌唱还没练好赶鸭子上架开巡演出专辑，动画也急着做，剧情也急。</p><p>&emsp;&emsp;从前的日子过得很慢，车马邮件都慢，一年看一两场live，一个月看一场生放。偶尔来个“九周年放送黄金周”，也不过是一周有三天生放而已。现在是连 live 都能每周两演了，人对这些的态度能不轻浮吗？正是因为每一次节目都来之不易，我们才能赋予每一次节目重要的意义，每一次都抱以绝佳的投入，事后慢慢回味，充分挖掘各种细节，而不是快餐似的娱乐享受，搞完今天还有明天，看完这周还有下周。人也被娱乐事业绑架，work-life-balance 被打破，那就真应了那个表情包了。</p><h3 id="2022-5-28"><a href="#2022-5-28" class="headerlink" title="2022.5.28"></a>2022.5.28</h3><p>&emsp;&emsp;“现在加入，还来得及吗？”<br>&emsp;&emsp;“来得及哦！欢迎加入学园偶像同好会！”</p><p>&emsp;&emsp;也好想有一个声音对我说：“现在加入，还来得及哦！离你希望的开学前交出一份像样的研究，还有三个月。现在上车古典研究方向，来得及哦！”<br>&emsp;&emsp;大概就是有点焦虑，虽然今天又看到一个音乐学院的 up 主的视频，反驳“好的旋律已经被开发完了”。</p><p>&emsp;&emsp;现在是一看外国学校就会严重焦虑和后悔，一看娱乐作品就会疯狂思考哲学，一碰学术就不专心（x<br>&emsp;&emsp;虽然很感谢充裕的时间让我可以对一些新奇的概念胡思乱想，但是就是写完毕设到现在两个月颓得很进步微乎其微。昨天参与保研宣讲浏览了下 IIIS 的主页看到一堆 STOC 收录，就很“无边落木萧萧下，不尽长江滚滚来”。庆幸的是现在看 abstract 能看懂他们在干什么了。<br>&emsp;&emsp;希望我配得上端午的旅游吧。。。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;$\ \ $&lt;/p&gt;</summary>
    
    
    
    <category term="杂写" scheme="http://kqp.world/categories/%E6%9D%82%E5%86%99/"/>
    
    
  </entry>
  
  <entry>
    <title>【AtCoder Regular 119D】Grid Repainting 3 题解</title>
    <link href="http://kqp.world/%E3%80%90AtCoder%20Regular%20119D%E3%80%91Grid%20Repainting%203%20%E9%A2%98%E8%A7%A3/"/>
    <id>http://kqp.world/%E3%80%90AtCoder%20Regular%20119D%E3%80%91Grid%20Repainting%203%20%E9%A2%98%E8%A7%A3/</id>
    <published>2021-05-27T09:40:04.000Z</published>
    <updated>2022-01-26T09:46:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>&emsp;&emsp;给定一个 $H\times W$ 的矩阵，每个格子要么是红色要么是蓝色。每次可以选择一个红色格子，然后把这一列或者这一行染白。问最多能染白多少格子，并输出一种方案。</p><p>&emsp;&emsp;$H,W \le 2500$<br>&emsp;&emsp;2s</p><span id="more"></span><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>&emsp;&emsp;其实思路十分自然 <del>但你就是想不出来哈哈哈哈</del></p><p>&emsp;&emsp;可以想到经典的二分图模型，左边一排点表示行，右边一排点表示列。每次操作选择一个度数大于 $1$ 的点，然后把这个点的连边全部删掉。假设删了 $x$ 个左边点和 $y$ 个右边点，那么最终收益是 $xW+yH-xy$。<br>&emsp;&emsp;显然删的点越多越好。</p><p>&emsp;&emsp;考虑二分图连成一棵树。这棵树不可能全部删完，但是也最多只会留下一个点（以它为根，每次删一个叶子）。所以要么留一个左边点，要么留一个右边点。</p><p>&emsp;&emsp;考虑森林（假设不包含单点的树），设有 $k$ 棵树，$z$ 棵树选择留左边点，那么最终收益是</p><script type="math/tex; mode=display">(X-z)W+(Y-(k-z))H-(X-z)(Y-(k-z))</script><p>&emsp;&emsp;其中 $X=\sum_{i=1}^k x_i,\ Y=\sum_{i=1}^k y_i$。<br>&emsp;&emsp;发现这是关于 $z$ 的开口向上的二次函数，因此最优值只在两端取，即要么都保留左边点，要么都保留右边点。</p><p>&emsp;&emsp;最后考虑图。发现图等价于它的生成树。（因为图也不可能完全删完，但也最多只会留下一个点）<br>&emsp;&emsp;于是这题最后就是个并查集+生成树。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pr;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">5005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; e[maxn];</span><br><span class="line"></span><br><span class="line">pr operator + (<span class="type">const</span> pr &amp;a,<span class="type">const</span> pr &amp;b) &#123;<span class="keyword">return</span> <span class="built_in">make_pair</span>(a.first+b.first,a.second+b.second);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ReadChar</span><span class="params">(<span class="type">char</span> &amp;ch)</span> &#123;</span><br><span class="line">ch=getchar();</span><br><span class="line"><span class="keyword">while</span> (ch!=<span class="string">&#x27;R&#x27;</span> &amp;&amp; ch!=<span class="string">&#x27;B&#x27;</span>) ch=getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ga[maxn];</span><br><span class="line">pr num[maxn];</span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> x)</span> &#123;<span class="keyword">return</span> ga[x]==x ?x :ga[x]=get(ga[x]) ;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> &#123;</span><br><span class="line">e[x].push_back(y), e[y].push_back(x);</span><br><span class="line">x=get(x), y=get(y);</span><br><span class="line">ga[x]=y;</span><br><span class="line"><span class="keyword">if</span> (x!=y) num[y]=num[x]+num[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> &#123;<span class="keyword">return</span> x*m+y*n-x*y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;pr,<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> c)</span> &#123;</span><br><span class="line">vis[k]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> go:e[k]) <span class="keyword">if</span> (!vis[go]) &#123;</span><br><span class="line"><span class="keyword">if</span> (c==<span class="number">0</span>) ans.push_back(<span class="built_in">make_pair</span>(<span class="built_in">make_pair</span>(k,go-n),<span class="number">1</span>));</span><br><span class="line"><span class="keyword">else</span> ans.push_back(<span class="built_in">make_pair</span>(<span class="built_in">make_pair</span>(go,k-n),<span class="number">0</span>));</span><br><span class="line">dfs(go,c^<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line">fo(i,<span class="number">1</span>,n) ga[i]=i, num[i]=<span class="built_in">make_pair</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">fo(j,<span class="number">1</span>,m) ga[n+j]=n+j, num[n+j]=<span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">fo(i,<span class="number">1</span>,n)</span><br><span class="line">fo(j,<span class="number">1</span>,m) &#123;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line">ReadChar(ch);</span><br><span class="line"><span class="keyword">if</span> (ch==<span class="string">&#x27;R&#x27;</span>) merge(i,n+j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> compNum=<span class="number">0</span>;</span><br><span class="line">pr compRB;</span><br><span class="line">fo(i,<span class="number">1</span>,n+m) <span class="keyword">if</span> (get(i)==i &amp;&amp; num[i].first+num[i].second&gt;<span class="number">1</span>) &#123;</span><br><span class="line">compNum++;</span><br><span class="line">compRB=compRB+num[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (calc(compRB.first-compNum,compRB.second)&gt;calc(compRB.first,compRB.second-compNum)) &#123;</span><br><span class="line">fo(i,<span class="number">1</span>,n) <span class="keyword">if</span> (!vis[i]) dfs(i,<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fo(j,<span class="number">1</span>,m) <span class="keyword">if</span> (!vis[n+j]) dfs(n+j,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans.size());</span><br><span class="line">reverse(ans.begin(),ans.end());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p:ans) <span class="built_in">printf</span>(<span class="string">&quot;%c %d %d\n&quot;</span>,(p.second ?<span class="string">&#x27;Y&#x27;</span> :<span class="string">&#x27;X&#x27;</span> ),p.first.first,p.first.second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;给定一个 $H\times W$ 的矩阵，每个格子要么是红色要么是蓝色。每次可以选择一个红色格子，然后把这一列或者这一行染白。问最多能染白多少格子，并输出一种方案。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;$H,W \le 2500$&lt;br&gt;&amp;emsp;&amp;emsp;2s&lt;/p&gt;</summary>
    
    
    
    <category term="OI/ACM" scheme="http://kqp.world/categories/OI-ACM/"/>
    
    
    <category term="算法_并查集" scheme="http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>【AtCoder Regular 119E】Pancakes 题解</title>
    <link href="http://kqp.world/%E3%80%90AtCoder%20Regular%20119E%E3%80%91Pancakes%20%E9%A2%98%E8%A7%A3/"/>
    <id>http://kqp.world/%E3%80%90AtCoder%20Regular%20119E%E3%80%91Pancakes%20%E9%A2%98%E8%A7%A3/</id>
    <published>2021-05-19T12:44:21.000Z</published>
    <updated>2022-01-26T09:46:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>&emsp;&emsp;给出一个序列 $a_1,\cdots,a_n$，你可以选择一段区间 $[l,r]$ 然后翻转 $a_l,\cdots,a_r$，使得 $\sum_{i=1}^{n-1} |a_i-a_{i+1}|$ 最小。</p><p>&emsp;&emsp;$n \le 3\times 10^5,\ 1 \le a_i \le 10^9$<br>&emsp;&emsp;2s</p><span id="more"></span><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>&emsp;&emsp;首先翻转一段区间只有端点处会产生影响，影响是 $-|a_{l-1}-a_l|-|a_r-a_{r+1}|+|a_{l-1}-a_r|+|a_l-a_{r+1}|$。</p><p>&emsp;&emsp;于是反手就是一个拆开绝对值+四个区域二维偏序。<br>&emsp;&emsp;光荣 TLE</p><script type="math/tex; mode=display">\\</script><p>&emsp;&emsp;于是需要观察出一些额外的性质。<br>&emsp;&emsp;就是如果 $a_{l-1} \le a_l$ 且 $a_r \ge a_{r+1}$，那么翻转 $[l,r]$ 必不会使答案更优。对称地，若 $a_{l-1} \ge a_l$ 且 $a_r \le a_{r+1}$，也不行。<br>&emsp;&emsp;通过讨论可证。<br>&emsp;&emsp;然后如果 $a_{l-1} \le a_l$ 且 $a_r \le a_{r+1}$，那么可以视为两个值域区间 $[a_{l-1},a_l],[a_r,a_{r+1}]$，于是翻转 $[l,r]$ 的收益就是这两个区间的交的长度的两倍。<br>&emsp;&emsp;$a_{l-1} \ge a_l$ 且 $a_r \ge a_{r+1}$ 同理。</p><p>&emsp;&emsp;所以现在问题转化成，给定若干个值域区间，求任意两个区间的交的最大长度。<br>&emsp;&emsp;简单的 $O(n \log n)$ 数据结构即可。<br>&emsp;&emsp;正着做一次再把序列反过来做一次。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,a,b) for(int i=a;i&gt;=b;i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pr;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">2139062143</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b[maxn],b0;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">discretize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(b,a,<span class="built_in">sizeof</span>(a));</span><br><span class="line"><span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">b0=<span class="built_in">unique</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+n)-b<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[i]=<span class="built_in">lower_bound</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+b0,a[i])-b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tr[<span class="number">4</span>*maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tr_xg</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l==r) &#123;</span><br><span class="line">tr[k]=z;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> t=k&lt;&lt;<span class="number">1</span>, mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (x&lt;=mid) <span class="built_in">tr_xg</span>(t,l,mid,x,z); <span class="keyword">else</span> <span class="built_in">tr_xg</span>(t+<span class="number">1</span>,mid+<span class="number">1</span>,r,x,z);</span><br><span class="line">tr[k]=<span class="built_in">min</span>(tr[t],tr[t+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL ans,organs;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; Q[maxn];</span><br><span class="line"><span class="type">int</span> cnt[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,b0) Q[i].<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">2</span>,n) <span class="keyword">if</span> (a[i<span class="number">-1</span>]&lt;a[i]) &#123;</span><br><span class="line">cnt[a[i<span class="number">-1</span>]]++;</span><br><span class="line">Q[a[i]].<span class="built_in">push_back</span>(a[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(tr,<span class="number">127</span>,<span class="built_in">sizeof</span>(tr));</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,b0) &#123;</span><br><span class="line"><span class="keyword">if</span> (cnt[i]) <span class="built_in">tr_xg</span>(<span class="number">1</span>,<span class="number">1</span>,b0,i,i);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x:Q[i]) &#123;</span><br><span class="line"><span class="keyword">if</span> (--cnt[x]==<span class="number">0</span>) <span class="built_in">tr_xg</span>(<span class="number">1</span>,<span class="number">1</span>,b0,x,inf);</span><br><span class="line"><span class="type">int</span> lp=<span class="built_in">max</span>(tr[<span class="number">1</span>],x);</span><br><span class="line"><span class="keyword">if</span> (lp&lt;=i) ans=<span class="built_in">min</span>(ans,organs<span class="number">-2ll</span>*(b[i]-b[lp]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">2</span>,n) ans+=<span class="built_in">abs</span>(a[i]-a[i<span class="number">-1</span>]);</span><br><span class="line">organs=ans;</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">2</span>,n<span class="number">-1</span>) ans=<span class="built_in">min</span>(ans,organs-<span class="built_in">abs</span>(a[i]-a[i+<span class="number">1</span>])+<span class="built_in">abs</span>(a[<span class="number">1</span>]-a[i+<span class="number">1</span>]));</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">2</span>,n<span class="number">-1</span>) ans=<span class="built_in">min</span>(ans,organs-<span class="built_in">abs</span>(a[i]-a[i<span class="number">-1</span>])+<span class="built_in">abs</span>(a[n]-a[i<span class="number">-1</span>]));</span><br><span class="line"></span><br><span class="line"><span class="built_in">discretize</span>();</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="built_in">reverse</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;给出一个序列 $a_1,\cdots,a_n$，你可以选择一段区间 $[l,r]$ 然后翻转 $a_l,\cdots,a_r$，使得 $\sum_{i=1}^{n-1} |a_i-a_{i+1}|$ 最小。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;$n \le 3\times 10^5,\ 1 \le a_i \le 10^9$&lt;br&gt;&amp;emsp;&amp;emsp;2s&lt;/p&gt;</summary>
    
    
    
    <category term="OI/ACM" scheme="http://kqp.world/categories/OI-ACM/"/>
    
    
    <category term="算法_偏序关系" scheme="http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB/"/>
    
  </entry>
  
</feed>
