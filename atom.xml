<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Four&#39;s</title>
  
  <subtitle>一鼓作气，三题暴力</subtitle>
  <link href="http://kqp.world/atom.xml" rel="self"/>
  
  <link href="http://kqp.world/"/>
  <updated>2022-11-01T03:25:49.666Z</updated>
  <id>http://kqp.world/</id>
  
  <author>
    <name>kqp</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Orthogonal Vectors Problem 相关</title>
    <link href="http://kqp.world/OV/"/>
    <id>http://kqp.world/OV/</id>
    <published>2022-10-27T08:01:11.000Z</published>
    <updated>2022-11-01T03:25:49.666Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Fine-Grained Complexity 四大基础问题中的一个。</p><span id="more"></span><p>&emsp;&emsp;这里推荐的资料是 <a href="https://people.csail.mit.edu/virgi/6.s078/">MIT 的一门课</a>的第 6、7 讲。</p><h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><p>&emsp;&emsp;Orthogonal Vectors Problem (OV)：<br>&emsp;&emsp;给定 $n$ 个 $d$ 维的 01 向量 $v_1,\cdots,v_n \in \{0,1\}^d$，问是否存在两个向量 $v_i, v_j$ 是正交的，即 $\langle v_i, v_j \rangle = 0$。</p><p>&emsp;&emsp;这个问题的暴力是 $O(n^2d)$ 的，枚举两个向量，然后每一维去验证。且在 $d$ 比较小的时候（$d \le 2\log n$ 时），可以用 $O(2^d)$ 的各种算法解决。<br>&emsp;&emsp;但是在 $d=\omega(\log n)$ 时，我们很难找到 $O(n^{2-\epsilon}d^c)$ 的算法，因此猜想它是 $n^2$-hard 的。事实上，它可以由 SAT 问题归约而来，因此 SAT 的困难性猜想 Strong Exponential Time Hypothesis (SETH) 可以推出 OV 问题的 $n^2$-hardness。</p><p>&emsp;&emsp;这个问题有许多变式：</p><ul><li>给定两个集合 $A,B$，每个集合有 $n$ 个 $d$ 维的 01 向量，问是否存在 $v_1 \in A, v_2 \in B$ 使得 $v_1,v_2$ 正交。（易证这个版本跟上述版本是等价的）</li><li>计数版本，求有多少对向量是正交的。</li><li>不再是 01 向量，而是某个域下的 $d$ 维向量。</li></ul><h2 id="比较好的解法"><a href="#比较好的解法" class="headerlink" title="比较好的解法"></a>比较好的解法</h2><p>&emsp;&emsp;该解法来自 [AWY15]，可以做到 $O(n^{2-1/O(\log (d/\log n))})$。思路是，给向量分组（每 $s$ 个一组，分为 $\frac ns$ 组），转化成“对于每一个组对 $(A,B)$，是否能在 $A$ 找一个向量，在 $B$ 找一个向量，使其正交”的子问题。每个组对的任务写成一个逻辑公式，并用一些 trick 变成比较好的多项式，然后使用矩阵乘法的 trick 让所有组对同时计算这个多项式。</p><p>&emsp;&emsp;先有几个 trick：</p><blockquote><p>Lemma1：如果要计算 $y_1 \lor y_2 \lor \cdots \lor y_m$，那么可以选择一个正整数 $t$，对于每个 $1 \le i \le t$，选择一个随机子集 $s_i \subseteq \{1,\cdots,m\}$，令 $Y_i = \bigoplus_{j \in s_i} y_j$，则只需计算 $Y_1 \lor \cdots \lor Y_t$ 即可。</p></blockquote><p>&emsp;&emsp;证明：<br>&emsp;&emsp;如果原式为假，则 $Y_1 \lor \cdots \lor Y_t$ 肯定为假。<br>&emsp;&emsp;如果原式为真，令 $s_{true} = \{y_i | y_i=true\}$，则每次生成随机子集 $s_i$ 时，在 $s_{true}$ 中选中奇数个元素的概率是 $\frac 12$，所以 $P[Y_1 \lor \cdots \lor Y_t=0]=\frac{1}{2^t}$。</p><blockquote><p>Lemma1.5：如果要计算 $y_1 \land y_2 \land \cdots \land y_m$，那么可以选择一个正整数 $t$，对于每个 $1 \le i \le t$，选择一个随机子集 $s_i \subseteq \{1,\cdots,m\}$，令 $Y_i = \lnot \left( \bigoplus_{j \in s_i} \lnot y_j \right)$，则只需计算 $Y_1 \land \cdots \land Y_t$ 即可。</p></blockquote><p>&emsp;&emsp;证明同理，如果原式为真，则 $Y_1 \land \cdots \land Y_t$ 肯定为真；如果原式为假，则 $Y_1 \land \cdots \land Y_t$ 只有 $\frac{1}{2^t}$ 的概率为真。</p><blockquote><p>Lemma2：有一个 $\mathbb F^2$（即模 $2$ 意义）下的多项式 $P(x_1,\cdots,x_d,y_1,\cdots,y_d)$，其展开后是 $m$ 个单项式的和。现有 $n$ 种 $x$ 变量的赋值 $a_1,\cdots,a_n \in \{0,1\}^d$，以及 $n$ 种 $y$ 变量的赋值 $b_1,\cdots,b_n \in \{0,1\}^d$，我们需要对每一对 $(a_i,b_j)$ 都求出 $P$ 的值。若 $m \le n^{0.1}$，这个时间只需要 $\tilde O(n^2)$。</p></blockquote><p>&emsp;&emsp;证明：令矩阵 $M$ 大小为 $n \times m$，$M_{ij}$ 表示第 $j$ 个单项让 $x$ 变量的取值为 $a_i$、$y$ 变量的取值全为 $1$ 时得到的值，同理令矩阵 $N$ 大小为 $m \times n$，$N_{ij}$ 表示第 $i$ 个单项让 $x$ 变量取值全为 $1$、$y$ 变量取值为 $b_j$ 时得到的值，则 $M\cdot N$ 就会得到每一对 $(a_i,b_j)$ 下 $P$ 的值。使用优秀的矩阵乘法技术，当 $m \le n^{0.1}$ 时，矩阵乘法的复杂度只需要 $\tilde O(n^2)$。</p><p>&emsp;&emsp;现在可以来做题了。<br>&emsp;&emsp;先给向量分组，每 $s$ 个一组，分成 $\frac ns$ 组。那么对于每一组，我们要求的东西可以写成一个逻辑表达式：</p><script type="math/tex; mode=display">\bigvee_{i,j \in [s]^2} \bigwedge_{k \in [d]} (\lnot v_{ik} \lor \lnot v_{jk})</script><p>&emsp;&emsp;我们希望把逻辑公式转化为 $\mathbb{F}^2$ 下的多项式，$\land$ 是乘法，$\oplus$ 是加法，$\lnot$ 是加 $1$，$\lor$ 用德摩根律转化为 $a \lor b = (1+a)(1+b)+1$。<br>&emsp;&emsp;对最外层的或使用德摩根律+Lemma1.5，参数 $t=2$：</p><script type="math/tex; mode=display">{\Large(} 1+\underbrace{(\bigwedge_{k \in [d]})+(\bigwedge_{k \in [d]})+\cdots+(\bigwedge_{k \in [d]})}_{O(s^2)\text{个}} {\Large)}{\Large(} 1+\underbrace{(\bigwedge_{k \in [d]})+(\bigwedge_{k \in [d]})+\cdots+(\bigwedge_{k \in [d]})}_{O(s^2)\text{个}} {\Large)}+1</script><p>&emsp;&emsp;对每个 $(\bigwedge_{k \in [d]})$，使用 Lemma1.5，参数 $t=3 \log s$：</p><script type="math/tex; mode=display">{\Large(} 1+\underbrace{(v_{ik}v_{jk})+(v_{ik}v_{jk})+\cdots +(v_{ik}v_{jk})}_{O(d)\text{个}} {\Large)}{\Large(} 1+()+()+\cdots+() {\Large)}\overbrace{\cdots}^{3 \log s\text{个}}{\Large(} 1+()+()+\cdots+() {\Large)}</script><p>&emsp;&emsp;这就是我们的多项式 $P$，共 $2sd$ 个变量。给定一个向量组对，通过这个多项式就可以算出这个组对是否有正交向量。By union bound，错误率不高于 $\frac 14+s^2\frac{1}{s^3} = \frac 14+\frac 1s$。<br>&emsp;&emsp;现在来算一下单项式数量 $m$。把每个 $(\bigwedge_{k \in [d]})$ 展开以后，看上去有 $(d+1)^{3 \log s}$ 个单项，但实际上，每个单项形如 $v_{ik_1}v_{jk_1}v_{ik_2}v_{jk_2}\cdots v_{ik_{3 \log s}}v_{jk_{3 \log s}}$，由于是在 $\mathbb F^2$ 下运算，重复的 $k$ 可以只保留一个，因此这样的单项的数量只有 $\binom{d+1}{3 \log s}$ 个。再把最外层的括号展开，就共有 $m=\left(s^2\binom{d+1}{3 \log s}\right)^2$ 个单项。<br>&emsp;&emsp;代入 $s=2^{\epsilon \log n / \log (d / \log n)}$，其中 $\epsilon$ 是足够小的常数，<del>经过巧妙且艰难的不等式放缩，</del>就可以得到：</p><ul><li>多项式 $P$ 对于单个组对的错误率不高于 $\frac 13$；</li><li>$m \le n^{0.1}$。</li></ul><p>&emsp;&emsp;因此就可以用 Lemma2 同时对 $(\frac ns)^2$ 个组对算出 $P$ 的值了，最终只要有一个组对返回 $1$ 那答案就是 $1$。由于现在每个组对的错误率是常数，那么就把整个过程重复 $O(\log n)$ 次（即随机产生多个 $P$），每个组对取众数。By Chernoff bound and union bound，错误率就变成 $\frac{1}{poly(n)}$ 了。</p><p>&emsp;&emsp;总结一下，算法流程是</p><ol><li>给向量分组，每 $s$ 个一组，共 $\frac ns$ 组；</li><li>随机生成多项式 $P$，并写成单项式的和的形式；（$O(m)$）</li><li>根据 $P$ 预处理矩阵 $M, N$（矩阵的大小是 $\frac ns \cdot m$ 的）；（$O(\frac ns \cdot m \cdot sd) = O(nmd)$）</li><li>计算 $M \cdot N$；（$\tilde O(\frac{n^2}{s^2})$）</li><li>重复 2-4，统计每个组对的答案众数。</li></ol><p>&emsp;&emsp;时间复杂度分析。瓶颈在于第 4 步，复杂度是 $\tilde O(\frac{n^2}{s^2})$，代入 $s$ 会得到 $\tilde O(n^{2-1/O(\log (d/\log n))})$。重复 2-4 的次数是 $O(\log n)$ 的，对 $\tilde O$ 无影响。<br>&emsp;&emsp;因此，如果 $d$ 等于常数倍的 $\log n$，那这个算法就是 subquadratic 的了。这也提醒我们在使用 OV 问题的困难性的时候，$d$ 不能太小，必须是 $d=\omega(\log n)$ 的。</p><p>&emsp;&emsp;甚至还可以在有解的时候快速求出方案。因为我们锁定了答案在哪个组对里，所以只需要 $O(s^2)$ 暴力就可以了。</p><h2 id="Average-Case-Hardness"><a href="#Average-Case-Hardness" class="headerlink" title="Average-Case Hardness"></a>Average-Case Hardness</h2><p>&emsp;&emsp;慢慢填坑。OV 到底是不是 average-case hard 的，好像有几派在打架？</p><h2 id="Completeness"><a href="#Completeness" class="headerlink" title="Completeness"></a>Completeness</h2><p>&emsp;&emsp;慢慢填坑。OV 似乎在 First-Oder Problems 中是完全的。具有完全性的问题有很大的价值，比如设计协议，给一个完全问题搞了某种协议以后，这一类问题就都拥有这种协议了。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>[AWY15] Amir Abboud, Ryan Williams, and Huacheng Yu. More Applications of the Polynomial Method to Algorithm Design. In SODA 2015.</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;Fine-Grained Complexity 四大基础问题中的一个。&lt;/p&gt;</summary>
    
    
    
    <category term="TCS" scheme="http://kqp.world/categories/TCS/"/>
    
    
    <category term="complexity" scheme="http://kqp.world/tags/complexity/"/>
    
  </entry>
  
  <entry>
    <title>零知识证明大整理</title>
    <link href="http://kqp.world/ZKP/"/>
    <id>http://kqp.world/ZKP/</id>
    <published>2022-09-14T03:30:10.000Z</published>
    <updated>2022-11-20T07:22:16.505Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;学的内容多了，就可以搞个总结整理了。<br>&emsp;&emsp;慢慢填坑。</p><span id="more"></span><p>&emsp;&emsp;推荐一个 <a href="https://cyber.biu.ac.il/event/the-9th-biu-winter-school-on-cryptography/">2019 年的 camp</a> 可以学到多数 ZKP 经典内容。<br>&emsp;&emsp;其他参考资料：Sanjeev Arora 的经典教材《Computational Complexity: A Modern Approach》，以及各类密码学教材。</p><h2 id="初始-Fundamental"><a href="#初始-Fundamental" class="headerlink" title="初始 Fundamental"></a>初始 Fundamental</h2><p>&emsp;&emsp;Princeton 的这个 <a href="https://www.cs.princeton.edu/courses/archive/fall07/cos433/lec15.pdf">lec15</a> 和 <a href="https://www.cs.princeton.edu/courses/archive/fall07/cos433/lec16.pdf">lec16</a> 是非常好入门教程。</p><p>&emsp;&emsp;怎么说明一个输入 $x$ 属于一个语言 $L$ 呢？通常来说，就是写出来一个数学证明（通常就是给出 $x$ 的 witness），谁想知道谁就来看。但缺点就是把 witness 公开出来了，有没有不公开的方法呢？比如有一个门禁，门禁里有一个大整数 $n$，我的“钥匙”就是 $n$ 的质因数分解。如果我直接显式地输入 $n$ 的质因数分解，那就会被人偷看偷听了，有没有方法使得我既能让门禁相信我知道 $n$ 的质因数分解，又能不说出任何关于 $n$ 质因数分解的信息呢？</p><p>&emsp;&emsp;零知识证明(Zero-Knowledge Proof, ZKP)是一个交互协议，交互双方为 Prover、Verifier，其中 Verifier 计算能力有限（通常假设它只有多项式时间）。它们会得到一个输入 $x$，Prover 想让 Verifier 相信 $x$ 属于某个语言 $L$。这个交互协议满足如下条件：</p><ul><li>Completeness：如果 $x \in L$，那么 Verifier 以高概率接受；</li><li>Soundness：如果 $x \not \in L$，那么 Verifier 以高概率拒绝；</li><li>Zero-Knowledge：Verifier 经过交互以后没有得到额外的信息，即，整个交互过程可以被 Verifier 自己模拟出来。更确切地说，存在一个算法 Simulator，它可以模拟出一个 Verifier 的 view，该 view 与真实交互中 Verifier 的 view 是不可区分的。（不可区分可以是完美/统计/计算不可区分）</li></ul><p>&emsp;&emsp;给非 CS 背景的人科普时可以举的通俗易懂的例子：如下图，Alice 想要给 Bob 证明她拥有这个门的钥匙，但不能直接把钥匙给她看。方法是，Bob 站在顶上通道处，每次随机喊“左”或“右”，Alice 就必须从下方走到对应位置。过程重复若干次，如果 Alice 总是能成功，Bob 就能确信 Alice 拥有钥匙了。</p><p><img src="/images/zkp_simple.png" alt=""></p><p>&emsp;&emsp;给 CS 背景的人科普时可以举的例子：图同构。有两幅图 $A$ 和 $B$，Prover 希望 Verifier 相信 $A$ 和 $B$ 同构。每次操作 Prover 给 Verifier 发送一个新图 $C$（由 $A$ 点标号随机打乱而来），声称 $A,B,C$ 同构，Verifier 要么询问 $A$ 和 $C$ 之间的点标号映射，要么询问 $B$ 和 $C$ 的点标号映射。操作重复若干次，Verifier 接受当且仅当每次 Prover 都能正确回答问题。<br>&emsp;&emsp;如果 $A,B$ 真的同构，那么 Prover 总是能正确回答。如果 $A$ 和 $B$ 不同构，那么 Prover 每次最多只有 $\frac 12$ 的概率回答正确，重复若干次以后概率无限小。直观理解，Verifier 每次只是知道了 $A$ 或 $B$ 其中一幅图的点标号重排结果，从中并不能推断出更有用的信息。</p><p>&emsp;&emsp;想要细学的话需要了解的例子：二次剩余、3-Coloring、哈密顿回路。</p><h2 id="更多框架"><a href="#更多框架" class="headerlink" title="更多框架"></a>更多框架</h2><h3 id="随机自归约-Random-Self-Reducible-问题的ZKP"><a href="#随机自归约-Random-Self-Reducible-问题的ZKP" class="headerlink" title="随机自归约(Random Self-Reducible)问题的ZKP"></a>随机自归约(Random Self-Reducible)问题的ZKP</h3><p>&emsp;&emsp;如果你发现二次剩余、离散对数、图同构的 ZKP 都长得很像，那么[rsr-szk]这篇文章就可以告诉你，这不是巧合。它们都是 random self-reducible 的，于是可以设计出统一的 ZKP 框架，并且是 perfect ZKP 的：</p><ul><li>输入：$x$，诚实的 Prover 拥有其 witness $y$。</li><li>Prover 随机生成一个 $r \in \{0,1\}^*$，将 $(x,y)$ 用 $r$ 随机归约成 $(x’,y’)$，发送 $x’$。</li><li>Verifier 发送一个随机提问 $b \gets_R \{0,1\}$。</li><li>若 $b=0$，Prover 发送 $r$，Verifier 检验“$x$ 用 $r$ 归约成 $x’$”；若 $b=1$，Prover 发送 $y’$，Verifier 检验“$y’$ 是 $x’$ 的 witness”。</li></ul><p>&emsp;&emsp;例如，在二次剩余中，$x \equiv y^2 \pmod n, x’ \equiv x \cdot r^2 \pmod n, y’ \equiv yr \pmod n$；在离散对数中，$x \equiv g^y, x’ \equiv g^{y+r}, y’ \equiv y+r$。</p><p>&emsp;&emsp;其实不仅是 random self-reducible，只要能把 $A$ 问题随机归约到 $B$ 问题，就能对 $A$ 问题采用这个框架。</p><p>&emsp;&emsp;这个东西的一个很重要的意义在于，结合后续一系列推导（包括 $\mathsf{SZK \subseteq coAM}$、$\mathsf{NP\subseteq coAM} \Rightarrow \text{polynomial hierarchy collapses}$），可以得到 $\mathsf{NPC}$ 问题不能拥有 SZK，又或者拥有 SZK 的问题（比如 random self-reducible 的问题）不能是 $\mathsf{NPC}$。</p><h3 id="sum-Protocol"><a href="#sum-Protocol" class="headerlink" title="$\sum$-Protocol"></a>$\sum$-Protocol</h3><h2 id="带各种特性的零知识证明"><a href="#带各种特性的零知识证明" class="headerlink" title="带各种特性的零知识证明"></a>带各种特性的零知识证明</h2><h3 id="常数轮零知识证明-Constant-Round-Zero-Knowledge-Proof"><a href="#常数轮零知识证明-Constant-Round-Zero-Knowledge-Proof" class="headerlink" title="常数轮零知识证明 Constant-Round Zero-Knowledge Proof"></a>常数轮零知识证明 Constant-Round Zero-Knowledge Proof</h3><p>&emsp;&emsp;传统的 ZKP 是把一个协议串行执行很多次来降低 soundness，因此自然会想如果把它改成并行，就变成常数轮了。但简单的并行会使得 simulator 的时间复杂度爆炸。（例如很多 ZKP 是让 verifier 发送两种询问中的一种，simulator 原本只需要期望 $2$ 步猜对询问然后往下走，现在 $n$ 个询问并行，那么就变成期望 $2^n$ 步才能同时猜对然后往下走。）<br>&emsp;&emsp;[constant-round]的 idea 是：还是并行，但让 verifier 先把询问加密发送给 prover，再执行原协议，到该询问的时候让 verifier 解密。这样 simulator 就不用猜询问了，一直发垃圾等 verifier 自己解密了询问再时间倒流即可。具体来说（以哈密顿回路的 3 轮协议为例）：</p><ul><li>Verifier 将询问串用 computationally binding, perfectly hiding 的 commitment scheme 加密发送给 Prover。</li><li>Prover 发送原协议第一步的消息。</li><li>Verifier 解密询问串。</li><li>Prover 回答。</li></ul><p>细节分析很复杂，因为要考虑各种不遵守协议 halt 的情况，如果不明白某些步骤的意义，可以参考 《Tutorials on the Foundations of Cryptography》6.5.4 节的讲解。</p><p>&emsp;&emsp;[constant-round] 的缺点就是不遵守协议 halt 的情况太复杂，其中有一个分析就是由于 simulator 会倒车，导致 verifier 有至少两次解密询问，如果每次成功解密的概率不一样，就会使得 simulator 期望倒车次数爆炸。<br>&emsp;&emsp;[easy-constant-round] 这篇仍然是让 verifier 先发送询问（假设叫 $\sigma$），但是额外生成了 $\sigma_i^0,\sigma_i^1$ 使得 $\sigma_i^0 \oplus \sigma_i^1=\sigma$。它让 prover 解密 $\sigma_i^0,\sigma_i^1$ 中的其中一个，这对 prover 来说是没有用的，但是 simulator 可以在这里倒车获得询问，这样就没有“每次成功解密的概率不一样”的问题，因而期望倒车次数是常数。<br>&emsp;&emsp;由于发送询问的方式更复杂了，所以轮数变成了 7 轮，没有达到最优，但是分析简单了很多。</p><h3 id="非交互零知识证明-Non-Interactive-Zero-Knowledge-Proof"><a href="#非交互零知识证明-Non-Interactive-Zero-Knowledge-Proof" class="headerlink" title="非交互零知识证明 Non-Interactive Zero-Knowledge Proof"></a>非交互零知识证明 Non-Interactive Zero-Knowledge Proof</h3><p>&emsp;&emsp;把 ZKP 做成非交互的当然是一个美好的愿景了，这样可以大大提升 ZKP 的效率，从而提高实用性。</p><p>&emsp;&emsp;但如果就简单地只是让 Prover 发条消息给 Verifier，这是不可能的。</p><blockquote><p>Lemma: 如果问题 $L$ 存在一个 ZKP 只是让 Prover 发一条消息给 Verifier，那么 $L \in \mathsf{BPP}$。</p></blockquote><p>&emsp;&emsp;证明：对于输入 $x$，直接让 simulator 模拟一个 Prover 消息，用 Verifier 验证，这就得到了 $L$ 的概率多项式算法。</p><p>&emsp;&emsp;事实上，不只是一轮不行，参考 Lower Bound of ZKP，黑盒 simulator 的情况下三轮都不行。</p><p>&emsp;&emsp;因此要实现非交互，必须借助一些外部工具。一个可行的方法就是 Common Reference String (CRS)，从天上来了一个可信第三方，给出了一个符合特定分布的字符串，Prover 和 Verifier 都无条件相信这个字符串是符合特定分布的。这个信任，就可以用来实现非交互。<br>&emsp;&emsp;下表是使用 CRS 的一些经典方法的总结。</p><div class="table-container"><table><thead><tr><th>Paper</th><th>Problem</th><th>Extra Property</th><th>CRS represents</th><th>Assumption</th><th>Completeness</th><th>Soundness</th><th>ZK</th><th>len of CRS</th></tr></thead><tbody><tr><td>[NIZK origin-upd]</td><td>3-Coloring</td><td></td><td>2 numbers for each edge</td><td>hardness of Quadratic Residuosity</td><td>$1$</td><td>$0$</td><td>computational</td><td>$16k$</td></tr><tr><td>[NIZK]</td><td>Hamiltonian</td><td>-</td><td>a cycle</td><td>One-Way Permutation with hard-core predicate</td><td>$1$</td><td>$neg$</td><td>computational</td><td>$n^7k^2m$</td></tr><tr><td>[NIZK]</td><td>Hamiltonian</td><td>argument</td><td></td><td>One-Way Trapdoor Permutation</td><td></td><td></td><td></td><td></td></tr><tr><td>[NIZK]</td><td>$\mathsf{NPC}$</td><td>multiple provers</td><td>random $y$ and original CRS</td><td>Psseudorandom Generator (from $n$-bit to $2n$-bit)</td><td></td><td></td><td></td><td>$2n+\</td><td>CRS\</td><td>$</td></tr><tr><td>[NIZK by influence game]</td><td>3-SAT-5</td><td></td><td>wild strings and random strings</td><td>Hidden Bit Model</td><td>$1-neg$</td><td>$neg$</td><td>computational</td><td>$O(kn \log (n/\epsilon))$</td></tr><tr><td>[NIZK by com]</td><td>circuit SAT</td><td></td><td>commitment scheme</td><td>Homomorphic Commitment Scheme</td><td>$1$</td><td>$0$</td><td>computational</td><td>$O(1)$</td></tr><tr><td>[fgNIZK-nc1]</td><td>Linear Problems, circuit SAT</td><td></td><td>commitment scheme in matrix</td><td>$\mathsf{NC^1 \subsetneq \oplus L/poly}$</td><td>$1$</td><td>$0$</td><td>$\mathsf{NC^1}$ computational</td><td>$\lambda^2$</td></tr></tbody></table></div><p>&emsp;&emsp;另一种方法是 Fiat-Shamir Transform，即如果 verifier 发的消息全都是随机字符串，那么就用一个伪随机函数来代替掉它，伪随机函数的输入就是之前的所有消息。</p><h3 id="非黑盒零知识证明-Non-Black-Box-Zero-Knowledge-Proof"><a href="#非黑盒零知识证明-Non-Black-Box-Zero-Knowledge-Proof" class="headerlink" title="非黑盒零知识证明 Non-Black-Box Zero-Knowledge Proof"></a>非黑盒零知识证明 Non-Black-Box Zero-Knowledge Proof</h3><h2 id="理论相关"><a href="#理论相关" class="headerlink" title="理论相关"></a>理论相关</h2><h3 id="Lower-Bound-of-ZKP"><a href="#Lower-Bound-of-ZKP" class="headerlink" title="Lower Bound of ZKP"></a>Lower Bound of ZKP</h3><h3 id="ZKP-and-One-Way-Function"><a href="#ZKP-and-One-Way-Function" class="headerlink" title="ZKP and One-Way Function"></a>ZKP and One-Way Function</h3><p>&emsp;&emsp;[szk-owf] 及后续工作 [zkp-owf] 提出的思路，我猜是在考虑怎么用 simulator 产生的 view 来设计判定 $x \in L$ 的算法的时候，捣鼓出了这个玩意。<br>&emsp;&emsp;如果一个问题 $L$ 是属于 $\mathsf{SZK}$ 的，并且是 hard on average 的，那么就可以通过这个 SZK 构造出 one-way function。这个 one-way function 的输入是 SZK 里的 simulator 所需的 random tape，输出是 simulator 产生的 view of verifier。<br>&emsp;&emsp;证明大致是，假设这个函数不是 one-way 的，即输入 view 可以快速求出 random tape。那么用 simulator 充当 prover，与 verifier 交互（每得到一条 verifier 的消息就重新算 random tape，再用 simulator 计算出 prover 要发的消息），这样就得到了 $L$ 的快速判定算法，从而 $L$ 不是 hard on average。<br>&emsp;&emsp;为什么限定是 SZK 呢？因为 SZK 证明 correctness 的时候会方便很多。后续论文 [ZKP-OWF] 把这个思想拓展到一般 ZKP 上了。<br>&emsp;&emsp;为什么是 hard on average 呢？我认为这个条件是不准确的，它用反证法推翻的结论是“$L$ 没有高效的概率算法”，所以应该跟 [ZKP-OWF] 一样，是“不属于 $\mathsf{BPP}$”。</p><h3 id="mathsf-SZK-and-mathsf-coAM"><a href="#mathsf-SZK-and-mathsf-coAM" class="headerlink" title="$\mathsf{SZK}$ and $\mathsf{coAM}$"></a>$\mathsf{SZK}$ and $\mathsf{coAM}$</h3><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>[constant-round] Oded Goldreich, and Ariel Kahan. How to Construct Constant-Round Zero-Knowledge Proof Systems for NP. In Journal of Cryptography 1996.</li><li>[easy-constant-round] Alon Rosen. A Note on Constant-Round Zero-Knowledge Proofs for NP. In Theory of Cryptography 2004.</li><li>[fgNIZK-nc1] Yuyu Wang, and Jiaxin Pan. Non-Interactive Zero-Knowledge Proofs with Fine-Grained Security. In EUROCRYPT 2022.</li><li>[NIZK] Uriel Feige, Dror Lapidot, and Adi Shamir. Multiple noninteractive zero knowledge proofs under general assumptions. In SIAM Journal on computing 1999.</li><li>[NIZK by com] Jens Groth, Rafail Ostrovsky, and Amit Sahai. New techniques for noninteractive zero-knowledge. In Journal of the ACM 2012.</li><li>[NIZK by influence game] Joe Kilian, and Erez Petrank. An efficient noninteractive zero-knowledge proof system for NP with general assumptions. In Journal of Cryptology 1998.</li><li>[NIZK origin-upd] Kaoru Kurosawa, and Kenichi Takai. A comment on NIZK for 3 colorability. In ICCS/ISITA `92.</li><li>[rsr-szk] Martin Tompa, and Heather Woll. Random Self-Reducibility and Zero Knowledge Interactive Proofs of Possession of Information. In STOC 1987.</li><li>[szk-owf] Rafail Ostrovsky. One-Way Functions, Hard on Average Problems, and Statistical Zero-Knowledge Proofs. In CCC 1991.</li><li>[zkp-owf] Rafail Ostrovsky, and Avi Wigdersony. One-Way Functions are Essential for Non-Trivial Zero-Knowledge. In Israel Symposium on Theory and Computing Systems 1993.</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;学的内容多了，就可以搞个总结整理了。&lt;br&gt;&amp;emsp;&amp;emsp;慢慢填坑。&lt;/p&gt;</summary>
    
    
    
    <category term="TCS" scheme="http://kqp.world/categories/TCS/"/>
    
    
    <category term="ZKP" scheme="http://kqp.world/tags/ZKP/"/>
    
  </entry>
  
  <entry>
    <title>虹咲5th live</title>
    <link href="http://kqp.world/nijigaku_5th_live/"/>
    <id>http://kqp.world/nijigaku_5th_live/</id>
    <published>2022-09-10T13:43:58.000Z</published>
    <updated>2022-11-08T07:41:29.126Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;众所周知虹动画第 2 季制作组厨力拉满，呈现出了一部精彩绝伦、细节可赏、值得每周期待的作品。那么以虹动画第 2 季为主题的虹 5th live 会怎么样呢？</p><span id="more"></span><h3 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h3><p>&emsp;&emsp;来到 HK 之后的第一场 live。满心欢喜加了去年跨年的 HK 转播群，但发现没人组织。最后跟萤火虫 staff 桑连麦看。<br>&emsp;&emsp;本来打算用实验室里的卡拉 ok 音响加上 4k 屏来看的，结果下午老板还来查房。为了安全起见，还是溜回宿舍用笔记本看了。</p><p>&emsp;&emsp;live 开始前大约期待的几个亮点：一是光路企划，有好几个光路要还原，比如侑弹钢琴时的彩虹展开、璃奈 solo 时的璃奈板；二是第 2 季的各种新歌，op、ed、Eutopia、Stars We Chase、缭乱；三是侑又要上台了。</p><p>&emsp;&emsp;开场发现舞台很小，不会有庞大的走位了。<br>&emsp;&emsp;整场 live 节奏按照动画来走，op 开场，岚珠露一手给你们看看，然后一路直到 13 话那首歌，ed 结束正场。安可后是缭乱，小组曲 cw，接几首全员曲。一开始我们感觉节奏太快，时长太短，但是整场 live 下来也接近 3h，造成一开始有短的感觉原因有二：一是 mc 少，全场只有开头结尾两次 mc，歌曲数量数下来估计是不少的；二是安可的位置摆得很中间，换句话说安可后的内容十分多，而正场的内容就纯动画，不像别的团有插入各种特典曲、小组曲、liella 之歌什么的。<br>&emsp;&emsp;值得期待的歌曲基本都出来了。op 的衣服应该很热，披肩依然是毛茸茸的。菜宝打头阵，可惜麦克风有大问题，好几个词都漏了，后面的夜明珠更是漏了一整句。一开始“もっと熱く高く　光よりもはやく”用力很猛，气势非常够，甚至过头了。菜宝的声音仍然能听出中后期有明显的气息急促，所以体力还是有欠缺（与此同时你的舞蹈还是最激烈之一的），但是很惊奇的是在这样疲累的状态下她能将所有的高音冲到位，在高音的音准上没有出问题，就好像把所剩无几的力气全部用在了刀刃上。这样的话，可能要点名水和星某些疲累状态下会产生严重音准问题的人了<del>（没错说的就是你 sayu 和 sww）</del>。dd 组两个人撩来撩去。Stars We Chase 这里展现出了一个战神秀秀，音准体力各方面都稳得很，堪称 Mia Taylor Swift。安可后第一首就是缭乱，然后全员长衫+光剑，像星战一样，是酸菜世界以外的另一种生草。146 耍剑耍得跟孙悟空似的。<br>&emsp;&emsp;很遗憾没有看到光路还原，导播没播，观众估计也没摆出来，看切米的表情不像是有光路。AZUNA 也没有弹射出场（大雾）<br>&emsp;&emsp;侑爷来了，侑爷再次弹钢琴了，这次是笑容满面，自信满满。侑脱离粉丝定位了，上台一起唱歌了，不过没关系了，随着粉丝对侑爷的代入感越来越小，其实好多人反而越来越希望 hnk 上台，不要埋没这一人才。后面 ed 的时候侑拿个篮子来回收花朵，最恰当的词语来形容她应当是 采 花 大 盗（x<br>&emsp;&emsp;其他的看点大概就是 C&amp;R 的时候的鸡兔大战、萌 p 和兔子两大美腿了。衣服的话，r3 新衣服都不错，op 衣服很还原（就是担心热死）但可惜只跳个 op 就换掉了。</p><p>&emsp;&emsp;读研了，身份逐渐学者了，看到这些还是很悸动，希望能一直悸动下去。<br>&emsp;&emsp;第一场体验很棒，期待后面有没有大新闻了。</p><h3 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h3><p>&emsp;&emsp;歌单基本没换。其实也没什么能换的，至少安可前的部分一首都换不了。<br>&emsp;&emsp;关于菜宝：Eutopia 最后一节副歌的第一句，跟它前一句“follow me”重叠了，这必然是有一句唱的有一句播的，这就说明无敌万能的虹虹其实也是有垫音的，打破了“虹全开麦”的传说。虽然情有可原，因为原曲这里就是重叠的，你可以说这是因为追求原曲效果不得不这么做。但是，鉴于他现在的垫音技术真的垫到神不知鬼不觉了（可能就是开场前录了一遍无修音的，而不是垫 CD，要不是重叠，真的锤不出来），那么“即便是疲惫也能将所有的高音冲到位”这个能力，就值得怀疑了。</p><h3 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h3><p>&emsp;&emsp;偷跑了永远一瞬？？这首有资格成为大毒曲的，如果放在更合适的位置（比如放在合适的动画剧情后），就会毒死人了。<br>&emsp;&emsp;秀战神今天的音准很有问题，像是累了。<br>&emsp;&emsp;场地大了，能放花车了。有在日留学群友现地抽中过道位，本以为会有侑酱经过的，结果侑酱的路线偏了 QAQ<br>&emsp;&emsp;厂长在缭乱的时候被 staff 烟封了（x</p><h3 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h3><p>&emsp;&emsp;先说一些细节，比如开头 C&amp;R 的时候果林施展调虎离山之计，先把步梦拉到角落然后去抱侑酱（x<br>&emsp;&emsp;萌 p 和秀秀，都很累的样子。萌 p solo 的声音很虚，秀秀音准比昨天好些，但后面也控不好。</p><p>&emsp;&emsp;然后就是万众瞩目的大新闻了，都期待虹能不能出第三季。如果有，说明学园偶像这个本职的故事是能打持久战的（而不是靠跳槽异世界续命）。<br>&emsp;&emsp;新闻出来是虹四格的动画化，带侑爷，明年一月番，虽然是 TV 动画，但是是 short。<br>&emsp;&emsp;稍微比期待的低了一丢丢。<br>&emsp;&emsp;但是并没有关系，反而是有好处的。因为这样一来，其实说明虹的主线进程开始放慢节奏了。回想水和星，其实都很赶，水是按老缪的节奏走的，走完了发现无路可走了，加之疫情，闲置下来了；星的话，两季 tv 的间隔缩短到正好一年，live 是赶鸭子上架，不仅间隔短，还超级加倍巡演。现在日程表密集得很，事实上下周还有“感谢祭+游戏重大发表+星10话+星生放”这样的连续轰炸，我是不喜欢的。放缓一点来，提高企划寿命，也让人能喘口气，更重要地，让每一次活动（动画也好，live 也好，出书出综艺也好）准备充分，提升质量，这样才值得回味，也有时间回味。</p><p>&emsp;&emsp;后面还有二次返场。不过没有发表额外的感想，就是唱一首歌就跑了，属于只是浅浅地回来一下。也是契合氛围的。</p><h3 id="总"><a href="#总" class="headerlink" title="总"></a>总</h3><p>&emsp;&emsp;头一次是几乎把 4 场全看完，没想到厨虹没那么深的我，看 live 的程度超过了其他所有团（x <del>有没有可能就是你摸鱼摸得太厉害了，赶紧读论文去好不好</del><br>&emsp;&emsp;虹真的蛮好的，有不同于传统 LL 的设定因此很多地方可以搞创新施展拳脚，有一个高厨力动画制作组，现在逐渐有了历史积淀，也可以拿出些情怀来了。<br>&emsp;&emsp;我的感受就像是，有个朋友能够继续陪跑下去了。感觉很好啊，值不值得追一辈子呢？</p><p>&emsp;&emsp;星也是值得期待的后辈，只能真切地希望大家心平气和地、不要带着怨气地去看星，不要学一些 up 主脑子都不转一下就开始锐评。要是本来鉴赏能力就不怎么好，还心浮气躁地看，那真是浪费他们给你讲的故事，也浪费你听故事的时间。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;众所周知虹动画第 2 季制作组厨力拉满，呈现出了一部精彩绝伦、细节可赏、值得每周期待的作品。那么以虹动画第 2 季为主题的虹 5th live 会怎么样呢？&lt;/p&gt;</summary>
    
    
    
    <category term="玩" scheme="http://kqp.world/categories/%E7%8E%A9/"/>
    
    
  </entry>
  
  <entry>
    <title>Liella 第二季随笔</title>
    <link href="http://kqp.world/Liella_S2/"/>
    <id>http://kqp.world/Liella_S2/</id>
    <published>2022-08-01T15:21:06.000Z</published>
    <updated>2022-12-05T02:49:29.256Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;纯粹是<a href="/something/" title="杂写">杂写</a>里面占篇幅太长了，所以拉出来单开一篇。<br>&emsp;&emsp;但为了一部番单开一篇 blog 实在是有点。。。</p><span id="more"></span><p>&emsp;&emsp;最近在看星Ⅱ，随时发表一下感受。</p><h3 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h3><p>&emsp;&emsp;前三话来看，是一部特别写实的番，如果把 LoveLive 大赛换成 XCPC，那完全就是我们集训队的真实写照。前三话每一话都表达了一个特别的主题，或者说矛盾。第一话的矛盾是要不要加人，加人的问题曾经讨论了很多，三次元加人可能问题比较大，动画剧情里的加人那完全就是正常的社团招新，相比起缪水前辈，她们更多地是作为传播学园偶像快乐的社团，而非封闭团体。第二话的矛盾是招新时如何平衡高团体目标与训练强度的问题，这是同类社团绕不开的问题，做过招新工作就会知道，你必须思考如何既能展现团队最终潜在的高成就及其道阻且长，又不能过分表达过程的艰苦来劝退新人，新人来了以后还有一个循序渐进的过程要怎么做，事实上头疼得很。香音她们的探索是降低训练强度，改变活动理念，但最终还是推翻了。第三话的矛盾是优胜的意义和信心，比赛如果成绩不好，你会心有不甘，产生信心问题；但优胜了以后又会有别的问题，sunnypa 的梦想是卫冕，Liella 的梦想是夺冠，这是互斥的，一个梦想的实现一定会使得另一个梦想的破灭。每年 OI/XCPC 没拿好牌的人，都会痛苦面具，他们在退役感言里真实地抒发他们的遗憾。而当进了省队/国集/区域赛出线，回头看看一同作战的其他队伍伙伴们，因为省队1/3线、出线队每校只能一支等各种原因被卡掉的伙伴们，你很难不会怀疑你到底在做什么。算法竞赛选手大部分时候足够冷血，坚信菜是原罪，没进队没出线就是自己菜，LoveLive 呢？<br>&emsp;&emsp;所以说怪就怪在 LoveLive 是个比赛，使得学园偶像变成了竞赛。竞赛人看着很爽，其他人恐怕不行，还是得多看看虹，办 school idol festival，“不要参加 LoveLive，会变得不幸”。<br>&emsp;&emsp;塑造出来的香音的内心是这样的，即便是有第一季最终话那样的场景使得她拥有坚定的信念，仍然会随着时间的推移、外界的各种反应，而使得信心下降，飘忽不定，怀疑自己。说明她不是神仙，内心跟我们一样，都不是强大到完美、强大到完全不受干扰的。</p><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><p>&emsp;&emsp;8.27 的生放对于第 4 5 6 话的解读的几处亮点节选：</p><ul><li>“虽然前面夏美一直在赚钱，但其实是用赚钱来掩饰自己实现不了其他梦想，只有赚钱不会骗自己。”</li><li>“从前是大家帮助了香音，让她能重新唱歌。现在香音想要去帮助大家。一个帮一个，把梦想传递下去，这就是连结。”</li><li>“不是只有二期生在引导夏美，一期生也一直在影响夏美，夏美是在 8 人的帮助下找到梦想入队的。”</li></ul><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><p>&emsp;&emsp;到第八话为止所有的 TV 插入曲情调都很统一，都是欢快的。所以会出现一个问题：单看每首歌曲都挺好，放在 TV 里就不见得合适了，因为跟情节不太相关，像是纯粹为了插首歌一样。在这方面做得好的是缪，缪的每一首动画插入歌都是紧扣主题的（start dash、万圣、婚礼、数星星等等，你想想是不是都有一整话或者一大段的铺垫），从曲风到歌词。水虹也相对较好，情调是对得上的（比如第一季海滩上捡垃圾完了之后紧接梦夜空，配合孔明灯）。星Ⅱ这里，相关性体现不出来。<br>&emsp;&emsp;其实更像是一部竞赛番了，全篇更多的笔墨在于如何努力训练参加比赛，但并没有把这个过程融入到曲子当中。<br>&emsp;&emsp;我似乎是逐渐成为香哥哥厨了。无他，就是觉得香哥哥内心同时具有害羞迷茫与坚定强大两种特质，能看到她不断地在用后者去努力克服前者，可以在关键时刻表现出来飒爽的姿态，给人很能依靠的感觉。中途也有无法决策的时候，这时候她跟小千就是互相替补，你犹豫了我坚决，我犹豫了你做主。</p><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><p>&emsp;&emsp;来谈谈第 9 话吧，感情上的小巅峰。<br>&emsp;&emsp;第一感受是：你们还是能写出像样的感情戏的嘛！<br>&emsp;&emsp;堇主动当坏人，为了让可可留下，她要做的牺牲很大，就是忍受队友的误解，甚至是永久的（如果没人出来解释的话）。可可自己扛下了一切也是猛得很，可可现在才是最焦虑的，但她要反过来安慰堇。别看可可最后抱堇一副稳得一批的宠爱，猜都能猜到回国的问题根本没解决，后面还要怎么扛？完全是打心态仗了，梭哈自己能赢。感受一下，这两个人不是香哥哥渐渐成长的强大，而是在突然爆发的事件中霸气侧漏。<br>&emsp;&emsp;感到惊奇的一点是一年级四人去找堇的时候，传达她们主动放弃上台的心意，用的是一段和声。虽然这个和声的旋律我听不出什么东西（需要请专业人来分析），不知道这能不能表达她们的感情。<br>&emsp;&emsp;后面可可抱堇哭的时候，喊了两遍“嫌いだ”，然后接一个“大好き”。有没有觉得很熟悉？没错就是香音的《青空を待ってる》，唱了三段的“嫌いだ”再突然转变接一段“大好き”。这首歌我当初喷它小百合套着一个半熟不熟的理解就开始唱了，歌词隐晦得很，很难抒发真正的感情。在第九话里套用了这个格式，播到这里，我就想，这首歌给可可唱一遍会怎样，但是发现不太行，因为可可对堇没有根本的嫌い，堇不是对可可造成了什么长期伤害的。所以可能只是套用了个格式，换了一种感情。<br>&emsp;&emsp;从第七八话过渡到第九话会有点突然，感情上是突然上了一大个台阶。如果能把这话拆成两话，用一话时间慢慢把感情铺上去，又会好很多。感情戏以细腻为佳，突然爆发的话得有足够的伏笔才能精彩。<br>&emsp;&emsp;比较主要的问题（也是之前的问题一路继承下来）是，已经不仅仅是把偶像番写成竞赛番了，这个 vn 一来，快要把竞赛番变成战斗番了。sunnypa 被 vn 杀掉，以及幽灵般地向香音喊话，这个 vn 拉满一股神秘大 boss 的味道。sunnypa 惨死区域赛的剧情我熟不熟？可太熟了，19 沈阳万众瞩目的隐练一年的业余门槛突然就被假题杀掉了，21 广州我们队滚到铜牌区了，22 两场中国 Final 一滚榜把一众强队和暴发户都刷掉了（逆十字甚至因为设备原因退赛了）……大家惊讶的眼神不就跟看到 sunnypa 没出线是一样的吗？竞赛党这些是见得多了，但是学园偶像真的要这么玩吗？毕竟我们的目的可以是赢得比赛，但是你们的目的是传递真感情，你们太过功利，就什么都传递不出来了。<br>&emsp;&emsp;如果有人被竞赛剧情吸引了，想要体验一把团结一致冲击比赛的快(tong)乐(ku)，欢迎来玩中学信息学奥林匹克竞赛和大学生程序设计竞赛！（x</p><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><p>&emsp;&emsp;9.16 生放，解读 7 8 话。<br>&emsp;&emsp;多看看 non 酱这个细节鬼才吧，她是真的会观察，会分析。</p><ul><li>“恋酱的沉迷游戏，反衬出她以前严肃的一面，让我惊叹她以前到底是个多认真的人。”</li><li>“慌张被抓的人都献出培根蛋面包。”</li><li>还有各种对比和衬托的应用</li></ul><p>&emsp;&emsp;讲到了很多关于第八话歌的祭り感。挑出来两个画面很好地表达了这首歌的感情，一个是香哥哥飒爽的笑容，体现的是浓厚的欢乐的祭り氛围，另一个是小千的跳跃，拉出全队的满满自信。<br>&emsp;&emsp;我时刻提醒自己，我们千万不要用“我比声优和制作组还懂动画”的态度来发表评论。这不是说他们的分析和评价不可反驳，而是从他们视角出来的东西，应当引起重视和思考。</p><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><p>&emsp;&emsp;第 10 和 11 话可以放在一起，<del>和 vn 正面对刚</del>探讨 lovelive 和歌唱的意义。我非常期待这个的，并且也很期待在面对弱 motivation 而强能力者的时候，她们要怎么办。编剧的回答是，赢下来，并且赢得十分坚定，香哥哥这次没有犹豫了，正面指出 vn 的歌曲不如她们能传达“连结大家，分享喜悦”的内涵。<br>&emsp;&emsp;小千和香哥哥在比赛后找 vn 的行为以及她们的想法，也都体现出结丘精神，不会放弃任何一个人的梦想，就像当初无论输赢也不能不让一年级上场一样。这里其实是对这种精神的扩大了，不仅是对于队内人，还是对于对手，与她们无关的人。<br>&emsp;&emsp;那么一个巨大的矛盾点就再次出现了（这不是第一次出现了）：梦想的互斥。第一次是 sunnypa 要卫冕冠军，光荣而退，只可惜半路被 vn 杀掉。这次是第二次，要么 liella 代表全体结丘学生一起胜利而 vn 没学上，要么 liella 失败而 vn 成功上学。你看，编剧其实够大胆的，在这种团结一致的结丘精神下，接二连三出现这样的互斥事件，用残酷的比赛框架，去捶打考验结丘精神。所以说这部剧现实得很对吧，你总是要思考这些问题，这些时时刻刻、无处不发生的问题。</p><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><p>&emsp;&emsp;9-12 话的生放讨论找个时间把熟肉补了再一次过发吧，日语不好，看生肉只看懂个大概。（挖个坑在这里）</p><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><p>&emsp;&emsp;12 话了，终于完结了。然而，大家的感受，包括我的感受都是“终于解放了”，而不是“呜呜呜没有 13 话我要死了”。很多因素，包括动画的质量下降了，评论恶臭了，每周上贴吧 b 站 q 群什么的都是一群牛鬼蛇神在声讨。我虽然努力去让每一次看动画都是心态稳健平和的，但是评论环境实在太糟糕，多多少少是影响了自己的观看和思考的。所以我也要庆祝，与其三个月每周忍受不堪入目的评论，不如早点结束，你好我好大家好，大家重新对下一项作品充满期待，回到正轨。<br>&emsp;&emsp;先说 12 话。我的感受是不算很好。主要原因是这是最终话，一个故事的结尾，要求当然跟中间是不一样的，中间的作用是推动情节发展，烘托氛围，塑造人物形象，到了结尾，你铺垫的就该结束了，感情就该有收尾的样子了，但是这次最后的 Lovelive 决赛并没有赢出感觉来。<br>&emsp;&emsp;先从感情来分析。横向对比往届的 Lovelive 决赛就知道了，不难发现，任何一个团（包括星团）在决赛之中都会掺入比赛之外的感情，缪是成员毕业、团队即将解散，水是学校关闭，以及对未来的迷茫，其感情都是留念、不舍，对曾经一起度过的生活道别；星这里则是为了不落下香音和 vn 的梦想，要暂停 9 人团队，有些许不舍，也有对决赛胜利从而实现她们梦想的信念。显然编剧也意识到了，光有一个比赛目标的话对于感情来说是绝对不够的，而附加一些别的感情在上面，就是最为有效的打造感情的方式。但问题是什么？是铺垫。感情以细腻为佳，一条连贯而不断发展的感情线会非常重要。我认为缪和水都做得非常好。水采用了最简单的方法——长度，把感情线拉长，她们大概集数过半就已经确定废校了，也就是说有将近一半的时间用来表现失落、苦闷、迷茫、探索、重新找到自己的价值，中间还插入了两话的雪的失败，两份失落叠加（一个额外的效果是借此把两位妹妹的成长塑造得淋漓尽致）。在这之中，每一处停顿都感觉时间像停下来了的样子，这就是感情氛围起作用了。缪真正开始她们的矛盾其实很晚，也同样差不多第 10 话才开始，也到 11 话结尾才把解散点出来，但是她们主要告别的是她们作为 μ’s 团体所度过的时光，所以前面 4-7 话的个人日常回、8-9 话的团体挑战，都是与矛盾相关的，就能起到很好的铺垫作用，这样让整个感情线流畅地呈指数函数形状发展，在 11 话迎来爆发，然后两话收尾。来到星这边，注意到星的附加矛盾其实是比较转折的，是突然间来了个 vn 跟你说你被 MIT 录取了，并且我要依附于你才能上学，前面的主线则是 Liella 一行人承载学校大家的梦想一起努力，因此对这个突然出现的矛盾点就没有铺垫，也就是说，这份附加的感情总共就出现了两三话，加之“维也纳音乐学院”这个音乐界 MIT 相关的剧情都有点荒诞不自然，感情当然也就不够细腻。<br>&emsp;&emsp;然后是歌。这是星 2 老问题了，歌曲曲风、歌词、感情基调都与剧情弱相关，到了决赛这里，放一首抒情慢歌，那么它自然也表达不了决赛或者是最终话应有的感情高潮。这首歌更适合作为平常的插入歌，并且最好是不以比赛的形式展现，增加一点音乐剧的样子，会非常好。横向对比缪水也是同样的，水的决赛歌是水蓝，歌词和舞蹈动作是很强烈的“告别过去，向新的未来进发”的寓意，这就是对将近半季的失落苦闷迷茫探索的回答，作为最终曲目是一个完美的总结；缪的是 kirakira session，单论这首歌我觉得其实也不算很好，歌词是合适的但曲调则是偏平静了，没有非常契合 11 话强烈的感情，但缪的亮点我认为不是这首决赛曲，而是紧接其后的安可，亮出 op1，这才是从音乐上对决赛感情的升华，两首歌结合，有慢有快，有静有烈，op1 也是适合 call 的曲，所以能把气氛抬起来。<br>&emsp;&emsp;基本上就是这两个最大的问题了。<br>&emsp;&emsp;也还有些其他问题，比如小千笑着流泪竟然只是请求；比如 vn 直接向现状屈服，不再打算通过自己的努力去获得入学资格了。<br>&emsp;&emsp;这个开放结尾，如果你要现实，我甚至可以说留学中止是因为疫情原因（x</p><h3 id="关于别人"><a href="#关于别人" class="headerlink" title="关于别人"></a>关于别人</h3><p>&emsp;&emsp;顺便说一下贴吧b站的追番评价。<br>&emsp;&emsp;可以说我大部分评价跟他们很不同。他们的文学鉴赏能力，从吐槽 Aqours 的剧情不合理就可见一斑了，大抵是高中语文也没有好好学，基本的意识流心理描写都不会读。很多时候给点整活就说是神回，剧情平淡一些、live 没有优胜就说是烂回，咬死一个人设，觉得人物性格不可更改不可成长（夸一夸大学语文老师反驳“文学作品忌讳人设崩塌”的精彩发言），夸张和心理现实主义写法被喷为不合逻辑。能从感情矛盾、人物塑造、表现手法等来分析的实在是少数。<br>&emsp;&emsp;我一直认为，如果不会赏析，就翻一下高考语文练习册，复习一下高考语文阅读理解，应该任意一本练习册都有提供一套详细的框架和套路的。这实在是最简单通用的、拿来就用的方法了，不需要你再去学更高级的文学理论，各种主义和体系的分析，也不需要你学哲学和美学，去参透更深层的思想。但明明大家都是考过高考语文的人了，甚至都在瞧不起高考应试套路了，却连一套赏析方法都没能掌握，怪。<br>&emsp;&emsp;也有自诩看番无数的“老二次元”以自己的资历为支撑来开喷。但看番资历不应成为评价理由，资历培养出来的观感若不能转化成成体系的分析和评价标准，那其实还是自己的感情和主观认识在主导，它不能叫评价，说白了就是你看番时心情不好。</p><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><p>&emsp;&emsp;第五话第六话确实出了一些问题，但我觉得各大平台的环境噪音影响太大了。将来需要找个时间从头到尾地重看一遍星Ⅱ。</p><p>&emsp;&emsp;发现对于“人设”的评价属实有点泛滥了。我仍然坚持大学语文老师的观点，不要在评论中引入“人设有没有崩”这种东西，扼杀人物形象性格多样性实在荒谬得很，你顶多能分析分析多种形象性格是不是没有很好地衔接。</p><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><p>&emsp;&emsp;本来只是简单地觉得这届观众应该好好看看 2022.8.27 的生放对于第 4 5 6 话的解读，但是看到 10 组熟肉下的评论，竟然充满着“聊天和来信都是第 4 话的，第 5 6 话都没有，可想而知这两话有多烂”这样的言论。我终于明白，这些人连看生放熟肉都是有眼无珠的，星Ⅱ期间再也不要看 lovelive 吧和 b 站视频的评论了，充斥着瞎 jb 看两眼就大放阙词的人。</p><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><p>&emsp;&emsp;搞半天原来大家还有“声优盾”这个想法在，这可能是大家从根本上看不进去生放的原因了。我觉得，你们最好是拿出些能锤的证据来，不然如此随意地揣测别人的想法，你们不觉得很不尊重人吗？为什么可以这么随意地用自己心中恶心的想法来代表别人？<br>&emsp;&emsp;并且最最重要的，不论她们到底是不是真心给出的分析和讨论，她们说出来的话对不对才是重点吧？那她们的分析和来信写的难道不正确吗？没有那些细节吗？这些不足以引导你去读懂这部番吗？</p><h3 id="end"><a href="#end" class="headerlink" title="end"></a>end</h3><p>&emsp;&emsp;这部剧到这里算是落下帷幕了。<br>&emsp;&emsp;它是一部正常普通的番，可赏之处很多，直面了很多现实问题，引起我很大量的思考。<br>&emsp;&emsp;网友们指出的一些问题是存在的，比如香音小千二人主导了过多事情导致团队内的羁绊塑造较弱，以及我这长篇大论总结的一些问题，导致它不会成为一部很优秀的番。总的来说，商业气味很浓，浓过头了，最主要的体现就是歌曲和剧情的弱相关，像是上头对编剧说，你这话要插一首歌，至于歌曲是什么，我不知道，可能还没写好，但你这里要插首歌。所以最方便的做法，就是比赛，比赛，不停地比赛，以比赛这个万金油平台，把歌曲都塞进去。<br>&emsp;&emsp;追番过程实在是艰难，太多被迫激起的激昂和思考了，于是有了这篇博客。其实明知这样是不好的，应该整部番看完一并评论，而不是看一话就发表一话评论，这样才有更全局整体的思考。<br>&emsp;&emsp;反正确定第三季了，第二季给我最大的教训就是，以后绝对不能冲动地看完一话就来看大家评论了。当然如果完全不在乎评论的话那就甚至不需要追番，缓冲一下几话几话地看，应该效果更好。<br>&emsp;&emsp;倒也感谢这些评论，鞭策我看完了第一本美学哲学教材，也确定了接下来的美学哲学读本和文学理论的读本了。</p><h3 id="外部链接"><a href="#外部链接" class="headerlink" title="外部链接"></a>外部链接</h3><p>&emsp;&emsp;推荐这个<a href="https://www.bilibili.com/video/BV1AK411o7xc/?share_source=copy_web&amp;vd_source=a15792db4a83b7fae4de2b946880c9b6">关于香音的分析</a>，以及这位 up 主的其他投稿。这位 up 是有认真分析的，关于香音的双重性格讲得很棒。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;纯粹是&lt;a href=&quot;/something/&quot; title=&quot;杂写&quot;&gt;杂写&lt;/a&gt;里面占篇幅太长了，所以拉出来单开一篇。&lt;br&gt;&amp;emsp;&amp;emsp;但为了一部番单开一篇 blog 实在是有点。。。&lt;/p&gt;</summary>
    
    
    
    <category term="玩" scheme="http://kqp.world/categories/%E7%8E%A9/"/>
    
    
  </entry>
  
  <entry>
    <title>2021 EC Final 退休游记</title>
    <link href="http://kqp.world/2021_EC_Final/"/>
    <id>http://kqp.world/2021_EC_Final/</id>
    <published>2022-07-22T06:37:00.000Z</published>
    <updated>2022-08-01T16:28:57.627Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“你们不是已经毕业了吗？”          ——遇到的所有熟人</p></blockquote><span id="more"></span><p>&emsp;&emsp;其实得知我们要去 EC 是一点都不惊奇的，毕竟大四这个赛季打也打了，金也拿了，我校也还没在区域赛出线，所以必然要被抓壮丁，且被寄予出线的厚望的（x<br>&emsp;&emsp;反正本科的课业全部结束了，无人之境也没有晋级、荣誉的压力，所以去比赛也不过是娱乐消遣、毕业旅行。我们三个人好像都已经把竞赛当闲时爱好了，心态上很放松，也没训练。就是可怜 zayin 请假几千几千地亏，邓老板牺牲了跟同学去青海的机会，亮亮损失了在成都陪女朋友的时光，nurivf 一直在修论文，好像只有我游手好闲（？<br>&emsp;&emsp;本来我校是5个正式+2个打星，结果后来打星也转正了，变成7支队伍浩浩荡荡，一个大军团<del>，占 EC 总队伍数的约 2%</del></p><h2 id="7-12-7-17"><a href="#7-12-7-17" class="headerlink" title="7.12~7.17"></a>7.12~7.17</h2><p>&emsp;&emsp;EC 前的一周集训，华为请我们去松山湖训练，题还是我们自己找，但吃住是他们的，顺便让他们插点广告。<br>&emsp;&emsp;于是就二刷了松山湖欧洲小镇。这次是深度游览，体验园区内的饮食，坐小火车上下班。住的酒店非常豪华，还能免费洗衣服。不过不包晚餐，要我们自己去各饭堂体验，对于完全不想花钱的我并不友好，宁可他晚餐也发盒饭。。。<br>&emsp;&emsp;问华为员工推荐食堂，宣讲嘉宾说吃多了都没意思，左左说不知道，yxuanwkeith 夫人说 KFC（<br>&emsp;&emsp;华为 ICT 搞的这个 Auto Driving Network，总有点标题党的感觉。。。<br>&emsp;&emsp;去年在欧洲小镇泡了一天，就有了相当的欧气一发抽出 AC1 黛，这次浸润 3 天之后，僕光Ⅱ、ns 一年级一上线就开抽，十分顺利地抽出了 4 个 20n 复读机配件，平均 125 心一张卡。给欧洲小镇点赞。</p><p>&emsp;&emsp;做了 5 套题，一套签到练习，两套省赛，两套外国自闭场，康复效果不错。最后的午餐去打 bytecamp，感受了一下，都是好题，他们那是真正的 camp。</p><p>&emsp;&emsp;见证了西安临危不惧镇定从容地把疫情处理干净，也见证了从广州到东莞之后广州、东莞疫情相继炸开。换在精准防控时代以前，我们这趟行程就是各种勇闯毒区。<br>&emsp;&emsp;从东莞回来是 17 号下午，正值广州萤火虫漫展，遂快乐逛外场，与 staff 朋友见最后一面。一开始校队还商量 18 号白天先逛了萤火虫晚上再去西安来着（x</p><h2 id="7-18"><a href="#7-18" class="headerlink" title="7.18"></a>7.18</h2><p>&emsp;&emsp;飞机是中午的，不用挤地铁，好评。<br>&emsp;&emsp;在西安的高速出口被拦截，工作人员一看行程码，说：“广东省广州市，广东省东莞市，全是中高风险。”于是做了一大票登记，花费半小时。<br>&emsp;&emsp;发现酒店是去年华为晚宴的酒店，感觉不祥。不过环境挺好，房间表面上也不错的，开房的时候看到标双价格是 800+ 一晚。当晚的晚餐是在围栏处领取盒饭，外面排队报到的人，和里面排队拿饭的人，互相都像看猴一样。<br>&emsp;&emsp;想补一个题，拖拖拉拉地还是没补完。<br>&emsp;&emsp;得益于50G/月的流量套餐，成为全队外出流量担当，并得知酒店的网十分炸裂。</p><h2 id="7-19"><a href="#7-19" class="headerlink" title="7.19"></a>7.19</h2><p>&emsp;&emsp;早餐有面和豆腐花，还有一大堆凉菜，没有 coffee。总体来说质量可能跟去年华为晚宴是一样的，但早餐跟正餐评价体系不一样，所以感受是略有进步。然而豆腐花竟然是酸的，感到十分震惊。<br>&emsp;&emsp;午餐的菜品十分少，廉价感十足，这就又回到了华为晚宴的质量了。联想到比赛场地叫“御宴宫”，突然绷不住了，当即创作了一个“御宴丁真，鉴定为油饼”。不过好像大家不混贴吧，不太玩丁真梗。。。</p><p>&emsp;&emsp;下午宣(chou)讲(jiang)。先去了元戎启行打算抽机键，结果发现要提问回答才能拿奖，于是把 6 张虾皮券集中到欧主力手上，派他去看看 switch，我们留守元戎。结果得知要扫二维码签到且没有 switch，我就扫了二维码，元戎结束后去虾皮第二场看看情况，然而签到码只能扫一次，于是第二场没有资格抽奖，空手而归。<br>&emsp;&emsp;后来才知道我第一场中了蓝牙音箱，但是人不在场，被 skip 了。。。</p><p>&emsp;&emsp;热身赛，观察环境，斜对角是胖头鱼头胖，斜前方是小万邦和冰泮北徂。<br>&emsp;&emsp;登录进去发现有二次元（<br>&emsp;&emsp;开场写个 A 题，然后队友直接跟我说，C 题你这样处理一下字符串，然后跑个 Manacher 就行了，我题都没读，直接开冲，过了才大概知道题意（<br>&emsp;&emsp;面基胖头鱼头胖，结果没认出 Howard Li（</p><p>&emsp;&emsp;晚餐依旧是菜品非常少，廉价感十足。发现他们对蒸鱼非常自信，总要在没菜的时候端一锅这样的鱼出来。身为天天吃鱼的广东人，只能说精神可嘉。<br>&emsp;&emsp;晚上参加华为宣讲错过水生放的两首新歌试听。发现前面一群纪中人聚会。。。pku、tju、hkust、scut、hdu，加上我 sysu，10 个人左右了，太辉煌了。<br>&emsp;&emsp;学弟们以及其他熟人见到我，第一句话都是：“你不是已经毕业了吗？”</p><h2 id="7-20"><a href="#7-20" class="headerlink" title="7.20"></a>7.20</h2><p>&emsp;&emsp;吃一大碗酸豆腐，带两瓶咖啡，开场。<br>&emsp;&emsp;签个 I 题，讨论一下，但是去重写错了，获得首红。<br>&emsp;&emsp;很快 A, L 也签完了。<br>&emsp;&emsp;读完 G, H，zayin 表示都有印象，甚至是出过的。判断是 G 简单些，于是想了个构造：先用 bfs 把确定的填完，然后第一行第一列放 $B$，其余依次填。我觉得这个构造有点假，因为黄大爷曾经出过类似的题是要用行和列来构造的，但 zayin 还是先去写了一发，WA 掉。<br>&emsp;&emsp;然后邓老板会了 J，zayin 会了 B，我们讨论出 C 的一个容斥+dp 的做法。B 过得顺利，J WA 后觉得变量定义有点乱，队友们一直在讨论。期间我写 C 发现假了，想写些“迟早要写”的东西发现也很麻烦，遂去读 E。<br>&emsp;&emsp;J 查错无果，遂弃，邓老板完善 D 的想法，我和 zayin 讨论 E。E 非常多 corner case，讨论出大致框架就开冲了，一路 WA 一路修，幸运的是最终集齐了所有 corner case 过了。期间 J 修了两个 bug 过了，D 也讨论清楚开始写了。<br>&emsp;&emsp;后来就是 D 一路写到封榜后，补上一个漏了的 corner case 后过掉。期间 C 一直假，最后扫了一眼 G 和 H，zayin 突然会了 H 的建图，最后 13min rush，赛后一分钟过样例。</p><p>&emsp;&emsp;刚出考场感到非常遗憾，因为算了算 8 题出线概率比较大，7 题就基本没戏了，所以如果 H 真的赛后 1min，那就痛失出线了，zayin 哀嚎。我也有一种非常可惜的感觉，但并不深刻，本身就没奔着出线来的，能在强队如云的 EC 不怎么训练还混到金就不错了，没想到好像还混得挺前，真要是过了 H 出了线，谁研二还要打 final 啊~<br>&emsp;&emsp;但其实我们队本质上都是乐子人心态了，这样的遗憾如果放在大三及以前，我们估计会以头抢地，但这次，其实也就是哀嚎两声，平静得很快，以至于后来有民间榜说我们也出线了，心态也都没啥波动了。</p><p>&emsp;&emsp;滚榜发现一众强队出线队都寄了，排在我们前面的都是清北浙南+一两支突出的队伍。大家都跟我们一样是爆发户？还是战线太长大家都不想训练了？现在就是清北浙南这些学校集中排在各大赛站前排，使得榜上 10 多名的队伍还能有不错的校排成绩。<br>&emsp;&emsp;然后关于题目，分类讨论的浓度实在太高了。从 I 签到就开始讨论，E 超级大讨论，D 也要讨论，好像就是大半场都在听队友讨论，帮队友梳理讨论。其他题 debug 时想 corner case 也会加重这一感受。<br>&emsp;&emsp;知乎上好像都是关于环境酒店的吐槽，没有对题目的评价。<br>&emsp;&emsp;对于我来说，又是一次被队友带飞的比赛。全程就是开场签了个到，然后胡说八道四小时躺了个金。E 主要还是在听和 check，D 姑且算是提供了一个 corner case。<br>&emsp;&emsp;后来发现我们 rush 的 H 的做法还是有问题的，建出二分图是对的，但后面应该求最大独立集而不是黑白染色。这题在赛场上估计还要半小时，WA 一次，才能意识到这个问题。所以我们的整体节奏还是慢了许多，并不是少了一两分钟的遗憾。我们花在 C 上的时间非常多，并且大部分时间是判断 G 比 H 简单，导致花在 H 的时间是不够的。</p><p>&emsp;&emsp;虾皮最后黑幕钦定 switch。<br>&emsp;&emsp;浅体验了下新的华为晚宴，之前华为 hr 说敲打了酒店必须做出重大改进，最后质量是合格了，但要说一桌 1000，那不如去抢。<br>&emsp;&emsp;晚上快乐逛市区。大雁塔南侧建了条商业街叫大唐不夜城，十分奇怪，根据初中历史，大唐的长安是宵禁的而且严格管控商业，在大唐搞不夜城你是想被杀头吗？<br>&emsp;&emsp;登上城墙，但无法眺望长安城。只走了 1/4 段，要是有充足时间走完它就好了。感觉西安这个城很厉害，用古代城墙包住现代市区，高楼大厦、旧市区建筑、古风建筑、洋式建筑就这么交在一起。</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>&emsp;&emsp;体会最深刻的还是心态变化了。最早大一大二是激情洋溢地打比赛，大三崩溃过所以是半热情半烦躁地过着，大三后期以及大四，因为没有压力了，就是以一种业余爱好的心态在参与。所以乐呵呵地来，乐呵呵地走。<br>&emsp;&emsp;可能这次最受伤的是亮亮了。最后的午餐这年非常努力，有在认真训练，但最终都没能有出线的机会。前几场还有些策略问题，比如有人一个题自闭一整场没人救，但最后的昆明，没有太多策略问题了，是凭实力自闭了。欧主力和梁主力如果想打还有两年，并且下一届还能招到 NOI 银水平的一众新大一，但是亮亮的竞赛就结束了，他做了很多措施来增进水平，包括用一年与水平一般的队友组队练 carry 能力，最后赌上大四，输了。<br>&emsp;&emsp;其实以我校的训练强度和水平，冲出线并不稳定，还得有一定的运气因素，得恰好选到一个没什么人的赛区，恰好没有重大失误。大四这一年，各赛区都有稳定强队和暴发户强队，没有上一年的济南昆明这种赛区了。</p><p>&emsp;&emsp;再说些杂的。引用我校教练的观点，疫情的 xcpc，特点就是战线拉得特别长，到了后期，大家都累。有的队伍仍然坚持一周四训，但应该更多的学校，氛围会逐渐变差。战时氛围跟备战下一赛季的氛围是不一样的，前者紧张得多，消耗的精力也会大。而且占用太多课余时间，没时间去体验科研等其他事情，这也不好。</p><p>&emsp;&emsp;后面还有 ccpc final 和 world final，打完，就可以写退役记了，这就是真退役了。希望孟加拉还是能去线下。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;“你们不是已经毕业了吗？”          ——遇到的所有熟人&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="总结与游记" scheme="http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"/>
    
    <category term="OI/ACM" scheme="http://kqp.world/categories/OI-ACM/"/>
    
    
  </entry>
  
  <entry>
    <title>【AtCoder Grand 029F】Construction of a tree 题解</title>
    <link href="http://kqp.world/%E3%80%90AtCoder%20Grand%20029F%E3%80%91Construction%20of%20a%20tree%20%E9%A2%98%E8%A7%A3/"/>
    <id>http://kqp.world/%E3%80%90AtCoder%20Grand%20029F%E3%80%91Construction%20of%20a%20tree%20%E9%A2%98%E8%A7%A3/</id>
    <published>2022-06-17T06:58:32.000Z</published>
    <updated>2022-06-17T08:23:50.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>&emsp;&emsp;设全集为 $\{1,2,\cdots,n\}$，给出 $n-1$ 个子集 $E_1,\cdots,E_{n-1}$，$|E_i| \ge 2$，请从每个子集中选出两个元素，视为给两个节点连一条边，使得最后构成一棵树。<br>&emsp;&emsp;输出一种方案或是“-1”表示无解。</p><p>&emsp;&emsp;$n \leq 10^5,\ \ \sum |E_i| \le 2 \times 10^5$<br>&emsp;&emsp;4s</p><span id="more"></span><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>&emsp;&emsp;这种觉得好像是流但看上去不是很能流最后又确实是流的题真的一流。。。</p><p>&emsp;&emsp;考虑必要条件，一棵树去掉根以后，边和点可以一一对应（每个点跟它连向父亲的边对应），因此建一个二分图，左边是 $1,\cdots,n$ 表示节点，右边是 $E_1,\cdots,E_{n-1}$ 表示边，那么左边去掉根节点之后应当有完美匹配。并且这是一棵无根树，所以左边去掉任意点以后都应当有完美匹配。<br>&emsp;&emsp;然后看看这个条件充不充分。有完美匹配以后我们还需要的是整个图连通，也就是根节点可以到达其他所有点，也就是从左边的根节点开始，沿着“非匹配边-匹配边-非匹配边-……”的交错路能遍历所有的点。题解证明了这是成立的：因为“左边去掉任意点以后都有完美匹配”，所以任取非根节点 $x$，把去掉它的完美匹配与去掉根的完美匹配并起来，这样除了根和 $x$ 外所有点的度数都是 $2$（因为每个点都连了两条匹配边，只有根和 $x$ 连了一条匹配边）。现在全图只有根和 $x$ 度数为 $1$，那它们必然在同一个连通块里，因为连通块的总度数一定是偶数。所以根和 $x$ 是连通的。<br>&emsp;&emsp;因此，“有解” $\to$ “左边去掉任意点都有完美匹配” $\to$ “任意求一个完美匹配，从左边的根节点开始，沿‘非匹配边-匹配边-非匹配边-……’做 BFS，可以遍历所有的点”，并且这样也就构造出一组解了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>, maxsum=<span class="number">2e5</span>+<span class="number">5</span>, maxe=<span class="number">4e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; S[maxn];</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[maxn];</span><br><span class="line"><span class="type">int</span> dis[<span class="number">2</span>*maxn],pt[<span class="number">2</span>*maxn],maxdis;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Hopcroft_bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dis,<span class="number">255</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">maxdis=<span class="number">-1</span>;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span> (!pt[i]) &#123;</span><br><span class="line">Q.<span class="built_in">push</span>(i);</span><br><span class="line">dis[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="type">int</span> cur=Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> go:e[cur]) <span class="keyword">if</span> (dis[go]==<span class="number">-1</span>) &#123;</span><br><span class="line">dis[go]=dis[cur]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (!pt[go]) &#123;</span><br><span class="line">maxdis=dis[go];</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dis[pt[go]]=dis[go]+<span class="number">1</span>;</span><br><span class="line">Q.<span class="built_in">push</span>(pt[go]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxdis&gt;<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Hopcroft_dfs</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> go:e[k]) <span class="keyword">if</span> (dis[k]+<span class="number">1</span>==dis[go]) &#123;</span><br><span class="line">dis[go]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (!pt[go] || <span class="built_in">Hopcroft_dfs</span>(pt[go])) &#123;</span><br><span class="line">pt[k]=go, pt[go]=k;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hopcroft</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> re=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">Hopcroft_bfs</span>())</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span> (!pt[i]) re+=<span class="built_in">Hopcroft_dfs</span>(i);</span><br><span class="line"><span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; ans[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n<span class="number">-1</span>) &#123;</span><br><span class="line"><span class="type">int</span> sz,x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;sz);</span><br><span class="line"><span class="built_in">fo</span>(j,<span class="number">1</span>,sz) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">e[x].<span class="built_in">push_back</span>(n+i);</span><br><span class="line">S[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Hopcroft</span>()!=n<span class="number">-1</span>) &#123;<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> root;</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span> (!pt[i]) &#123;root=i; <span class="keyword">break</span>;&#125;</span><br><span class="line">queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; Q;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x:S[root]) &#123;</span><br><span class="line">vis[x]=<span class="number">1</span>;</span><br><span class="line">Q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(root,x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">auto</span> cur=Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">int</span> son=pt[n+cur.second];</span><br><span class="line">ans[cur.second]=<span class="built_in">make_pair</span>(cur.first,son);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x:S[son]) <span class="keyword">if</span> (!vis[x]) &#123;</span><br><span class="line">vis[x]=<span class="number">1</span>;</span><br><span class="line">Q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(son,x));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n<span class="number">-1</span>) <span class="keyword">if</span> (!vis[i]) &#123;<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,ans[i].first,ans[i].second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;设全集为 $\{1,2,\cdots,n\}$，给出 $n-1$ 个子集 $E_1,\cdots,E_{n-1}$，$|E_i| \ge 2$，请从每个子集中选出两个元素，视为给两个节点连一条边，使得最后构成一棵树。&lt;br&gt;&amp;emsp;&amp;emsp;输出一种方案或是“-1”表示无解。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;$n \leq 10^5,\ \ \sum |E_i| \le 2 \times 10^5$&lt;br&gt;&amp;emsp;&amp;emsp;4s&lt;/p&gt;</summary>
    
    
    
    <category term="OI/ACM" scheme="http://kqp.world/categories/OI-ACM/"/>
    
    
    <category term="算法_网络流/匹配" scheme="http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BD%91%E7%BB%9C%E6%B5%81-%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>【AtCoder Regular 141D】Non-divisible Set 题解</title>
    <link href="http://kqp.world/%E3%80%90AtCoder%20Regular%20141D%E3%80%91Non-divisible%20Set%20%E9%A2%98%E8%A7%A3/"/>
    <id>http://kqp.world/%E3%80%90AtCoder%20Regular%20141D%E3%80%91Non-divisible%20Set%20%E9%A2%98%E8%A7%A3/</id>
    <published>2022-05-31T08:45:50.000Z</published>
    <updated>2022-05-31T09:08:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>&emsp;&emsp;给定长度为 $n$ 的序列 $a_1,\cdots,a_n$ 和一个参数 $m$，对于每个 $i$，问是否能从序列中选出满足如下条件的子集：</p><ul><li>集合包含 $a_i$；</li><li>集合大小为 $m$；</li><li>集合内不存在一个数是另一个数的倍数。</li></ul><p>&emsp;&emsp;$m \le 3 \cdot 10^5,\ m \le n \le 2m$<br>&emsp;&emsp;$1 \le a_1 &lt; a_2 &lt; \cdots &lt; a_n \le 2m$<br>&emsp;&emsp;2s</p><span id="more"></span><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>&emsp;&emsp;如果建出一个“倍数关系图”，那么每次询问就是去掉一个点之后求最大独立集，这就很不可做，所以这个倍数关系一定是要利用的。<br>&emsp;&emsp;子集大小为 $m$ 而每个数最多只有 $2m$，看着就有玄机，只是没想到竟然是这样用的。。。</p><p>&emsp;&emsp;每个 $a_i$ 可以表示成 $2^c \cdot d$，其中 $d$ 为奇数。按照 $d=1,3,\cdots,2m-1$ 把所有的 $a_i$ 分门别类放好，这样总共有 $m$ 个类，且每个类最多只能选 1 个数，又因为最后要选 $m$ 个数，因此每个类恰好选一个数。<br>&emsp;&emsp;考虑如果选了 $2^{c_1}d_1$ 和 $2^{c_2}d_2$，如果 $d_1 | d_2$，那么必须有 $c_1 &gt; c_2$。因此直观来看，$d$ 较小的类 $c$ 应该较大，$d$ 较大的类 $c$ 应该较小。因此可以用 $O(m \log m)$ 的时间从左到右、从右到左分别求出每个类的 $c$ 的上限和下限，那么只要夹在上限和下限之间的数都一定是可行的（比它小的类全部选上限、比它大的类全部选下限即可）。</p><p>&emsp;&emsp;虽然它真的很巧妙，不过似乎只能用于判断 $m$ 为“$d$ 的种类数”是否可行。能用于判断比这更小的 $m$ 是否可行吗？</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">6e5</span>+<span class="number">5</span>, maxm=<span class="number">6e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; V[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Invalid</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> L[maxm],R[maxm],lim[maxm];</span><br><span class="line"><span class="type">bool</span> ans[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line"><span class="type">int</span> er=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!(a&amp;<span class="number">1</span>)) a&gt;&gt;=<span class="number">1</span>, er++;</span><br><span class="line">V[a].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(er,i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">2</span>*m; i+=<span class="number">2</span>) <span class="keyword">if</span> (V[i].<span class="built_in">empty</span>()) <span class="built_in">Invalid</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(lim,<span class="number">127</span>,<span class="built_in">sizeof</span>(lim));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">2</span>*m; i+=<span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (lim[i]&lt;=(V[i].<span class="built_in">begin</span>())-&gt;first) <span class="built_in">Invalid</span>();</span><br><span class="line">R[i]=(<span class="built_in">lower_bound</span>(V[i].<span class="built_in">begin</span>(),V[i].<span class="built_in">end</span>(),<span class="built_in">make_pair</span>(lim[i],<span class="number">0</span>))<span class="number">-1</span>)-&gt;first;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i*<span class="number">3</span>; j&lt;<span class="number">2</span>*m; j+=i+i) lim[j]=<span class="built_in">min</span>(lim[j],R[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>*m<span class="number">-1</span>; i&gt;<span class="number">0</span>; i-=<span class="number">2</span>) &#123;</span><br><span class="line"><span class="type">int</span> lim=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i*<span class="number">3</span>; j&lt;<span class="number">2</span>*m; j+=i+i) lim=<span class="built_in">max</span>(lim,L[j]);</span><br><span class="line"><span class="keyword">if</span> (lim&gt;=(V[i].<span class="built_in">rbegin</span>())-&gt;first) <span class="built_in">Invalid</span>();</span><br><span class="line">L[i]=<span class="built_in">upper_bound</span>(V[i].<span class="built_in">begin</span>(),V[i].<span class="built_in">end</span>(),<span class="built_in">make_pair</span>(lim,n+<span class="number">1</span>))-&gt;first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">2</span>*m; i+=<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p:V[i]) ans[p.second]=(L[i]&lt;=p.first &amp;&amp; p.first&lt;=R[i]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">puts</span>(ans[i] ?<span class="string">&quot;Yes&quot;</span> :<span class="string">&quot;No&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;给定长度为 $n$ 的序列 $a_1,\cdots,a_n$ 和一个参数 $m$，对于每个 $i$，问是否能从序列中选出满足如下条件的子集：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集合包含 $a_i$；&lt;/li&gt;
&lt;li&gt;集合大小为 $m$；&lt;/li&gt;
&lt;li&gt;集合内不存在一个数是另一个数的倍数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;$m \le 3 \cdot 10^5,\ m \le n \le 2m$&lt;br&gt;&amp;emsp;&amp;emsp;$1 \le a_1 &amp;lt; a_2 &amp;lt; \cdots &amp;lt; a_n \le 2m$&lt;br&gt;&amp;emsp;&amp;emsp;2s&lt;/p&gt;</summary>
    
    
    
    <category term="OI/ACM" scheme="http://kqp.world/categories/OI-ACM/"/>
    
    
    <category term="算法_神奇的脑洞" scheme="http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>【AtCoder Grand 037D】Sorting a Grid 题解</title>
    <link href="http://kqp.world/%E3%80%90AtCoder%20Grand%20037D%E3%80%91Sorting%20a%20Grid%20%E9%A2%98%E8%A7%A3/"/>
    <id>http://kqp.world/%E3%80%90AtCoder%20Grand%20037D%E3%80%91Sorting%20a%20Grid%20%E9%A2%98%E8%A7%A3/</id>
    <published>2022-05-07T07:43:17.000Z</published>
    <updated>2022-05-07T08:09:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>&emsp;&emsp;给定一个 $n$ 行 $m$ 列的矩阵，里面的元素是 $1,\cdots,nm$ 每个恰好出现一次。依次执行以下操作：</p><ol><li>对每一行任意重排；</li><li>对每一列任意重排；</li><li>对每一行任意重排，</li></ol><p>使得最后矩阵第 $i$ 行第 $j$ 列恰好是 $i(m-1)+j$。输出一种方案（第 1 步和第 2 步后的结果）。可证明一定有解。</p><p>&emsp;&emsp;$n, m \le 100$<br>&emsp;&emsp;2s</p><span id="more"></span><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>&emsp;&emsp;一些简单的推导：把一个元素属于第几行（即除以 $m$ 上取整）叫做它的颜色。第 3 步对每一行重排，因此第 2 步结束后肯定是每个元素都去到了它所在的行，这时候每一列包含每种颜色恰好一个，这也是第 1 步要达成的效果。因此问题变成：每行重排，使得每列包含每种颜色恰好一个。<br>&emsp;&emsp;这时候就能嗅到匹配的味道了，但具体怎么匹配还是有点技巧。<br>&emsp;&emsp;题解给的做法是一列一列确定。建一个二分图，左边 $n$ 个点表示行，右边 $n$ 个点表示颜色，连边表示这一行有这种颜色。这个二分图是有完美匹配的（证明：Hall 定理，任取左边若干个点，它连向右边的点表示选取的行总共包含了多少种颜色，这不可能比行数少，不然就有颜色超过 $m$ 个了），把这个完美匹配拉出来作为第 1 列，剩下的变成 $(n,m-1)$ 的子问题了，因此总共做 $m$ 次二分图匹配就好了。</p><p>&emsp;&emsp;官方题解给的有完美匹配的证明似乎有点问题，它说二分图每个点的度数都是 $m$ 因此符合 Hall 定理，但这“度数为 $m$”是有重边的，不能直接应用 Hall 定理。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,a[maxn][maxn],b[maxn][maxn],br[maxn][maxn],c[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getr</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x)</span> </span>&#123;<span class="keyword">return</span> (x+m<span class="number">-1</span>)/m;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[maxn],bz[maxn];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Hung</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> tim)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bz[k]==tim) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">bz[k]=tim;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> go:e[k]) <span class="keyword">if</span> (!f[go] || <span class="built_in">Hung</span>(f[go],tim)) &#123;</span><br><span class="line">f[go]=k;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line"><span class="built_in">fo</span>(j,<span class="number">1</span>,m) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line"><span class="built_in">sort</span>(a[i]+<span class="number">1</span>,a[i]+<span class="number">1</span>+m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tm=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">fo</span>(j,<span class="number">1</span>,m) &#123;</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) e[i].<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line"><span class="built_in">fo</span>(k,j,m) <span class="keyword">if</span> (k==j || <span class="built_in">getr</span>(a[i][k])!=<span class="built_in">getr</span>(a[i][k<span class="number">-1</span>])) &#123;</span><br><span class="line"><span class="type">int</span> r=<span class="built_in">getr</span>(a[i][k]);</span><br><span class="line">e[i].<span class="built_in">push_back</span>(r);</span><br><span class="line">br[i][r]=k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">Hung</span>(i,++tm);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line"><span class="type">int</span> ii=f[i];</span><br><span class="line">b[ii][j]=a[ii][br[ii][i]];</span><br><span class="line">a[ii][br[ii][i]]=<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">sort</span>(a[ii]+<span class="number">1</span>,a[ii]+<span class="number">1</span>+m);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line"><span class="built_in">fo</span>(j,<span class="number">1</span>,m) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i][j]);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fo</span>(j,<span class="number">1</span>,m) &#123;</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) c[i]=b[i][j];</span><br><span class="line"><span class="built_in">sort</span>(c+<span class="number">1</span>,c+<span class="number">1</span>+n);</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) b[i][j]=c[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line"><span class="built_in">fo</span>(j,<span class="number">1</span>,m) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i][j]);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;给定一个 $n$ 行 $m$ 列的矩阵，里面的元素是 $1,\cdots,nm$ 每个恰好出现一次。依次执行以下操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对每一行任意重排；&lt;/li&gt;
&lt;li&gt;对每一列任意重排；&lt;/li&gt;
&lt;li&gt;对每一行任意重排，&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使得最后矩阵第 $i$ 行第 $j$ 列恰好是 $i(m-1)+j$。输出一种方案（第 1 步和第 2 步后的结果）。可证明一定有解。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;$n, m \le 100$&lt;br&gt;&amp;emsp;&amp;emsp;2s&lt;/p&gt;</summary>
    
    
    
    <category term="OI/ACM" scheme="http://kqp.world/categories/OI-ACM/"/>
    
    
    <category term="算法_网络流/匹配" scheme="http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BD%91%E7%BB%9C%E6%B5%81-%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>【CF1580E】Railway Construction 题解</title>
    <link href="http://kqp.world/%E3%80%90CF1580E%E3%80%91Railway-Construction-%E9%A2%98%E8%A7%A3/"/>
    <id>http://kqp.world/%E3%80%90CF1580E%E3%80%91Railway-Construction-%E9%A2%98%E8%A7%A3/</id>
    <published>2022-04-25T07:20:49.000Z</published>
    <updated>2022-04-25T09:11:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>&emsp;&emsp;给定一幅 $n$ 个点 $m$ 条边的带权无向图（权值表示距离），现在想要加一些单向边，权值自定（需是正整数），使得：</p><ul><li>从 $1$ 号点到每个点的最短路长度不变；</li><li>从 $1$ 号点到每个点都有至少两条点不相交的最短路径。</li></ul><p>&emsp;&emsp;新建一条从 $u$ 号点出发的单向边代价为 $w_u$。求最小代价。<br>&emsp;&emsp;以及有 $q$ 次修改操作，每次选择一个点 $k$ 把 $w_k$ 增加 $x$。</p><p>&emsp;&emsp;$n \le 2 \times 10^5,\ m \le 3 \times 10^5,\ q \le 2 \times 10^5$<br>&emsp;&emsp;$1 \le w_i \le 10^9$，初始边权 $d$ 满足 $1 \le d \le 10^9$，每次操作增加的代价 $x_i$ 满足 $1 \le x_i \le 4 \times 10^8$。<br>&emsp;&emsp;2.5s</p><span id="more"></span><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>&emsp;&emsp;<del>中国特色数据结构题</del></p><p>&emsp;&emsp;首先考虑无修改怎么做。这种情况的推导是自然流畅的：<br>&emsp;&emsp;原始图做了最短路之后可以得到一幅最短路图（只保留最短路边的 DAG），后面就都在这个最短路图上讨论了。稍加观察可以发现，如果一个点的入度至少为 $2$，那么当它的前驱满足了“至少有两条点不相交的最短路径”之后，它也会自然满足这个条件。简单证明：如下图，对于点 $x$，假设它有前驱 $y$ 和 $z$，其中 $y$ 不是 $z$ 的必经点（否则交换 $y$ 和 $z$），$y$ 有两条点不相交的最短路径 $p_1,p_2$。任取一条从 $1$ 到 $z$ 不经过 $y$ 的路径，假设最后与 $p_1,p_2$ 交在点 $v$，那么 $1 \to p_1 \to y \to x$ 和 $1 \to p_2 \to v \to z \to x$ 就是 $x$ 的两条点不相交的最短路。<br><img src="/images/cf1580e.png" alt=""><br>&emsp;&emsp;这样一来，就只有最短路图上入度为 $1$ 的点是需要关注的关键点了。对于每个关键点，当然是在最短路长度 $dis$ 比它小的点里找 $w$ 最小的连过来了（这样就能使它入度 $&gt;1$ 了），但如果这个点是它的直接父亲且不为 $1$，那就要找 $w$ 次小的了。<br>&emsp;&emsp;所以无修改的版本就是把点按 $dis$ 排序，每个点在前面找 $w$ 的最小和次小。</p><p>&emsp;&emsp;带修改就有点米奇妙妙屋了。<br>&emsp;&emsp;首先倒序处理操作，把增加代价变成减少代价，要好做些，因为增加代价是把最小值和次小值分散出去，而减少代价是把最小值和次小值聚集过来。<br>&emsp;&emsp;这里的分段现象比较明显（连续一段数最(次)小值值相同），考虑用 set 维护这些段，用 $S_1$ 维护最小值相同的连续段及段内需要使用最小值的关键点数量，用 $S_2$ 维护次小值相同的连续段及段内需要使用次小值的关键点数量。当减小点 $k$ 的代价 $w_k$ 时，从第一个 $&gt;dis_k$ 的点开始，先修改 $S_1$，即把最小值 $&gt;w_k$ 的段合并起来并且把这个原最小值变为次小值丢到 $S_2$ 里；再修改 $S_2$，即把次小值 $&gt;w_k$ 的段合并起来。维护关键点数量需要 lower_bound 之类的求一个节点在一个区间内的儿子数量，用关键点数量就可以维护答案了。<br>&emsp;&emsp;分析一下时间复杂度。初始每个 set 最多有 $n$ 个段，每次修改操作，可能要在初始位置把一个段给断开（即新增一个段）。对于 $S_1$，剩下的就都是合并操作了，所以总段数是 $O(n+q)$ 的，复杂度 $O((n+q) \log (n+q))$。对于 $S_2$，还会在更新最小值的时候产生次小值的新段，但每个最小值段最多只会贡献一个次小值段（贡献完它就被合并了），所以总段数仍然是 $O(n+q)$ 的，复杂度 $O((n+q) \log (n+q))$。</p><p>&emsp;&emsp;注意，有一种写法是按“最小值与次小值都相同”对序列分段，只用一个 set。这个复杂度是不对的，如果有很多很多段，这些段的最小值相同，次小值不同，而每次操作都把这个最小值再减小，那就每次操作都要把这些段都遍历一遍了。</p><p>&emsp;&emsp;注意一些细节，比如如果最小值次小值记录的是节点标号而不是具体的值，就要注意最小值来源不变但值减少了的情况；比如答案会爆 long long，要 unsigned long long。</p><h2 id="扯淡"><a href="#扯淡" class="headerlink" title="扯淡"></a>扯淡</h2><p>&emsp;&emsp;可能可以把一些 set 操作换成线段树？就像题解写的那样。</p><p>&emsp;&emsp;比较搞笑的是，在我本地拍的时候，上面说的“只用一个 set 维护最小值和次小值都相同的段”的写法跑得比分开两个 set 的写法还要快。。。不过前者交上去就 T 了。<br>&emsp;&emsp;（并且在拍的过程中还卡 T 了一个跑得飞快的老哥。。。可惜现在不能 hack 了 QAQ</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>// 实现细节比较多，修修补补会变得特别丑，建议少看（x</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,a,b) for(int i=a;i&gt;=b;i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">2e5</span>+<span class="number">5</span>, maxq=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SEG</span> &#123;</span><br><span class="line"><span class="type">int</span> l,r,minw,num;</span><br><span class="line"><span class="built_in">SEG</span>(<span class="type">int</span> l0,<span class="type">int</span> r0,<span class="type">int</span> minw0,<span class="type">int</span> num0) &#123;l=l0, r=r0, minw=minw0, num=num0;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> SEG &amp;a,<span class="type">const</span> SEG &amp;b) &#123;<span class="keyword">return</span> a.r&lt;b.r;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,q,qk[maxq],qx[maxq];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; e[maxn];</span><br><span class="line">ULL w[maxn];</span><br><span class="line"></span><br><span class="line">LL dis[maxn];</span><br><span class="line"><span class="type">int</span> d[maxn],d0;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dis,<span class="number">127</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">priority_queue&lt;pair&lt;LL,<span class="type">int</span>&gt;&gt; Q;</span><br><span class="line">Q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0ll</span>,<span class="number">1</span>));</span><br><span class="line"><span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">auto</span> tp=Q.<span class="built_in">top</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">int</span> cur=tp.second;</span><br><span class="line"><span class="keyword">if</span> (-tp.first!=dis[cur]) <span class="keyword">continue</span>;</span><br><span class="line">d[++d0]=cur;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> go:e[cur]) <span class="keyword">if</span> (dis[go.first]&gt;dis[cur]+go.second) &#123;</span><br><span class="line">dis[go.first]=dis[cur]+go.second;</span><br><span class="line">Q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-dis[go.first],go.first));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; son[maxn];</span><br><span class="line">set&lt;SEG&gt; S1,S2;</span><br><span class="line"><span class="type">int</span> indg[maxn],fa[maxn],st[maxn],keynum[maxn];</span><br><span class="line">ULL ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> go:e[i]) <span class="keyword">if</span> (dis[i]+go.second==dis[go.first]) &#123;</span><br><span class="line">indg[go.first]++;</span><br><span class="line">fa[go.first]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SEG <span class="title">min1</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>)</span>, <span class="title">min2</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(st,<span class="number">127</span>,<span class="built_in">sizeof</span>(st));</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">2</span>,n) &#123;</span><br><span class="line"><span class="type">int</span> cur=d[i];</span><br><span class="line"><span class="type">int</span> minw1=min1.minw, minw2=min2.minw;</span><br><span class="line"><span class="keyword">for</span>(; j&lt;=n &amp;&amp; dis[d[j]]&lt;dis[cur]; j++) &#123;</span><br><span class="line">st[d[j]]=i;</span><br><span class="line"><span class="keyword">if</span> (w[d[j]]&lt;w[minw1]) minw2=minw1, minw1=d[j];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (w[d[j]]&lt;w[minw2]) minw2=d[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (minw1!=min1.minw || minw2!=min2.minw) &#123;</span><br><span class="line"><span class="keyword">if</span> (min2.l&lt;=min2.r) S2.<span class="built_in">insert</span>(min2);</span><br><span class="line">min2=<span class="built_in">SEG</span>(min2.r+<span class="number">1</span>,i,minw2,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (minw1!=min1.minw) &#123;</span><br><span class="line"><span class="keyword">if</span> (min1.l&lt;=min1.r) S1.<span class="built_in">insert</span>(min1);</span><br><span class="line">min1=<span class="built_in">SEG</span>(min1.r+<span class="number">1</span>,i,minw1,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">keynum[i]=keynum[i<span class="number">-1</span>]+(indg[cur]==<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (indg[cur]==<span class="number">1</span>) &#123;</span><br><span class="line">son[fa[cur]].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">if</span> (fa[cur]!=<span class="number">1</span> &amp;&amp; fa[cur]==minw1) &#123;</span><br><span class="line">min2.num++;</span><br><span class="line">ans+=w[minw2];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">min1.num++;</span><br><span class="line">ans+=w[minw1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">min1.r=min2.r=i;</span><br><span class="line">&#125;</span><br><span class="line">S1.<span class="built_in">insert</span>(min1);</span><br><span class="line">S2.<span class="built_in">insert</span>(min2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> minw)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (minw==<span class="number">1</span>) ?<span class="number">0</span> :<span class="built_in">upper_bound</span>(son[minw].<span class="built_in">begin</span>(),son[minw].<span class="built_in">end</span>(),r)-<span class="built_in">upper_bound</span>(son[minw].<span class="built_in">begin</span>(),son[minw].<span class="built_in">end</span>(),l<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cut_cur</span><span class="params">(set&lt;SEG&gt; &amp;S,<span class="type">int</span> pos,<span class="type">int</span> ty)</span> </span>&#123;</span><br><span class="line">set&lt;SEG&gt;::iterator it=S.<span class="built_in">lower_bound</span>(<span class="built_in">SEG</span>(<span class="number">0</span>,pos,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line"><span class="keyword">if</span> (it==S.<span class="built_in">end</span>() || it-&gt;l==pos) <span class="keyword">return</span>;</span><br><span class="line">SEG t=*it;</span><br><span class="line">S.<span class="built_in">erase</span>(it);</span><br><span class="line"><span class="keyword">if</span> (ty==<span class="number">1</span>) &#123;</span><br><span class="line">S.<span class="built_in">insert</span>(<span class="built_in">SEG</span>(t.l, pos<span class="number">-1</span>, t.minw, keynum[pos<span class="number">-1</span>]-keynum[t.l<span class="number">-1</span>]-<span class="built_in">get_num</span>(t.l,pos<span class="number">-1</span>,t.minw)));</span><br><span class="line">S.<span class="built_in">insert</span>(<span class="built_in">SEG</span>(pos, t.r, t.minw, keynum[t.r]-keynum[pos<span class="number">-1</span>]-<span class="built_in">get_num</span>(pos,t.r,t.minw)));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">S.<span class="built_in">insert</span>(<span class="built_in">SEG</span>(t.l, pos<span class="number">-1</span>, t.minw, <span class="built_in">get_num</span>(t.l,pos<span class="number">-1</span>,(S1.<span class="built_in">lower_bound</span>(<span class="built_in">SEG</span>(<span class="number">0</span>,t.l,<span class="number">0</span>,<span class="number">0</span>)))-&gt;minw)));</span><br><span class="line">S.<span class="built_in">insert</span>(<span class="built_in">SEG</span>(pos, t.r, t.minw, <span class="built_in">get_num</span>(pos,t.r,(S1.<span class="built_in">lower_bound</span>(<span class="built_in">SEG</span>(<span class="number">0</span>,pos,<span class="number">0</span>,<span class="number">0</span>)))-&gt;minw)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ULL Ans[maxn],w_old[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">LL x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x);</span><br><span class="line">w[i]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,m) &#123;</span><br><span class="line"><span class="type">int</span> u,v,d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;u,&amp;v,&amp;d);</span><br><span class="line">e[u].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(v,d)), e[v].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(u,d));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,q) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;qk[i],&amp;qx[i]);</span><br><span class="line">w[qk[i]]+=qx[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dijkstra</span>();</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(w_old,w,<span class="built_in">sizeof</span>(w));</span><br><span class="line"><span class="built_in">fd</span>(i,q,<span class="number">1</span>) &#123;</span><br><span class="line">Ans[i]=ans;</span><br><span class="line"><span class="type">int</span> cur=qk[i];</span><br><span class="line">w[cur]-=qx[i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">cut_cur</span>(S1,st[cur],<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cut_cur</span>(S2,st[cur],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// minw1</span></span><br><span class="line"><span class="type">int</span> tl=st[cur], tr=tl<span class="number">-1</span>, tnum=<span class="number">0</span>;</span><br><span class="line">set&lt;SEG&gt;::iterator it=S1.<span class="built_in">lower_bound</span>(<span class="built_in">SEG</span>(<span class="number">0</span>,tl,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line"><span class="keyword">while</span> (it!=S1.<span class="built_in">end</span>() &amp;&amp; w[cur]&lt;w_old[it-&gt;minw]) &#123;</span><br><span class="line">SEG t=*it;</span><br><span class="line"><span class="keyword">if</span> (t.minw==cur) &#123;</span><br><span class="line">ans-=(ULL)t.num*qx[i];</span><br><span class="line">it++;</span><br><span class="line">tl=t.r+<span class="number">1</span>, tr=t.r;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans-=t.num*w_old[t.minw];</span><br><span class="line">S1.<span class="built_in">erase</span>(it++);</span><br><span class="line">set&lt;SEG&gt;::iterator it2=S2.<span class="built_in">lower_bound</span>(<span class="built_in">SEG</span>(<span class="number">0</span>,t.l,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line"><span class="keyword">while</span> (it2!=S2.<span class="built_in">end</span>() &amp;&amp; it2-&gt;l&lt;=t.r) &#123;</span><br><span class="line">ans-=w_old[it2-&gt;minw]*it2-&gt;num;</span><br><span class="line">S2.<span class="built_in">erase</span>(it2++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> num=<span class="built_in">get_num</span>(t.l,t.r,cur);</span><br><span class="line">ans+=w[t.minw]*num;</span><br><span class="line">S2.<span class="built_in">insert</span>(<span class="built_in">SEG</span>(t.l,t.r,t.minw,num));</span><br><span class="line">tnum+=keynum[t.r]-keynum[t.l<span class="number">-1</span>]-num;</span><br><span class="line">tr=t.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tl&lt;=tr) &#123;</span><br><span class="line">ans+=tnum*w[cur];</span><br><span class="line">S1.<span class="built_in">insert</span>(<span class="built_in">SEG</span>(tl,tr,cur,tnum));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// minw2</span></span><br><span class="line">tl=tr+<span class="number">1</span>;</span><br><span class="line">tnum=<span class="number">0</span>;</span><br><span class="line">it=S2.<span class="built_in">lower_bound</span>(<span class="built_in">SEG</span>(<span class="number">0</span>,tl,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line"><span class="keyword">while</span> (it!=S2.<span class="built_in">end</span>() &amp;&amp; w[cur]&lt;w_old[it-&gt;minw]) &#123;</span><br><span class="line">tr=it-&gt;r;</span><br><span class="line">tnum+=it-&gt;num;</span><br><span class="line">ans-=it-&gt;num*w_old[it-&gt;minw];</span><br><span class="line">S2.<span class="built_in">erase</span>(it++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tl&lt;=tr) &#123;</span><br><span class="line">ans+=tnum*w[cur];</span><br><span class="line">S2.<span class="built_in">insert</span>(<span class="built_in">SEG</span>(tl,tr,cur,tnum));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">w_old[cur]-=qx[i];</span><br><span class="line">&#125;</span><br><span class="line">Ans[<span class="number">0</span>]=ans;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">0</span>,q) <span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span>,Ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;给定一幅 $n$ 个点 $m$ 条边的带权无向图（权值表示距离），现在想要加一些单向边，权值自定（需是正整数），使得：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从 $1$ 号点到每个点的最短路长度不变；&lt;/li&gt;
&lt;li&gt;从 $1$ 号点到每个点都有至少两条点不相交的最短路径。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;新建一条从 $u$ 号点出发的单向边代价为 $w_u$。求最小代价。&lt;br&gt;&amp;emsp;&amp;emsp;以及有 $q$ 次修改操作，每次选择一个点 $k$ 把 $w_k$ 增加 $x$。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;$n \le 2 \times 10^5,\ m \le 3 \times 10^5,\ q \le 2 \times 10^5$&lt;br&gt;&amp;emsp;&amp;emsp;$1 \le w_i \le 10^9$，初始边权 $d$ 满足 $1 \le d \le 10^9$，每次操作增加的代价 $x_i$ 满足 $1 \le x_i \le 4 \times 10^8$。&lt;br&gt;&amp;emsp;&amp;emsp;2.5s&lt;/p&gt;</summary>
    
    
    
    <category term="OI/ACM" scheme="http://kqp.world/categories/OI-ACM/"/>
    
    
    <category term="算法_图论" scheme="http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="算法_平衡树/set" scheme="http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%B9%B3%E8%A1%A1%E6%A0%91-set/"/>
    
  </entry>
  
  <entry>
    <title>偶像作品衍生的美学文学哲学 open problems</title>
    <link href="http://kqp.world/%E5%81%B6%E5%83%8F%E4%BD%9C%E5%93%81%E8%A1%8D%E7%94%9F%E7%9A%84%E7%BE%8E%E5%AD%A6%E5%93%B2%E5%AD%A6%20open%20problems/"/>
    <id>http://kqp.world/%E5%81%B6%E5%83%8F%E4%BD%9C%E5%93%81%E8%A1%8D%E7%94%9F%E7%9A%84%E7%BE%8E%E5%AD%A6%E5%93%B2%E5%AD%A6%20open%20problems/</id>
    <published>2022-04-10T08:33:05.000Z</published>
    <updated>2022-05-05T04:08:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;其实偶像作品中也有很多很有趣的美学、哲学、艺术问题可以思考。我逐渐觉得我应该再修一个艺术理论的学位，去读一些书。<br>&emsp;&emsp;<del>博客逐渐变成了奇怪的形状</del></p><span id="more"></span><p>&emsp;&emsp;现在还只是一个理工科学生道听途说了一些美学、哲学概念，然后胡乱做一些思考罢了，书和 paper 也没读过多少。毕竟不是专业，不知道能消耗多少时间在这上面，只能是说读了更多的书和 paper 以后慢慢修正。</p><h2 id="美的创作过程的分离与异化"><a href="#美的创作过程的分离与异化" class="headerlink" title="美的创作过程的分离与异化"></a>美的创作过程的分离与异化</h2><h3 id="一个较长的-intro"><a href="#一个较长的-intro" class="headerlink" title="一个较长的 intro"></a>一个较长的 intro</h3><p>&emsp;&emsp;3 月 3 号 liella 的生放谈了一专里每一个人的 solo，香音那首比较独特，主要是歌词，初读可以说怪得很，不知道什么原因就对着一个人说大嫌い，一整首歌都在讨厌你讨厌你，却又在结尾的时候突然变成大好き了，很难懂的感情。这场生放里小百合似乎是给出了解释，不过我没有听懂生肉，结合弹幕的同传师爷和其他人的表现，看上去是小百合给出了深层次的解读，并不是浮于歌词表面的样子。<br>&emsp;&emsp;所以今天就想要补这场熟肉，想要更好地理解这首歌。然而，却发现小百合并不是在解释歌词内涵，她讲了一堆与此不太相关的东西。她首先提到这个“君”可能不是人类，可以理解成一个香音最喜欢的人，但也说“一千个观众有一千个‘君’”，具体她的理解没有明说。她说以前读了歌词然后按自己的理解唱，但这次行不通，这跟香音的风格差了太多，需要主动走进香音。她说巡演期间录的歌，正好对唱歌思考了很多。她说不是单纯地歌唱低落，不是悲しみ，不是切ない。总之说了一通，大概就是两个重点，一我确乎没有明白这个“君”到底是谁，香音为什么对他大嫌い，又为什么突然转成了大好き；二是小百合明白了吗，不知道，她只是给出了自己的解答。<br>&emsp;&emsp;所以这个出新歌的过程是这样的，作曲人、作词人把作品交给小百合，小百合开始做阅读理解，然后交上一份答卷。答得对不对呢？小百合自己也说，以前就不太管，香音不这么理解但是小百合这么理解的。所以我们说我们在欣赏一首歌的时候，我们到底在欣赏什么呢？欣赏歌曲的旋律，这是对作曲人的；欣赏歌词的文学艺术，这是对作词人的。那么小百合是什么呢？一个发声工具，和一个做阅读理解的考生。那么到底谁才是涉谷香音呢？不是小百合了。<br>&emsp;&emsp;LoveLive 毕竟是偶像企划，绝大多数歌曲其实表意很清晰，没什么能过多分析的。比如“僕らの勢いは四方八方九方”，这种歌词也没法存在第二种解读，结合水水的经历，声优们就能跟作词达成共识，很容易就能把这个内涵表达出来了。这个时候，Aqours 和声优 Aqours 是站在一起的。但是像这次，或者以后作词人还想在歌词中表达些什么更深刻的，更隐晦一点的，那么歌曲、声优、角色就全都分离开了。<br>&emsp;&emsp;记得去年读了一本讲美学和美育的哲学书，里面就提到了美的创作的异化。以前是由创作主体完成整个美的创作过程，因此在过程中主体完成了审美，而现在这个创作过程是分离的，造成审美也是破碎的。一首现代歌曲的作曲、作词、演唱的分离恰恰是此书里的例子，歌手很难把自己的感情、经历等审美要素代入这首歌，因为这首歌压根就不是他参与创作的。<br>&emsp;&emsp;所以尽管小百合很用力去研究香音唱这首歌的心境，总是听着少了真情实感。以前咻卡也这样，夜空知晓一切的现场版也这样，只是在用一些歌唱技巧去制造低落、伤感的情绪，很容易用力过猛，然后变得假起来。在这个过程中她们本应是讲故事的人，但现在只是转述故事的人，这个故事就不是她们的故事。<br>&emsp;&emsp;难免还是要对如今的商业模式做出思考。当然，作词作曲演唱这三者的分离是不可避免的，不这么分化大家都得饿死。但是，如果一味迁就，那就会让偶像的意义越发模糊。要我提出观点的话，我认为偶像本身应该参与创作，至少，作词和偶像应当有一个合作与交流，让歌词成为共同完成的作品，从而得到文学、角色人设、演出者生活经历三者的结合。<br>&emsp;&emsp;回到这首歌本身，最好的解读还是来信里提到的，开始是对歌唱的讨厌，歌唱带给了她不好的经历，但触及心底，发现对于歌唱还是要说热爱。我们所希望的是，这是香音的想法，香音怀着这份心情唱了出来，而不是香音看了别人寄给她的稿子想到了这些然后唱了出来。</p><h2 id="创作与观众的关系"><a href="#创作与观众的关系" class="headerlink" title="创作与观众的关系"></a>创作与观众的关系</h2><p>&emsp;&emsp;虹第二季第二话 Q4 劝岚珠的场景，体现了两种不同的表演理念的冲突。发现这也是我思考的一个问题：表演者应该为自己而创作，还是为粉丝而创作？<br>&emsp;&emsp;这是两种不同的追求。一种是追求艺术本身的，我是为了歌唱，舞蹈，我的艺术理念，展现自我的风格，所以来表演，我不是为了在观众这里获得人气和支持。而一种是我希望带给粉丝一些东西，比如欢乐，感动，坚定的信念，传递各种気持ち，我希望能与观众产生共鸣。<br>&emsp;&emsp;Lovelive 的定位是后者，是偶像和粉丝一起完成的企划，粉丝投票选出了 c 位，选出了歌词中的关键词，选衣服，选一堆东西，所以歌曲也和粉丝结合得很紧密，总是要君と一緒に这样的。所以如果在这些特定的企划里寻找答案，那几乎是唯一的。但相比起来，也正如岚珠所说，前者是更加随心所欲的，它可以在创作上更纯粹，因为审美主体很大程度被创作者选择了，就是自己这一类的主体。<br>&emsp;&emsp;当然岚珠很可能会走到一个矛盾里，她固然是需要受众的，而且是广泛的受众，因为她的目标学园偶像，到底有没有纯粹的表现自我的学园偶像呢？可能这就不是学园偶像的定义了。<br>&emsp;&emsp;但是抛开学园偶像这个追求和身份，这就是艺术和观众的联系问题了。尽管在一定的哲学体系下，这已经是一个相当成熟的问题了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;其实偶像作品中也有很多很有趣的美学、哲学、艺术问题可以思考。我逐渐觉得我应该再修一个艺术理论的学位，去读一些书。&lt;br&gt;&amp;emsp;&amp;emsp;&lt;del&gt;博客逐渐变成了奇怪的形状&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="杂写" scheme="http://kqp.world/categories/%E6%9D%82%E5%86%99/"/>
    
    
  </entry>
  
  <entry>
    <title>Aqours 6th 巨蛋收集计划</title>
    <link href="http://kqp.world/Aqours-6th-dome-collection/"/>
    <id>http://kqp.world/Aqours-6th-dome-collection/</id>
    <published>2022-02-14T02:25:56.000Z</published>
    <updated>2022-11-18T07:44:35.555Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;继“Aqours 东蛋之路”后，现在差不多可以开始起草“Aqours 蛋巡之路”了。。。</p><span id="more"></span><p>&emsp;&emsp;2020初宣布五蛋巡，本以为一路顺利在人气巅峰创下声优偶像最高成就，却因为疫情，一度将近两年开不了9人 live。起起落落，开开停停，一路上不断有 live 开催又延期又终止。最终勉强把两次小组 live 开起来（说勉强是因为缺了老王），在声优的请求下开了 dreamy concert，逢田姐甚至直言：“两年不开 live，粉丝都掉了一大半。”五蛋巡被迫向疫情屈服，只剩下两个蛋（UPD：三个了），千言万语汇成一句话：蛋巡尚未成功，同志仍需努力。</p><h3 id="Ocean-Stage"><a href="#Ocean-Stage" class="headerlink" title="Ocean Stage"></a>Ocean Stage</h3><p>&emsp;&emsp;Ocean Stage Day1 在开学前，学校吃土群组织不起来，只能是去广州转播场。这次是跟漫展认识的雪雪人以及贴吧网友萤火虫 staff 一起。对于广州大场的印象就是虎上加虎，果不其然，这次又见到了经典熟悉的“南方灯光展”“南方动物园”，仿佛回到了两年前的南方剧院里的 5th。</p><p>&emsp;&emsp;而这场 6th，也无处不渗透着 5th 的气息。<br>&emsp;&emsp;不会想到在开场听到 hop stop nonstop，气氛一下就回到了 5th 的剧场版主题了。接连几首动画曲也在告诉大家，动画曲和剧场版曲不是某些数字 live 独有的，以后总会源源不断地听到。姐姐那句俏皮可爱的“デキナカッタコトガデキタリ”仍然使得全场爆发。<br>&emsp;&emsp;天花板上 kurukuru 的那条龙，像个吊死鬼一样飘着。<br>&emsp;&emsp;一二年级分别唱完以后，仍在猜测三年级会唱哪一首，是特典还是剧场版，然而音乐一响，居然是鞠南的泪水化为雪花。明显感受到整个观众席都虎躯一震。这是冬 2223 的第一次现场表演，鞠南的 CD 唱功（sww是没开麦呢还是神速进步了呢？）、高虐拥抱；曜梨的贵妇服装、专业舞蹈、白学对视、奇卡背景；花露的活泼欢快、sif 音效；宫林波的手捧白碟、认真过节、情人节礼物，实在是尽显特色。<br>&emsp;&emsp;两个幕间都是没内容的金曲 medley，十分敷衍。<br>&emsp;&emsp;接下来小姐姐们穿着私服出场了，几位时尚达人（喵香王）的衣服很漂亮，杏似乎是比较保守的。私服打了海盗、白日梦、君瞳三首热气氛的歌，效果非常好，甚至有韩舞的感觉，咻卡抡大旗的动作似乎改了，改得更魅惑了。然而往下的几首动画曲，穿着私服跳，味道却是不对的，水族馆的ゆらゆら的动作非得穿二单服才有鱼的感觉，水蓝没有了脱衣服也丢掉了朝向新世界的寓意。后来换回了 op1 的衣服是挺好的（据说还改新了，增加了亮片），咻卡的样貌回到了 18 年，想起了鲤鱼锐评 op1 袜子。<br>&emsp;&emsp;live 前流传出了彩虹光路企划，果然，安可一开始，彩虹就形成了。这就像是对逢田姐的回应，时隔两年，彩虹仍在，粉丝一个没跑。广播曲一出场，爱爱直接泪目，显然也是被 surprise 了。彩虹让人感受到 LoveLive 的确是一个双向企划，台上的人能让台下的人哭，台下的人也能让台上的人哭。<br>&emsp;&emsp;广州场的观众席也形成了短暂的彩虹，只可惜拍完照就散了。<br><img src="/Aqours-6th-dome-collection/rainbow1.jpg" class=""><br><img src="/Aqours-6th-dome-collection/rainbow2.jpg" class=""></p><p>&emsp;&emsp;回想自己，头一次对 live 产生向往，也是在贴吧云 5th 的时候，看到了彩虹，从而十分强烈地想要成为彩虹一员。两年后，正好是下一场数字 live，在 live viewing 里短暂地成为了彩虹，我们的心意，一定要届过去啊。<br>&emsp;&emsp;水水经历了十分艰难的两年，我们都能感受到。运营其实不容易，谁不想等疫情稳一点憋一个大招呢？毕竟是要冲蛋巡的呀。小场也不能开太多，因为 live 的安排还要匀给正在冉冉上升的虹和星，要租场地，要考虑粉丝们的钱包。这场 6th 显然也是硬开的，东京疫情爆炸了，整个霓虹声优界一个一个开盲盒似的感染，台下观众席也不知道藏有什么狼虫虎豹。疫情之下没有完美的决策，只有胆战心惊的博弈。<br>&emsp;&emsp;只不过逢田姐不用再担心粉丝跑掉了，彩虹就是最好的证明。</p><h3 id="Sunny-Stage"><a href="#Sunny-Stage" class="headerlink" title="Sunny Stage"></a>Sunny Stage</h3><p>&emsp;&emsp;有空补。</p><p>&emsp;&emsp;曲目编排结构跟 Ocean Stage 基本一致，就是把 2223 换成了生日专 1，因此亮点大概就是 AAO 和大新闻重回东蛋了。<br>&emsp;&emsp;然后你水现在似乎是超级求稳策略，动不动就关麦放 CD。。。好听是好听了，车祸是少了，不是 live 了。</p><h3 id="Windy-Stage"><a href="#Windy-Stage" class="headerlink" title="Windy Stage"></a>Windy Stage</h3><p>&emsp;&emsp;宣布重回东蛋以来，其实很快讨论度就没了，因为虹Ⅱ高质量播出，星团低质量加人，焦点都在后辈。重新让大家动员起来，应该是将近 5 月底，全国民间观影组织再次联动，大约 10 多个城市有组织观影，还制作联动谷子。吃土群水厨日渐稀少，加之 live 日期在考试周前，组织不起来，最终与萤火虫 staff 桑与雪雪单推哥一起去 day1 大场，家里蹲白嫖 day2。<br>&emsp;&emsp;本来还是比较担心的，毕竟加藤达也带着交响乐团来了，很高雅的，如果叠上“南方灯光展”“南方动物园”的 buff 那可就全毁了。但出乎意料地，这次灯光和 mix 氛围比军 call 还好，待会要好好夸夸他们。</p><p>&emsp;&emsp;作为 6th 的句号，两天下来，算是对得起东蛋了，亮点很多，当然槽点也有，据贴吧大佬分析上座率还挺高，动员人数挺多。最重要的，它的意义太多了，它是疫情以来的一个总结，加上 day2 大新闻，它又铺开了水水乃至企划的新的未来。</p><p>&emsp;&emsp;先从 live 本身讲起。这次的曲目编排没有那么模块化了，所以很难记流水了，就发散一点讲吧。<br>&emsp;&emsp;加藤达也手一挥，水水战歌起，两个篇章向角色打完招呼，小姐姐已经站上台，这样的开场，最令人激动。<br>&emsp;&emsp;开场的服装很华丽，是根据主视图来做的，整体造型非常优雅，布料看上去很好。虽然颜色是偏离了主视图的（主视图的衣服略带黄色，看上去有 ns 的感觉），实际选择了纯白色，不过这样也能给人以纯洁之感。<br>&emsp;&emsp;MC 的欢迎辞，就是通常会喊的「皆さん、こんばんは」，这次改成了「皆さん、ただいまー」。都是张开双臂大声喊出来的，喜悦溢于言表。我们在下面喊「お帰り」也是一样的，这心情，真的何异于老友重逢呢？<br>&emsp;&emsp;新歌很多，特别多，两天加起来大概把后疫情时代（以现在为基准）正经的都翻出来唱了。跟 Ocean 和 Sunny 差别很大，Windy 两天的差别也很大。之前有表统计已发售但未在 live 演唱的歌曲，现在应该是把这个表清空了，就连 a to z、ing i try 这样的都吐出来了（anju 自己都吐槽这歌埋了 3 年。。。）。当然还有一个表，是未上过数字 live 的歌，这个还没清空，但也有在清了，像 4 单，fes 首秀之后等上 Aqours 专场等到今天，喷蝴蝶好评。然后动画曲，6th 加上前面几次 live，也差不多把动画（TV+剧场）中的关键曲目都滚了一遍了，剧场版曲甚是。<br>&emsp;&emsp;加藤达也带着乐团来，当然也是亮点了。这次乐团相比 4th 可是辛苦了不少，参与的曲目多得多。从转播的体验来说，乐团伴奏跟播放伴奏效果是差不多的，但是乐团对幕间体验的提升那就太大了，尤其是在 Ocean 和 Sunny 幕间还特别敷衍的衬托下。乐队投票曲是心羽君飞和奇迹闪耀不错，真的是奇迹再现了。加藤真的活泼，也扮小恶魔，也用手指指人。<br>&emsp;&emsp;唱了生日专 2，各自有特色。anju 的鞋全场最高，这么细高的高跟鞋蹦蹦跳跳真的吓人，原以为水的鞋子是打算一直保守下去的（水一直都是运动鞋底，虹有小皮鞋，青山姐直接上芭蕾舞鞋），看来水的鞋子也要突破了；逢田姐的舞蹈加了色气的动作，尽显工口梨本色；姐姐的歌旋律很像《一百万个可能》，然后发力比较柔弱，是大和抚子、绝世美人；sww。。。你开心就好，唱到高音还唱断了只剩垫音；王弹吉他；咻卡活力；kyan 偷跑新歌，背景翅膀超帅。<br>&emsp;&emsp;唱功整体有进步，体力和音准比以往的观感好多了，sww在团歌中不再那么突出了。因为设备不好，判断不了这次哪些有垫音哪些是假唱，反正水水一如既往采用稳如老狗策略，真实不真实不知道，总之观感好。<br>&emsp;&emsp;我一定要夸夸这次广州场的 call 啊！！我坐在右后角落，看下去上举、快挥、特殊动作都是非常整齐的，厄的时候连风火轮都非常整齐！屏幕前几个大闪风火轮领头，前半场和两边的蓝色白色风火轮，后排零星几个风火轮，转起来的时候整齐划一，而且因为是官棒官色没有光污染，比军 call 壮观得多。所以说这东西，不整齐是厄介是光害，整齐了、颜色亮度正常了就是光路企划了。可惜没有拍照。不过高速拍掌一定是一个坏文明。ns 因为不在最后，不需要那么感动，所以拉 mix 反而很合适（？<br>&emsp;&emsp;day 2 最后来了时隔近 4 年的二次返场。不过感情基调不一样了，4th 是感谢与不舍，这次是激动与对未来的憧憬。</p><p>&emsp;&emsp;最大的问题应该在于选曲。一是关联性，虽然新歌和金曲很多，但是拼凑感较强，如贴吧评论“网易云心动模式都比这个好”，而且这是个老问题，4th 也被吐槽了。这种 live 没有动画做主题，因此要把握整体感和关联性是比较难的，何况还有投票曲等不可控因素，但实际上歌曲各自有感情，幕间加一点引导，从感情上把歌曲都串起来，应是可以做到的。二是非团曲曲目选择，Ocean 是 2223，Sunny 是 solo，那么顺理成章这次就是小组了，结果又是 solo。在生日专质量普遍偏低的情况下，小组有高质量曲不上，又要藏到不知什么时候。很期待 AAA 三人的凤凰舞。三是顺序，这也是感情关联性把握不好的一个原因。最突出的就是 ns 了，ns 的位置很突兀，本身情感是偏向高毒的，适合后置，而甚至动作都没改，唱到半场挥手了（这本来是 5th 结尾时向大家挥手的），唱到最后都跑了（就一种要安可的味道）。只能以后面接 ing i try 稍作解释，从“一二年级 -&gt; 三年级”到“三年级 -&gt; 一二年级”，就是 Aqours 特别是三年级又回来了的感觉。<br>&emsp;&emsp;第二大问题在于导播。一是个人特写占比太高，全团镜头和全场镜头又少又糟糕。东蛋的宏大没有拍出来，团曲 9 人整齐的动作和团体舞蹈效果没有拍出来，舞台走位没有拍出来，观众应援没有拍出来。day2 开头至少把长长的屏幕拍进来了（我才知道原来舞台布局都换了），结果这个优秀导播马上就离开了。二是个人特写切换也不及时，day1 狂拍不唱歌不说话的成员，互动也漏掉很多。<br><img src="/Aqours-6th-dome-collection/screen1.png" class=""><br><img src="/Aqours-6th-dome-collection/screen2.png" class=""><br>&emsp;&emsp;然后是舞台利用度低了很多。东蛋这么大，舞台也不止一个，但是表演场地太局限了，大部分主舞台，少量中心舞台，几趟花车，移动不丰富，很是浪费。参考 4th 和缪的 FL，移动量都很大，4th 的圣诞歌是在主舞台向中心舞台的走道上进行的舞蹈动作，这利用率一下子就上去了。<br>&emsp;&emsp;剩下就是一些小问题了，“僕らの勢いは四方八方九方”这最有气势的词，应该更用力些，把气势更加发挥出来。くるるん始终像个被小孩不小心放飞的氢气球。</p><p>&emsp;&emsp;总的来说，从曲目选择上，从歌单清理上，整一个 6th 巡演就像是对 5th 以后疫情以来的一个大总结。这一段空窗期熬过去了，这段时间的努力和精彩也都展现出来了。<br>&emsp;&emsp;因此也就来到了本场 live 最万众瞩目的一环：象征未来的大新闻。<br><img src="/Aqours-6th-dome-collection/yohane1.png" class=""><br><img src="/Aqours-6th-dome-collection/yohane2.png" class=""><br>&emsp;&emsp;你的水第三季，又何必是水第三季！<br>&emsp;&emsp;水的动画活过来了，这真的很难想到，当大家都在为学园偶像题材寻找出路，讨论将来还有多少新团，虹和星谁先出第三季的时候，一直被认为转向三次元发展的水水竟然率先给出一个回答。<br>&emsp;&emsp;这是一个十分有创意又十分大胆冒险的尝试。出异世界番（暂且不知是 20min 的正常季度番还是小泡面），换一个题材重生，这样就续下去了，给企划也添上更多的 tag。只不过，如果完全脱离学园偶像，完全转型，就不是企划大方向了，这是另起炉灶，推倒重建，就算冲第三次东蛋、蛋巡乃至新国立，也不是以学园偶像的身份了。如何在转型时规避风险，应当是企划要慎重考虑的。<br>&emsp;&emsp;可以看得出这个破企划一直在做新的尝试，有些尝试很令人苦恼，比如星团硬塞式的加人；有些尝试则大放异彩，比如虹团的模式，虹的动画制作（以二次元去贴合三次元）。这次的尝试会如何？会吸引动画党入坑？会被人骂改朝换代？会讲出一个好故事还是摆烂乱写？<br>&emsp;&emsp;但是在粉丝看来，这代表着 Aqours 能再战很长时间，而且还有机会冲三次东蛋或者更大的场，这就是最好的消息了。这是强大的定心针，我们不必再担心水水江河日下，惨淡退出，live 开一场少一场，靠着越来越难以鉴赏的流水线产歌苦度余生。借助新的主题，水水可以产出具有新的内涵的歌，有更多不同的经历，也可以把经历填进词里，让词具有更丰富的感情（虽然现在问题最严重的应该是作曲 qaq）。有歌和动画，就有资本继续往上冲，路一下子宽了。<br>&emsp;&emsp;拨云见日，前途大好，未来光明。</p><h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3><p>&emsp;&emsp;还记得 20 年生放，做出一个“Aqours 结成 5 周年”的动作。5 周年以前，时间过得还算慢，动画、live 一步步来，不会感受到时间过得快。但是 5 周年以后，疫情空窗，一下子就到 7 周年了，虹也 5 周年了，突然间都开始纪年了。<br>&emsp;&emsp;蛋巡，起起落落，从线上振替，到成熟的线上 live，到小组现场试水，然后更多的现场水 live，最后是 6th 登蛋，点出水水甚至是企划的新未来。<br>&emsp;&emsp;疫情改变了很多很多。在等待水水的过程中，我也在经历这些大事，竞赛，升学，找研究方向，确定未来的路子。我也迷茫，未来怎么走，就像水水和运营一开始也不知所措，一步一步在试。试错很多，我错过了润北美的机会，水水以及整个企划的活动安排也不见得合理。最终到这里，我毕业了，马上要开启新的旅程，水水和企划也是。<br>&emsp;&emsp;好像在和什么人一同战斗一样。<br>&emsp;&emsp;我不要让我的人生变成“为水水和 LoveLive 而奋斗”，但是和她们在两条战线上，一同都在奋斗，能永远相互支持，这就最高了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;继“Aqours 东蛋之路”后，现在差不多可以开始起草“Aqours 蛋巡之路”了。。。&lt;/p&gt;</summary>
    
    
    
    <category term="玩" scheme="http://kqp.world/categories/%E7%8E%A9/"/>
    
    
  </entry>
  
  <entry>
    <title>【ICPC Camp PTZ-Shanghai 2022 Day2 G】Gross LCS 题解</title>
    <link href="http://kqp.world/%E3%80%90ICPC-Camp-PTZ-Shanghai-2022-Day2-G%E3%80%91Gross-LCS-%E9%A2%98%E8%A7%A3/"/>
    <id>http://kqp.world/%E3%80%90ICPC-Camp-PTZ-Shanghai-2022-Day2-G%E3%80%91Gross-LCS-%E9%A2%98%E8%A7%A3/</id>
    <published>2022-02-11T09:33:59.000Z</published>
    <updated>2022-02-11T10:00:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>&emsp;&emsp;给定两个数组 $A=\langle a_1,\cdots,a_n \rangle$ 和 $B=\langle b_1,\cdots,b_m \rangle$，定义 $A+x$ 表示 $\langle a_1+x,\cdots,a_n+x \rangle$，求 $\sum_{x=-10^{100}}^{10^{100}} LCS(A+x,B)$。</p><p>&emsp;&emsp;$n,m \le 4000,\ \ |a_i|,|b_i| \le 10^8$<br>&emsp;&emsp;10s，<strong>16MB</strong></p><span id="more"></span><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>&emsp;&emsp;首先，这么大的 $x$ 范围里，必定有很多是无贡献的。有贡献的 $x$ 的数量不超过 $nm$ 个，因为 $a_i+x=b_j$ 这样的等式只有 $nm$ 个。<br>&emsp;&emsp;这相当于说，对于一个固定的 $x$，在一个 $n$ 行 $m$ 列的矩阵上，把符合 $a_i+x=b_j$ 的格子 $(i,j)$ 做标记，在每一个标记点可以走到其右下方的任意标记点，问从左上走到右下的最长距离。<br>&emsp;&emsp;再往下想，每一对 $(i,j)$ 对应的 $x$ 是唯一的，也就是每种 $x$ 产生的标记总数也只有 $nm$。那么只要想办法把每种 $x$ 产生的标记弄出来，就可以 dp 了。</p><p>&emsp;&emsp;如果没有空间限制，那么就 $O(nm)$ 枚举所有的数对即可。这个 dp 是个简单的 LIS。<br>&emsp;&emsp;现在有空间限制，那么就需要用一些方法按顺序生成 $(x,i,j)$ 三元组。可以把 $b$ 数组从小到大排序（记为 $b’_1,\cdots,b’_m$），初始在堆里加入所有 $(b’_1-a_i,i,1)$，然后每从堆里取出一个元素，就把 $b’$ 向前推进一位，这样就能顺序生成所有 $(x,i,j)$ 三元组了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pr;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">4005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">2e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="type">int</span> val,i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpB</span><span class="params">(<span class="type">const</span> B &amp;a,<span class="type">const</span> B &amp;b)</span> </span>&#123;<span class="keyword">return</span> a.val&lt;b.val || a.val==b.val &amp;&amp; a.i&gt;b.i;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QST</span> &#123;</span><br><span class="line"><span class="type">int</span> x,i,j;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> QST &amp;a,<span class="type">const</span> QST &amp;b) &#123;</span><br><span class="line"><span class="keyword">return</span> a.x&gt;b.x || a.x==b.x &amp;&amp; a.i&gt;b.i || a.x==b.x &amp;&amp; a.i==b.i &amp;&amp; a.j&lt;b.j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,a[maxn],p[maxn];</span><br><span class="line">B b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c[maxn];</span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; RC;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x)</span> </span>&#123;<span class="keyword">return</span> x&amp;(-x);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> re=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; x; x-=<span class="built_in">lowbit</span>(x)) re=<span class="built_in">max</span>(re,c[x]);</span><br><span class="line"><span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">xg</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">RC.<span class="built_in">insert</span>(x);</span><br><span class="line"><span class="keyword">for</span>(; x&lt;=m; x+=<span class="built_in">lowbit</span>(x)) c[x]=<span class="built_in">max</span>(c[x],z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">c_clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x:RC)</span><br><span class="line"><span class="keyword">for</span>(; x&lt;=m; x+=<span class="built_in">lowbit</span>(x)) c[x]=<span class="number">0</span>;</span><br><span class="line">RC.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,m) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i].val), b[i].i=i;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+m,cmpB);</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,m) p[b[i].i]=i;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;QST&gt; Q;</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) Q.<span class="built_in">push</span>((QST)&#123;b[<span class="number">1</span>].val-a[i],i,b[<span class="number">1</span>].i&#125;);</span><br><span class="line"><span class="type">int</span> lastx=inf, ans=<span class="number">0</span>, curans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">QST cur=Q.<span class="built_in">top</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (lastx!=cur.x &amp;&amp; lastx!=inf) &#123;</span><br><span class="line">ans+=curans;</span><br><span class="line">curans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">c_clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp=<span class="built_in">get</span>(cur.j<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">curans=<span class="built_in">max</span>(curans,dp);</span><br><span class="line"><span class="built_in">xg</span>(cur.j,dp);</span><br><span class="line"></span><br><span class="line">lastx=cur.x;</span><br><span class="line"><span class="keyword">if</span> (p[cur.j]&lt;m) &#123;</span><br><span class="line"><span class="type">int</span> newj=p[cur.j]+<span class="number">1</span>;</span><br><span class="line">Q.<span class="built_in">push</span>((QST)&#123;b[newj].val-a[cur.i],cur.i,b[newj].i&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans+=curans;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;给定两个数组 $A=\langle a_1,\cdots,a_n \rangle$ 和 $B=\langle b_1,\cdots,b_m \rangle$，定义 $A+x$ 表示 $\langle a_1+x,\cdots,a_n+x \rangle$，求 $\sum_{x=-10^{100}}^{10^{100}} LCS(A+x,B)$。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;$n,m \le 4000,\ \ |a_i|,|b_i| \le 10^8$&lt;br&gt;&amp;emsp;&amp;emsp;10s，&lt;strong&gt;16MB&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="OI/ACM" scheme="http://kqp.world/categories/OI-ACM/"/>
    
    
    <category term="算法_DP" scheme="http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"/>
    
  </entry>
  
  <entry>
    <title>LoveLive 三团跨年 live + 72红白</title>
    <link href="http://kqp.world/countdownlovelive_72kouhaku/"/>
    <id>http://kqp.world/countdownlovelive_72kouhaku/</id>
    <published>2022-01-01T06:00:00.000Z</published>
    <updated>2022-08-09T14:49:15.528Z</updated>
    
    <content type="html"><![CDATA[<p>12.31 已经成为每年最期待的日子了 qaq</p><span id="more"></span><h2 id="LoveLive-Countdown"><a href="#LoveLive-Countdown" class="headerlink" title="LoveLive Countdown"></a>LoveLive Countdown</h2><p>&emsp;&emsp;老实说我不希望 LL 自己办跨年，我希望有朝一日能在红白看见 LL series special，或者像さだまさし那样的在自己的 live 上连线红白。<br>&emsp;&emsp;今年这种线上线下并行的 live 已经成熟了，各种 live 依次宣布，加上也有过 fes 先例了，所以听见三团跨年其实也没多大惊奇。惊奇的是今年的民间组织竟然这么给力，全国上下二三十个城市几乎都有正规的民间组织观影，还做宣传视频，仿佛 live 开到家门口一样。总策划真的辛苦了。<br>&emsp;&emsp;一开始还纠结是去广州的大场还是吃土群自己的小场，后来因为带上了 sif 网友和贴吧网友（叫我传销头子），网友喜欢小场，又看到广州场标题叫 live with a tiger 感觉很可怕，就选择了一带三去吃土群小场。遗憾的是某位帅气小哥哥受伤没来。<br>&emsp;&emsp;这场 live 最担心的是 liella 特别是小百合，18场高强度巡演已经让她们嗓子很辛苦了，这个1st巡演过后，要么报废，要么成神。</p><p>&emsp;&emsp;看了红白的歌单，五木大叔不上了，松田圣子亡女不上了，岚停止活动了，有些许失望。あいみょん常驻了，几位老叔叔老阿姨还在，杰尼斯搬出了今年的雪皇桶三巨头（去年的 imitation rain 真的好听），yoasobi 两年都是现象级的歌，所以也十分期待。但是预计着只能够在 LL 开场前那一小会儿看一看，比如看到了雪人杂技团（</p><p>&emsp;&emsp;开场先放日天歌，一波烟雾弹。<br>&emsp;&emsp;星一单虹一专开场，水一转攻势来了个 dreamy color。这里最令人激动的当然是看到菜宝的大红旗袍和过膝靴。<br>&emsp;&emsp;然后来到星专场，像是简化的 1st 巡演，有给 pay 子发挥的nonfiction，有给小百合展现的symphony，拍手歌一如既往跳协调操，星光序曲将成为新的光路企划。mc可以看鲤鱼乱摸小百合。<br>&emsp;&emsp;接下来是虹专场，上来12个solo短版，似乎是各自选曲。我虽然虹听得少，但还是识得一些亮点，哀温之诗三专封神，岚珠米娅首秀，萌p绝育之光，兔兔可爱充满活力的开花宣言。最后11人版LLL，我喜欢这个摆字造型。<br>&emsp;&emsp;然后出现了146与167并肩的名场面。<br>&emsp;&emsp;时间来到水专场，开场竟然是水蓝，现在水live已经能源源不断地重新看到动画歌曲了非常感动。后面几首则是近期live比较常规的曲子，亮点反而偏少（也可能是我看得多），情怀多，比如水蓝的衣服。<br>&emsp;&emsp;三个专场之后是听广播坐牢，跟相似度调查一样感觉都是在硬凑时间，所以这一段跑去看红白了，看到红组ゲスト吃零蛋竟然还能优胜，实属宅男人气优势。中途LL有三首广播曲，这是live的焦点之一，水水轻快海边曲，虹虹炫酷rap，星星用网友的话叫“意外地成熟”。大家的衣服都改得很漂亮，尤其是某十四岁少女米娅，太成熟了。<br>&emsp;&emsp;最后的跨年倒数，最精彩的部分，网卡了直接错过，新年第一寄，成为本场最大遗憾。<br>&emsp;&emsp;倒数完后只有主题曲了，三团leader向系列致敬。没有021这样的新寓意。有点戛然而止的感觉。</p><p>&emsp;&emsp;于是又一年过去了。这年也发生了很多事，最大的感想就是，看着小姐姐们年龄渐长，真的很希望在水水退役前来一次现地。不会想到LL有如今这般发展，后辈实力越来越猛，而且都是逐梦成功的远古拉拉人。如果再展望，我希望的是一路平稳，不需要搞大事，只求长久，一代又一代的传承，把羽毛接好。如果还有祝愿，那就是星星能实现她们动画里的目标——新国立。</p><p>&emsp;&emsp;live还有很多，所以并没有太强烈的“结束了”的感觉。fes，以后还会有。</p><p>&emsp;&emsp;写这篇东西写着写着看到里p结婚了。只能说，恭喜，你怎么会有女朋友嘛.jpg伤害提升十倍。</p><h2 id="72届红白"><a href="#72届红白" class="headerlink" title="72届红白"></a>72届红白</h2><p>&emsp;&emsp;终于在过年期间有时间补了红白，甚至还是熟肉。</p><p>&emsp;&emsp;还是那句话：“不得不说跟红白一对比都要感慨你拉是怎么活到现在的”。偶像live看多了，还是要看点红白修正一下品味，至少不能认为天天翻车是正常的。</p><p>&emsp;&emsp;郷ひろみ 67 了你敢信，气息真的厚足，身体健壮，活力四射。<br>&emsp;&emsp;dish 出场前有 あいみょん 跟主持人的互动，あいみょん 竟然还能这么娇小活泼可爱，全靠大泉洋衬托。<br>&emsp;&emsp;特别影片提到了 アイゴ 褐蓝子鱼，以为是什么高档鱼类，一百度竟然是泥猛，好家伙还隔这吹生态破坏呢，台山人来了全吃了。煲汤不知多鲜！<br>&emsp;&emsp;小孩子的歌很可爱啊啊啊，小小的人总是有大大的和平梦想，但是这个作曲就一股夜に駆ける味，果然还是你 yoasobi。<br>&emsp;&emsp;纯烈清洁工上线。<br>&emsp;&emsp;来到了筒就顺带把雪皇筒都说一说。筒翻车率较高，没有去年 imitation rain 那番冷艳；king 中规中矩的偶像男团表现；雪人杂技团，秀多过唱了。<br>&emsp;&emsp;天童奶奶经典花道，不过乐队动作有点骚。<br>&emsp;&emsp;上白石萌音长得好可爱啊~<br>&emsp;&emsp;まふまふ这首是惊艳，首先布景把人带入一个很梦幻虚无的境界，然后高音特别猛，比上一个 milet 还猛，麦克风还用绷带跟手绑起来。歌词初读觉得很没头绪，怎么描述了一通生命的无意义，嘲讽了劝活的人，最后自己还拼命喊生きて呢？倒回去再读了两三遍，大约理解了，在生不如死的情感面前，歌词反对的是那些轻浮说教的劝活，转而以撕心裂肺的呐喊表达出内心对生命的尊重。<br>&emsp;&emsp;水森かおり的歌配上旅行画面，真的让人感到很舒服。<br>&emsp;&emsp;マツケンサンバ，日式桑巴，从报幕到结尾都是整活的气息。<br>&emsp;&emsp;没有指挥的交响乐团，对这位游戏音乐人的纪念。<br>&emsp;&emsp;年年晨间剧主题歌都吸引我，但是年年都不知道去哪里找晨间剧看。<br>&emsp;&emsp;这个bish是怎么被选上红白的。。。全场唯一一首听到头皮发麻的，质量似乎比水水live还差（<br>&emsp;&emsp;剑玉队打破规律魔咒，二连胜了，可喜可贺。以后选首长点的歌唱吧，队伍越来越长了。<br>&emsp;&emsp;决明子的 rap 很棒，节奏适中，歌词很鼓舞人，很温柔又很能届到明天的勇气。<br>&emsp;&emsp;perfume打造的元宇宙很有现代感，有迷失在科技空间的感觉。美中不足是只有三个女生唱歌气息很弱，bgm太强，整首歌就会感觉很虚。<br>&emsp;&emsp;宫本浩次，这唱得面目狰狞的，一副“我特么跟你安利我家乡你敢不去？”的样子，感觉这首歌温柔一点会更贴合。<br>&emsp;&emsp;紫团这次是生田绘梨花的毕业live，温暖的毕业歌总是很触动人。不仅联想到kon，还联想到逢田姐（x<br>&emsp;&emsp;細川たかし这个演歌够味，小街欢腾感，不过津轻都这么冷感伤感的吗？以及大泉洋水平高啊。<br>&emsp;&emsp;坂本阿姨今年借助樱吹雪的背景也特别美，给这首歌换上了不同的风格。<br>&emsp;&emsp;拖鞋睡衣战神藤井风，整首歌曲也是充满了随性的气息，包括旋律变化、唱法、眼神。<br>&emsp;&emsp;yoasobi 又一现象级歌曲，<del>最初是在鬼畜区认识这首歌的</del>。歌难度很高但是唱得很稳，不过感觉现场不如 CD 有气势？<br>&emsp;&emsp;铃木大叔这首摇滚又有点爵士风的小曲，配上几个老爷子扭来扭去的动作，真的太有大叔味了！去年初识铃木大叔，被特有的大叔磁性声音吸引，这次由深情思念变为活泼欢快，充满中年男人的魅力。<br>&emsp;&emsp;ゆず护花使者一般，歌曲轻快像rap，和声很棒！<br>&emsp;&emsp;gen桑同样是一首很安静舒服的歌曲。<br>&emsp;&emsp;あいみょん这首把乐队live的feel发挥到极致了，自由的衣服，标准的乐队站位和灯光，あいみょん特有的低沉和像甩出去一样的滑音。<br>&emsp;&emsp;出现了！さだまさし这个形式，在自己的live中途接入红白，一石二鸟，是我最希望出现在LL跨年live上的形式！自己跨年跟上红白两不误！歌曲的话，跟まふまふ的劝活又是两种风格，这种是很慈祥的老爷爷用毕生的阅历鼓励你笑って。<br>&emsp;&emsp;苹果姐姐拿个喇叭唱歌是要做什么？这歌词倒也确实适合播广播（<br>&emsp;&emsp;石川小百合的摇滚rap，香香辣辣你见过没！！还是要靠津轻拉回风格qaq。<br>&emsp;&emsp;福山大叔的歌是想把人间看透，并赞美生命的延续。<br>&emsp;&emsp;奥运会片段体现出的是互相尊重的价值观，展现了很多比赛之上的爱。稍有别于国内价值观，例如因心理原因退赛的体操选手，这样的事迹至少不会在国内被公开宣传，我们宣传的是拼尽全力为国争光，而他们如他们所说：“他选择的不是运动员的立场，而是人类的立场。”<br>&emsp;&emsp;高音战神misia，第一首破音和粗嗓比较严重，第二首跟拖鞋战神合作的歌就挺好，充分发挥了高音战神的魅力。<br>&emsp;&emsp;最后红组在审查员评分吃零蛋的情况下奇迹般赢了。要分析起来的话可能需要考虑如下因素：红组会不会因为 bish 而一票否决；杰尼斯和坂道系在宅女宅男中的人气对比；现象级歌曲的人气因素；审查员似乎都偏年轻因此老歌的地位会不会下降。</p><p>&emsp;&emsp;今年没有像前几年一样发现特别令我眼前一亮的歌曲，有点可惜。不过，也是各位霓虹音乐人一年又一年努力呈现的舞台。抱以欣赏和学习的态度去观看，身心愉悦。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;12.31 已经成为每年最期待的日子了 qaq&lt;/p&gt;</summary>
    
    
    
    <category term="玩" scheme="http://kqp.world/categories/%E7%8E%A9/"/>
    
    
  </entry>
  
  <entry>
    <title>2021ICPC南京站大杂记</title>
    <link href="http://kqp.world/2021_ICPC_nanjing/"/>
    <id>http://kqp.world/2021_ICPC_nanjing/</id>
    <published>2021-12-04T15:24:08.000Z</published>
    <updated>2022-01-26T07:34:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;发现自己真的好久没写游记了啊。。。<del>倒是各式各样的其他小作文写了不少。。。</del></p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;真没想到吧，大四了还没退役。以前中学说“五年 OI 一场空”，或者“十年 OI 一场空”，今年，都第 11 个年头了。。。<br>&emsp;&emsp;大一打完了没想过会有大二，结果被郭老拉去毛营；大二打完了没想过会有大三，结果被 zayin 哥哥盛情邀请；大三打完了线也出了杯也捧了更不会想到有大四，结果暑假校队选拔的时候被拉进小黑屋谈话，说今年金牌数量危，出线名额危，让我们来救救场，甚至还要拆了我们队变成两个抢出线的队来着。。。最后大概就是以“final 还没来”为理由又续了一年。</p><p>&emsp;&emsp;算法竞赛这个东西，说真的，我现在大概不是很有资格说我很热爱它，无论从想法上还是行动上。放到大二及以前我认为我是有资格的。转折是大三以来，出现了更多的兴趣爱好，有了想投入精力的课程，有了对科研生活、TCS research 的向往 <del>，有了想要追的女生</del>。补题时间骤减，训练补题时的厌烦情绪骤升，想不出题目被人智商碾压时的痛苦骤升。逐渐发现，比赛打久了，真的会累。</p><p>&emsp;&emsp;这一年波波折折也算是把学校定了，预计着大四就混在实验室，读 paper，想问题，喝茶（x）暑假去校选帮忙，去小黑屋谈话，给学弟队伍凑个人头好训练，回过神来才发现又被忽悠上了赛道。</p><h2 id="开学"><a href="#开学" class="headerlink" title="开学"></a>开学</h2><p>&emsp;&emsp;当然这个赛季无人之境有多拉大家也都看到了。最好的可能就是第一场 CCPC 网络赛，凭运气挤进了 hdu 土豆服务器抢了个第 9。后面的三场网络赛每场都是两个人打、另一人实习，全部都 rk70+。<br>&emsp;&emsp;打校赛拿了个第一，尚能饭。仔细分析了与最后的午餐的差距，他们做后期题比我们更有潜力，但是前中期我们更稳，所以在日常难度较大的训练里他们总要超我们一两个题，但也通常要到 3h-4h 以后才翻上去，校赛这种 90% 简单题的场我们自然也更有优势。<br>&emsp;&emsp;这样一分析，其实我们就像是当年的穷游中国，靠前中期优势取胜。</p><p>&emsp;&emsp;排赛站的时候，我们想着把小赛区留给冲出线的队，我们去大赛区旅游，结果几个来回全线上了，旅游泡汤。<br>&emsp;&emsp;队友实习结束后大概一周能有 4 场训练。没怎么补题倒是真的。</p><p>&emsp;&emsp;很快 11 月就到了。<br>&emsp;&emsp;CCPC 广州，完全是老年人随心所欲流派打法，zayin 卡 C 题，邓老板写几何题，两人直接从 1h 卡到 5h，期间不换题也不看榜，F 板刷了什么的根本不知道。我最后把数论题搞出来了没机时，赛后 10min 才卡完常。颁奖的时候十分希望直接打铁，这样我们名字就不会被念到，结果很不幸铜了。<br>&emsp;&emsp;ICPC 上海，体面了一点，至少会开题、会跟榜了。遗憾的是我开场摸的全是中后期题，一个签到都没抢到，最后全程躺，一题都没写，就看着队友输出，给他们小黄鸭。<br>&emsp;&emsp;可见这两场其实没什么游记可写。。。<br>&emsp;&emsp;CCPC 威海，出题历程大概有 3 个月，几经风雨，呕心沥血，在挖精妙的 idea、不停地叉做法改进做法、控难度等方面下了很大功夫。最后功亏一篑，H 题 generator 写错导致数据弱了，被很弱智的水法冲了过去，荣登 XCPC 比烂表。关于出题我也有很多想说的，等后面的 OI 出题任务过了以后再开篇。</p><p>&emsp;&emsp;好几场打崩的场恰好都有锅，然后就可以在一些群里看到：“无人之境都打成这样，总不能是无人之境有问题吧”“不会以为无人之境不训练了就很弱吧”……赫然发现我们的表现竟然成了判断一场比赛区分度好坏的标准之一了。感谢你们对我们过往成绩的认可，不过我们也十分惭愧，我们打崩了基本上都是自身原因，我们尚不足以用于评判区分度的好坏。</p><p>&emsp;&emsp;然后就到南京了。</p><h2 id="南京"><a href="#南京" class="headerlink" title="南京"></a>南京</h2><p>&emsp;&emsp;星期三得知正赛竟然是周六，又赶上周六大一的同学有军理考试，于是含有大一的队伍突然间全寄了，紧急换人。对着校赛榜抓壮丁，抓了个打得很好的研究生队（两个我校退役选手，一个来自 csu 进过小米邀请赛的大神），再抓了校队里还没打满 2 场里的唯一不含大一的一支队伍。</p><p>&emsp;&emsp;周五热身前看到 cjb 哥哥发了个死亡笔记，不幸榜上有名。热身完了以后回去看到某 C 开头的学会以“代码含有暴戾语言”为由禁赛了 5 个人，血压拉满。</p><p>&emsp;&emsp;周六早上，第一趟出门，到机房发现忘带电脑；回宿舍拿电脑第二趟出门，到机房发现忘带板子，回宿舍拿板子第三趟出门，到机房离开始只有 10 min 了。阿尔茨海默症晚期选手。还没开场先跑个 2km 感觉很淦。</p><p>&emsp;&emsp;开场，邓老板抢了个 G 一血。我玩 M 题猜了个错结论，也没判 $n=1$，WA 了两发，罚时大概从一开始就没有了。<br>&emsp;&emsp;然后读过几个题之后我就开始想 J，队友陆续过掉 CD，zayin 开始快乐线段树历史和。我的 J 转化了模型却一直没进展。邓老板被迫开计数题。<br>&emsp;&emsp;2.5h 后 E 过了。zayin 一边救 J 一边听计数题，机位空了一万年。<br>&emsp;&emsp;最后我突然发现每一步操作结果一定是一段连续的区间，zayin 听了马上补充说不是连续区间而是恰好只有两个相邻的数，于是 dp 做法就出来了。最终 4h18min 过了 J。<br>&emsp;&emsp;我写 J 的时候他们 IG 都会了，但是一开始以为 I 要 cdq 所以决定先写 G。最后两题都没写完。</p><p>&emsp;&emsp;苟在金区。想比上海更体面一点，想能够给这篇游记起个标题叫“体面记”，但结果不算很体面。就这样吧。<br>&emsp;&emsp;这场主要问题就是我的 J 卡了半个场，节奏全部拖慢了。这个 J 的套路应该是老套路了，所幸最后能想起来。I 比较歪。</p><p>&emsp;&emsp;发现我校稳定每场一个金，这样下去金牌数和出线还真的很危。求求下一任中大之光赶紧出线呀。。。</p><h2 id="结束了"><a href="#结束了" class="headerlink" title="结束了"></a>结束了</h2><p>&emsp;&emsp;现在是处于一种退役了但又没完全退役的状态。<br>&emsp;&emsp;已有的比赛确实打完了，两场 ICPC，一场 CCPC。神不知鬼不觉被拉上的大四赛道，也算是走完了。大四打完，这下是真不会有下一年了。<br>&emsp;&emsp;但是很大概率将来还要被拉去打 EC，下周还有个毛营想要试着去旅游去抢钱，一年后还有一个状态未知的 WF2021。</p><p>&emsp;&emsp;竞赛就是这样子，前面无论多累多不想做，恨不得没有比赛天天过科研生活，可是真的比赛完了，真的到退役的时候了，就总会觉得还远远不够，还应该再做几个题，再打上几年。<br>&emsp;&emsp;没有完全把实力发挥出来，当然会意犹未尽。不过，我相信不只是因为赛场的遗憾，这么多年的投入，不可能不在说再见的时候牵动心弦。<br>&emsp;&emsp;所幸这次又又又只是暂别。atcoder，codeforces，太多没补完的东西，暂时要放一放，去读 paper 做毕设了。总会在 EC、WF 之前，又捡起来再打。不过可以肯定的是，一大段时间内，不会再有一周四训这样热火朝天的行为了。</p><p>&emsp;&emsp;EC 确定日期之前大概也不会康复了。现在可以开始你想要的生活了，它还是你期待的样子吗？<br>&emsp;&emsp;希望是的。</p><p>&emsp;&emsp;更多的话，等下一篇年终总结来说吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;发现自己真的好久没写游记了啊。。。&lt;del&gt;倒是各式各样的其他小作文写了不少。。。&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="总结与游记" scheme="http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"/>
    
    <category term="OI/ACM" scheme="http://kqp.world/categories/OI-ACM/"/>
    
    
  </entry>
  
  <entry>
    <title>【AtCoder Grand 030E】Less than 3 题解</title>
    <link href="http://kqp.world/%E3%80%90AtCoder%20Grand%20030E%E3%80%91Less%20than%203%20%E9%A2%98%E8%A7%A3/"/>
    <id>http://kqp.world/%E3%80%90AtCoder%20Grand%20030E%E3%80%91Less%20than%203%20%E9%A2%98%E8%A7%A3/</id>
    <published>2021-11-25T11:45:14.000Z</published>
    <updated>2022-01-26T09:46:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>&emsp;&emsp;给定两个长度为 $n$ 的 01 串 $s,t$，每个串都不会有连续三个相同的字符。现在每次操作可以将 $s$ 的一位反转，但反转之后也要保证没有连续三个相同的字符，求最少的步数使得 $s$ 变成 $t$。</p><p>&emsp;&emsp;$n \le 5000$<br>&emsp;&emsp;2s</p><span id="more"></span><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>&emsp;&emsp;题解这个模型转化非常 nice。</p><p>&emsp;&emsp;给 $0$ 和 $1$ 之间画一条红线，给 $1$ 和 $0$ 之间画一条蓝线，这样这个 01 串就变成了：</p><ul><li>有很多红蓝相间的线；（开头和结尾可以补充无限条红蓝相间的线）</li><li>相邻的线间隔为 1 或 2；</li><li>每次操作可以将一条线往左或者往右移 1 位，不能与别的线重合，线的间隔仍然要为 1 或 2。</li></ul><p>&emsp;&emsp;可以发现这样就变成了线的匹配问题。$O(n)$ 枚举 $s$ 串开头的线匹配 $t$ 的哪一条线，然后再 $O(n)$ 算出匹配代价即可，总共 $O(n^2)$。整个过程用些数据结构或者 trick 可以优化成 $O(n)$，不过意义不大。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pr;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">5005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,ps0,ps1,pt0,pt1,ps2,pt2;</span><br><span class="line">pr ps[<span class="number">4</span>*maxn],pt[<span class="number">4</span>*maxn];</span><br><span class="line"><span class="type">char</span> s[maxn],t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pre</span><span class="params">(<span class="type">char</span> *t,pr *p,<span class="type">int</span> &amp;p0,<span class="type">int</span> &amp;p1,<span class="type">int</span> &amp;p2)</span> &#123;</span><br><span class="line">fo(i,<span class="number">0</span>,n+<span class="number">5</span>) p[++p0]=<span class="built_in">make_pair</span>(<span class="number">0</span>,i&amp;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (p[p0].second!=(t[<span class="number">0</span>]&gt;t[<span class="number">1</span>])) p[++p0]=<span class="built_in">make_pair</span>(<span class="number">0</span>,(t[<span class="number">0</span>]&gt;t[<span class="number">1</span>]));</span><br><span class="line">p1=p0+<span class="number">1</span>;</span><br><span class="line">fo(i,<span class="number">1</span>,n<span class="number">-1</span>) <span class="keyword">if</span> (t[i]!=t[i+<span class="number">1</span>]) p[++p0]=<span class="built_in">make_pair</span>(i,(t[i]&gt;t[i+<span class="number">1</span>]));</span><br><span class="line">p2=p0;</span><br><span class="line"><span class="type">int</span> cur=(t[n]==<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">fo(i,<span class="number">0</span>,n+<span class="number">5</span>) p[++p0]=<span class="built_in">make_pair</span>(n,cur), cur^=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (n&lt;=<span class="number">2</span>) &#123;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">fo(i,<span class="number">1</span>,n) ans+=(s[i]!=t[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">s[<span class="number">0</span>]=(s[<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span> ?<span class="string">&#x27;0&#x27;</span> :<span class="string">&#x27;1&#x27;</span> );</span><br><span class="line">t[<span class="number">0</span>]=(t[<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span> ?<span class="string">&#x27;0&#x27;</span> :<span class="string">&#x27;1&#x27;</span> );</span><br><span class="line"></span><br><span class="line">pre(s,ps,ps0,ps1,ps2);</span><br><span class="line">pre(t,pt,pt0,pt1,pt2);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans=n*n*<span class="number">10</span>;</span><br><span class="line">fo(i,<span class="number">1</span>,pt2) <span class="keyword">if</span> (ps[ps1].second==pt[i].second) &#123;</span><br><span class="line"><span class="type">int</span> bs=ps1-max(<span class="number">0</span>,i-pt1), be=ps2+max(<span class="number">0</span>,pt2-(i+ps2-ps1)), bt=i-(ps1-bs), len=be-bs+<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> ans1=<span class="number">0</span>;</span><br><span class="line">fo(j,<span class="number">1</span>,len) ans1+=<span class="built_in">abs</span>(ps[bs+j<span class="number">-1</span>].first-pt[bt+j<span class="number">-1</span>].first);</span><br><span class="line">ans=min(ans,ans1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;给定两个长度为 $n$ 的 01 串 $s,t$，每个串都不会有连续三个相同的字符。现在每次操作可以将 $s$ 的一位反转，但反转之后也要保证没有连续三个相同的字符，求最少的步数使得 $s$ 变成 $t$。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;$n \le 5000$&lt;br&gt;&amp;emsp;&amp;emsp;2s&lt;/p&gt;</summary>
    
    
    
    <category term="OI/ACM" scheme="http://kqp.world/categories/OI-ACM/"/>
    
    
    <category term="算法_神奇的脑洞" scheme="http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>【2021 ICPC Gran Premio de Mexico 2da Fecha F】Flipped Factorization 题解</title>
    <link href="http://kqp.world/%E3%80%902021%20ICPC%20Gran%20Premio%20de%20Mexico%202da%20Fecha%20F%E3%80%91Flipped%20Factorization%20%E9%A2%98%E8%A7%A3/"/>
    <id>http://kqp.world/%E3%80%902021%20ICPC%20Gran%20Premio%20de%20Mexico%202da%20Fecha%20F%E3%80%91Flipped%20Factorization%20%E9%A2%98%E8%A7%A3/</id>
    <published>2021-11-09T04:11:15.000Z</published>
    <updated>2022-06-07T04:14:25.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>&emsp;&emsp;设 $x$ 的质因数分解为 $p_1^{c_1}p_2^{c_2}\cdots p_m^{c_m}$，记 $f(x) = c_1^{p_1}c_2^{p_2}\cdots c_m^{p_m}$，给定 $n$，求 $\sum_{i=1}^n f(n) \bmod 10^9+7$。</p><p>&emsp;&emsp;$n \le 10^{14}$<br>&emsp;&emsp;10s</p><span id="more"></span><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>&emsp;&emsp;$n$ 的这个范围没法筛，但却很根号。<br>&emsp;&emsp;因此用 powerful number 求积性函数和。</p><p>&emsp;&emsp;观察到对质数来说 $f(p)=1$，能对上这个形式的，马上想到全 1 函数 $1(n)=1$。然后观察 $h = \frac{f}{1} = f \ast \mu$，得到</p><script type="math/tex; mode=display">h(p^c)=\begin{cases}c^p-(c-1)^p, &c>1 \\ 0, &c=1\end{cases}</script><p>&emsp;&emsp;然后推式子</p><script type="math/tex; mode=display">\begin{aligned}& f = h \ast 1 \\ \Rightarrow & \sum_{i=1}^n f(i) = \sum_{i=1}^n \sum_{j=1}^{\lfloor \frac ni \rfloor} h(i)1(j) = \sum_{i=1}^n h(i) \lfloor \frac ni \rfloor \\ \end{aligned}</script><p>&emsp;&emsp;又由于 $h$ 只在 powerful number 处有值，因此用 dfs 把 $O(\sqrt n)$ 个 powerful number 都找出来算答案就行了。dfs 的过程中要维护 $h$ 的值，$c^p$ 可以用快速幂算。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxp0=<span class="number">1e7</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> LL mo=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">LL n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[maxp0],p0;</span><br><span class="line"><span class="type">bool</span> bz[maxp0];</span><br><span class="line"><span class="type">void</span> <span class="title function_">Prime</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">fo(i,<span class="number">2</span>,n) &#123;</span><br><span class="line"><span class="keyword">if</span> (!bz[i]) p[++p0]=i;</span><br><span class="line">fo(j,<span class="number">1</span>,p0) &#123;</span><br><span class="line"><span class="keyword">if</span> (i*p[j]&gt;n) <span class="keyword">break</span>;</span><br><span class="line">bz[i*p[j]]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i%p[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL <span class="title function_">Pow</span><span class="params">(LL x,LL y)</span> &#123;</span><br><span class="line">LL re=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; y; y&gt;&gt;=<span class="number">1</span>, x=x*x%mo) <span class="keyword">if</span> (y&amp;<span class="number">1</span>) re=re*x%mo;</span><br><span class="line"><span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL ans;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> k,LL h,LL i)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (k&gt;p0) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (n/i&lt;(LL)p[k]*p[k]) <span class="keyword">return</span>;</span><br><span class="line">dfs(k+<span class="number">1</span>,h,i);</span><br><span class="line">LL last=<span class="number">1</span>;</span><br><span class="line">i*=p[k];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">2</span>; ; c++) &#123;</span><br><span class="line">LL cur=Pow(c,p[k]);</span><br><span class="line">LL newh=h*(cur-last+mo)%mo;</span><br><span class="line">i*=p[k];</span><br><span class="line">(ans+=(n/i)%mo*newh)%=mo;</span><br><span class="line">dfs(k+<span class="number">1</span>,newh,i);</span><br><span class="line"><span class="keyword">if</span> (n/i&lt;p[k]) <span class="keyword">break</span>;</span><br><span class="line">last=cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">Prime(<span class="number">1e7</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">ans=n%mo;</span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;设 $x$ 的质因数分解为 $p_1^{c_1}p_2^{c_2}\cdots p_m^{c_m}$，记 $f(x) = c_1^{p_1}c_2^{p_2}\cdots c_m^{p_m}$，给定 $n$，求 $\sum_{i=1}^n f(n) \bmod 10^9+7$。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;$n \le 10^{14}$&lt;br&gt;&amp;emsp;&amp;emsp;10s&lt;/p&gt;</summary>
    
    
    
    <category term="OI/ACM" scheme="http://kqp.world/categories/OI-ACM/"/>
    
    
    <category term="算法_数论" scheme="http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>TCS papers 阅读记录</title>
    <link href="http://kqp.world/TCS_papers_reading/"/>
    <id>http://kqp.world/TCS_papers_reading/</id>
    <published>2021-10-27T14:04:08.000Z</published>
    <updated>2022-11-04T02:19:00.531Z</updated>
    
    <content type="html"><![CDATA[<p>大概就随便记一记读过的有亮点的东西，觉得很牛逼的东西就分享一下，随缘更新。</p><p>当然也不是教程或者阅读笔记。</p><p>TCS 是指 Theoretical Computer Science。</p><span id="more"></span><h2 id="Fine-Grained-Complexity-and-Cryptography"><a href="#Fine-Grained-Complexity-and-Cryptography" class="headerlink" title="Fine-Grained Complexity and Cryptography"></a>Fine-Grained Complexity and Cryptography</h2><p><a href="https://people.csail.mit.edu/virgi/6.s078/">这是 MIT 的 Fine-Grained Complexity 课</a>，可以用它的 lecture note 简单学一学。以及它的<a href="https://people.csail.mit.edu/virgi/6.s078/paperlist.html">大作业的 paper list</a> 作为起点我认为是不错的。</p><h4 id="Marshall-Ball-Alon-Rosen-Manuel-Sabin-and-Prashant-Nalini-Vasudevan-Average-Case-Fine-Grained-Hardness-In-STOC-2017"><a href="#Marshall-Ball-Alon-Rosen-Manuel-Sabin-and-Prashant-Nalini-Vasudevan-Average-Case-Fine-Grained-Hardness-In-STOC-2017" class="headerlink" title="Marshall Ball, Alon Rosen, Manuel Sabin, and Prashant Nalini Vasudevan. Average-Case Fine-Grained Hardness. In STOC 2017."></a>Marshall Ball, Alon Rosen, Manuel Sabin, and Prashant Nalini Vasudevan. Average-Case Fine-Grained Hardness. In STOC 2017.</h4><p>&emsp;&emsp;以下称为 [avg-fg]<br>&emsp;&emsp;声称是第一篇将 fine-grained complexity 与 cryptography 结合起来的工作。<br>&emsp;&emsp;先推导一个重要的 Lemma 1，就是将传统的 random self-reducibility 改造了一下，原本的归约只要多项式复杂度就好了，现在要求复杂度更精细，因此要用比较牛逼的点值和插值。<br>&emsp;&emsp;然后基于这个做出了几个基本问题的 average-case hardness。<br>&emsp;&emsp;然后针对 OV 问题，给出了只用 $\tilde O(n)$ 的验证方法（灵活运用多点求值和快速插值），这样就给出了一个 MA 协议和 Proof of Work。<del>虽然是老竞赛选手了，但还是被秀得头皮发麻</del><br>&emsp;&emsp;然后它说用 OV 构造的 instance-solution pair 作为 OWF 会证伪 NSETH，因此 OV 的这个 hardness 不太能用来做 OWF。</p><h4 id="Marco-L-Carmosino-Jiawei-Gao-Russell-Impagliazzo-Ivan-Mihajlin-Ramamohan-Paturi-and-Stefan-Schneider-Nondeterministic-extensions-of-the-strong-exponential-time-hypothesis-and-consequences-for-non-reducibility-In-TCS-2016"><a href="#Marco-L-Carmosino-Jiawei-Gao-Russell-Impagliazzo-Ivan-Mihajlin-Ramamohan-Paturi-and-Stefan-Schneider-Nondeterministic-extensions-of-the-strong-exponential-time-hypothesis-and-consequences-for-non-reducibility-In-TCS-2016" class="headerlink" title="Marco L. Carmosino, Jiawei Gao, Russell Impagliazzo, Ivan Mihajlin, Ramamohan Paturi, and Stefan Schneider. Nondeterministic extensions of the strong exponential time hypothesis and consequences for non-reducibility. In TCS 2016."></a>Marco L. Carmosino, Jiawei Gao, Russell Impagliazzo, Ivan Mihajlin, Ramamohan Paturi, and Stefan Schneider. Nondeterministic extensions of the strong exponential time hypothesis and consequences for non-reducibility. In TCS 2016.</h4><p>&emsp;&emsp;以下称为 [NSETH]<br>&emsp;&emsp;[avg-fg] 在构建 one-way function 的时候说，如果他设计的 one-way function 存在，就会证伪 NSETH 猜想。这篇就是讲 NSETH 猜想。<br>&emsp;&emsp;简单来说，SETH 是说 k-SAT 需要指数时间，而 NSETH 是说 k-UNSAT 在非确定图灵机上也要指数时间。<br>&emsp;&emsp;然后他说证伪 NSETH 会得到一些 circuit lower bound，所以很难证伪。由于不懂电路就先跳过了。<br>&emsp;&emsp;fine-grained reduction 可以在非确定性图灵机上进行，这样就可以使用 NSETH 这个 hardness 了。NSETH 推导出来最有趣的结果应当是，SETH-hard 不能说明 3-SUM-hard 和 APSP-hard。</p><h4 id="Rio-LaVigne-Andrea-Lincoln-and-Virginia-VassilevskaWilliams-Public-Key-Cryptography-in-the-Fine-Grained-Setting-In-CRYPTO-2019"><a href="#Rio-LaVigne-Andrea-Lincoln-and-Virginia-VassilevskaWilliams-Public-Key-Cryptography-in-the-Fine-Grained-Setting-In-CRYPTO-2019" class="headerlink" title="Rio LaVigne, Andrea Lincoln, and Virginia VassilevskaWilliams. Public-Key Cryptography in the Fine-Grained Setting. In CRYPTO 2019."></a>Rio LaVigne, Andrea Lincoln, and Virginia VassilevskaWilliams. Public-Key Cryptography in the Fine-Grained Setting. In CRYPTO 2019.</h4><p>&emsp;&emsp;以下称为 [pubkey]<br>&emsp;&emsp;<del>老板：“如果 public key 做出来了，那数字签名之类的全套都有了，你代码实现一下，假装数字签名那些是很难很创新的东西，不就把毕设水出来了吗？反正你校的老师都水平低看不懂。”</del><br>&emsp;&emsp;这篇想要基于 [avg-fg] 继续深入，搞 public key 和 key exchange，顺便深入研究 one-way function。<br>&emsp;&emsp;开局 27 个 definition 让人为之震撼，这套东西居然要基于这么强的限制，花拳绣腿。<br>&emsp;&emsp;而后面基于 Merkle Puzzle 设计具体协议的那部分，特别是证明，还没读懂。要么是我水平低领悟不了她们的奥妙，要么是她们喝了假酒在那乱写。<br>&emsp;&emsp;然后老板的想法大概也是要 fail 的，像“均匀采样一个 3-SUM 问题无解的例子”这样的东西就很不可实现。</p><h4 id="Marshall-Ball-Alon-Rosen-Manuel-Sabin-and-Prashant-Nalini-Vasudevan-Proofs-of-Work-From-Worst-Case-Assumptions-In-CRYPTO-2018"><a href="#Marshall-Ball-Alon-Rosen-Manuel-Sabin-and-Prashant-Nalini-Vasudevan-Proofs-of-Work-From-Worst-Case-Assumptions-In-CRYPTO-2018" class="headerlink" title="Marshall Ball, Alon Rosen, Manuel Sabin, and Prashant Nalini Vasudevan. Proofs of Work From Worst-Case Assumptions. In CRYPTO 2018."></a>Marshall Ball, Alon Rosen, Manuel Sabin, and Prashant Nalini Vasudevan. Proofs of Work From Worst-Case Assumptions. In CRYPTO 2018.</h4><p>&emsp;&emsp;以下称为 [PoW]<br>&emsp;&emsp;原班人马对 [avg-fg] 的延续。<br>&emsp;&emsp;前半部分是把 OV 问题换成了 kOV 问题重新推了一遍 Proof of Work，但是复杂度算得很假，包括但不限于多点求值和快速插值的复杂度竟然离谱地达到了 $O(n \log^3 n \log p)$、一些步骤细节写得不清不楚。<br>&emsp;&emsp;后面比较有趣的是搞了一个 Zero Knowledge Proof of Work，美中不足的是它根据 ElGamal 来改的，因此用了 Decisional Diffie-Hellman 假设，违背了 Fine-Grained Cryptography 的初衷（使用 Fine-Grained Complexity 中的 hardness）。</p><h4 id="Improved-Merlin-Arthur-Protocols-for-Central-Problems-in-Fine-Grained-Complexit"><a href="#Improved-Merlin-Arthur-Protocols-for-Central-Problems-in-Fine-Grained-Complexit" class="headerlink" title="Improved Merlin-Arthur Protocols for Central Problems in Fine-Grained Complexit"></a>Improved Merlin-Arthur Protocols for Central Problems in Fine-Grained Complexit</h4><p>&emsp;&emsp;以下称为 [improved-ma]<br>&emsp;&emsp;为 $k$-SUM、#Zero-Weight $k$-Clique、$k$-CNF Unsat 设计了高效的 MA 协议。都是多项式/生成函数加上一些神奇的多项式技巧。<del>怎么感觉一直都是同一班人在给 OI/ACM/学术带来多项式的血雨腥风</del><br>&emsp;&emsp;这里会发现，$k$-SUM 和 $k$-CNF 都是做经典问题的补问题。因为 MA 协议还是比较爽的，以 $\exists$ 开头的问题（如问是否有解）直接让 prover 把解扔给 verifier 就行了，所以反过来以 $\forall$ 开头的问题（如问是否无解）才是有挑战性的。<br>&emsp;&emsp;但如果尝试给 MA 套上 zero-knowledge，难度就另说了。。。</p><h4 id="Matching-Triangles-and-Basing-Hardness-on-an-Extremely-Popular-Conjecture"><a href="#Matching-Triangles-and-Basing-Hardness-on-an-Extremely-Popular-Conjecture" class="headerlink" title="Matching Triangles and Basing Hardness on an Extremely Popular Conjecture"></a>Matching Triangles and Basing Hardness on an Extremely Popular Conjecture</h4><p>&emsp;&emsp;以下称为 [matching-triangles]<br>&emsp;&emsp;这篇文章大概干了两件事：一是把很多问题归约到了 $\Delta$-Matching-Triangle 问题上，第二是给出了 $\Delta$-Matching-Triangle 问题的一个优秀的做法。做法是，枚举三种颜色的 size，然后取两种子做法复杂度较小者（算是一种复杂度平衡），第一个子做法是 size 比较小的时候直接枚举 $\Delta-1$ 个三角形，然后用矩阵乘法判断是否存在最后一个三角形；第二个子做法是 size 比较大的时候先鸽笼一波排除掉一定有解的情况，然后把三角形 list 出来。</p><h2 id="Interactive-Protocals"><a href="#Interactive-Protocals" class="headerlink" title="Interactive Protocals"></a>Interactive Protocals</h2><h4 id="DOES-co-NP-HAVE-SHORT-INTERACTIVE-PROOFS"><a href="#DOES-co-NP-HAVE-SHORT-INTERACTIVE-PROOFS" class="headerlink" title="DOES co-NP HAVE SHORT INTERACTIVE PROOFS?"></a>DOES co-NP HAVE SHORT INTERACTIVE PROOFS?</h4><h2 id="Zero-Knowledge-Proof"><a href="#Zero-Knowledge-Proof" class="headerlink" title="Zero Knowledge Proof"></a>Zero Knowledge Proof</h2><a href="/ZKP/" title="看这里">看这里</a>]]></content>
    
    
    <summary type="html">&lt;p&gt;大概就随便记一记读过的有亮点的东西，觉得很牛逼的东西就分享一下，随缘更新。&lt;/p&gt;
&lt;p&gt;当然也不是教程或者阅读笔记。&lt;/p&gt;
&lt;p&gt;TCS 是指 Theoretical Computer Science。&lt;/p&gt;</summary>
    
    
    
    <category term="TCS" scheme="http://kqp.world/categories/TCS/"/>
    
    
    <category term="complexity" scheme="http://kqp.world/tags/complexity/"/>
    
    <category term="ZKP" scheme="http://kqp.world/tags/ZKP/"/>
    
  </entry>
  
  <entry>
    <title>【2018 NWERC D】Date Pickup 题解</title>
    <link href="http://kqp.world/%E3%80%902018%20NWERC%20D%E3%80%91Date%20Pickup%20%E9%A2%98%E8%A7%A3/"/>
    <id>http://kqp.world/%E3%80%902018%20NWERC%20D%E3%80%91Date%20Pickup%20%E9%A2%98%E8%A7%A3/</id>
    <published>2021-10-09T05:59:34.000Z</published>
    <updated>2022-01-26T09:46:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>&emsp;&emsp;有一幅 $n$ 个点 $m$ 条边的有向图，边有边权（代表通过所需时间），你在 $1$ 号点，女朋友在 $n$ 号点。<br>&emsp;&emsp;你可以选择在 $1$ 号点延迟任意时间之后，选定一条路线开始游走，一旦开始游走就不能停下来。你的女朋友会在时间区间 $[a,b]$ 中的任意一个实数时间点 call 你，你一旦被 call 就要马上过去 $n$ 号点，女朋友的等待时间就是她 call 了之后到你到达所用的时间。<br>&emsp;&emsp;求女朋友的最坏等待时间最小。</p><p>&emsp;&emsp;$n,m \le 10^5,\ \ 0 \le a \le b \le 10^{12}$，边权 $\le 10^6$<br>&emsp;&emsp;保证每个点至少有一条出边，即总是可以无限游走的。</p><p>&emsp;&emsp;6s</p><span id="more"></span><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>&emsp;&emsp;官方题解有很多细节不是很懂，不过对我考场上的想法有很大的启发，于是完成了我考场上的想法。</p><p>&emsp;&emsp;二分答案 $mid$。<br>&emsp;&emsp;首先，如果到了 $[a,b]$ 这个时间段，我们必须随叫随到，因此我们可以知道这时候哪些点哪些边是能走的：对于点 $u$ 需满足 $dis(u,n) \le mid$，对于边 $(u,v,w)$ 需满足 $w+dis(v,n) \le mid$。这个时间段内我们只能在这个子图上走，除了开始的一点点（$a$ 时刻我们可能还在去这个子图的路上）。<br>&emsp;&emsp;如果我们能从 $1$ 号点去到这个子图，那么接下来要做的事情就是：如果这个子图有环，我们就一直沿着环走，就合法了；如果这个子图没有环，它就是个 DAG，就可以在上面 dp 出一个最久逗留时间，让它 $\ge b$ 就好了。<br>&emsp;&emsp;所以现在就是要判断从 $1$ 号点能不能到达这个子图，即会不会在 $a$ 时刻还没走到子图但是被 call 了然后去不了 $n$ 号点。<br>&emsp;&emsp;假设在 $[a,b]$ 时间段我们最先到达的节点是 $x$，它的充要条件就是：1、$x$ 是子图上的点；2、$dis(1,x) \le a+mid-dis(x,n)$（即 $a$ 时刻 call 合法）。这样就相当于筛选出了子图的合法起点，可以做一个 bfs 筛去子图里起点不能到的点，然后做上面的拓扑找环和 dp。</p><p>&emsp;&emsp;关于 DAG 上的 dp，初值是对于子图起点 $x$，$dp_x=a+mid-dis(x,n)$（即越晚出发越好，但要满足 $a$ 时刻 call 合法），然后按拓扑序求最长路径。</p><p>&emsp;&emsp;注意一些特殊情况，比如 $1$ 号点本身是子图里的点的时候，只需判断 $dis(1,n) \le mid$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pr;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">LL a,b;</span><br><span class="line"><span class="built_in">vector</span>&lt;pr&gt; e[maxn],ef[maxn];</span><br><span class="line"></span><br><span class="line">LL dis1[maxn],disn[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="type">void</span> <span class="title function_">dijkstra</span><span class="params">(<span class="type">int</span> st,<span class="built_in">vector</span>&lt;pr&gt; *e,LL *dis)</span> &#123;</span><br><span class="line"><span class="built_in">memset</span>(dis,<span class="number">127</span>,<span class="keyword">sizeof</span>(LL)*(n+<span class="number">2</span>));</span><br><span class="line">dis[st]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;LL,<span class="type">int</span>&gt;&gt; Q;</span><br><span class="line">Q.push(<span class="built_in">make_pair</span>(<span class="number">0</span>,st));</span><br><span class="line">fo(i,<span class="number">1</span>,n) &#123;</span><br><span class="line"><span class="keyword">while</span> (!Q.empty() &amp;&amp; vis[Q.top().second]) Q.pop();</span><br><span class="line"><span class="keyword">if</span> (Q.empty()) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">auto</span> tp=Q.top(); Q.pop();</span><br><span class="line">vis[tp.second]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(pr go:e[tp.second]) <span class="keyword">if</span> (!vis[go.first] &amp;&amp; dis[go.first]&gt;-tp.first+go.second) &#123;</span><br><span class="line">dis[go.first]=-tp.first+go.second;</span><br><span class="line">Q.push(<span class="built_in">make_pair</span>(-dis[go.first],go.first));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> valid[maxn],arrived[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;pr&gt; et[maxn];</span><br><span class="line">LL dp[maxn];</span><br><span class="line"><span class="type">int</span> dg[maxn];</span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">(LL mid)</span> &#123;</span><br><span class="line"><span class="built_in">memset</span>(dg,<span class="number">0</span>,<span class="keyword">sizeof</span>(dg));</span><br><span class="line"><span class="built_in">memset</span>(arrived,<span class="number">0</span>,<span class="keyword">sizeof</span>(arrived));</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">fo(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">et[i].clear();</span><br><span class="line"><span class="keyword">if</span> (valid[i] &amp;&amp; dis1[i]&lt;=a+mid-disn[i]) &#123;</span><br><span class="line">Q.push(i);</span><br><span class="line">arrived[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line"><span class="type">int</span> cur=Q.front(); Q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> go:e[cur]) <span class="keyword">if</span> (go.second+disn[go.first]&lt;=mid) &#123;</span><br><span class="line"><span class="keyword">if</span> (!arrived[go.first]) Q.push(go.first), arrived[go.first]=<span class="number">1</span>;</span><br><span class="line">et[cur].push_back(go);</span><br><span class="line">dg[go.first]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">topo</span><span class="params">(LL mid)</span> &#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0xbf</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">fo(i,<span class="number">1</span>,n) <span class="keyword">if</span> (arrived[i] &amp;&amp; !dg[i]) Q.push(i);</span><br><span class="line"><span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line"><span class="type">int</span> cur=Q.front(); Q.pop();</span><br><span class="line"><span class="keyword">if</span> (dis1[cur]&lt;=a+mid-disn[cur]) dp[cur]=max(dp[cur],a+mid-disn[cur]);</span><br><span class="line"><span class="keyword">if</span> (dp[cur]&gt;=b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> go:et[cur]) &#123;</span><br><span class="line">dp[go.first]=max(dp[go.first],dp[cur]+go.second);</span><br><span class="line"><span class="keyword">if</span> (--dg[go.first]==<span class="number">0</span>) Q.push(go.first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fo(i,<span class="number">1</span>,n) <span class="keyword">if</span> (arrived[i] &amp;&amp; dg[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(LL mid)</span> &#123;</span><br><span class="line">fo(i,<span class="number">1</span>,n) valid[i]=(disn[i]&lt;=mid);</span><br><span class="line"><span class="keyword">if</span> (valid[<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">bfs(mid);</span><br><span class="line"><span class="keyword">return</span> topo(mid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">fo(i,<span class="number">1</span>,m) &#123;</span><br><span class="line"><span class="type">int</span> x,y,z;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">e[x].push_back(<span class="built_in">make_pair</span>(y,z));</span><br><span class="line">ef[y].push_back(<span class="built_in">make_pair</span>(x,z));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dijkstra(<span class="number">1</span>,e,dis1);</span><br><span class="line">dijkstra(n,ef,disn);</span><br><span class="line"></span><br><span class="line">LL l=<span class="number">0</span>, r=dis1[n];</span><br><span class="line"><span class="keyword">while</span> (l&lt;=r) &#123;</span><br><span class="line">LL mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (check(mid)) r=mid<span class="number">-1</span>; <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,r+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;有一幅 $n$ 个点 $m$ 条边的有向图，边有边权（代表通过所需时间），你在 $1$ 号点，女朋友在 $n$ 号点。&lt;br&gt;&amp;emsp;&amp;emsp;你可以选择在 $1$ 号点延迟任意时间之后，选定一条路线开始游走，一旦开始游走就不能停下来。你的女朋友会在时间区间 $[a,b]$ 中的任意一个实数时间点 call 你，你一旦被 call 就要马上过去 $n$ 号点，女朋友的等待时间就是她 call 了之后到你到达所用的时间。&lt;br&gt;&amp;emsp;&amp;emsp;求女朋友的最坏等待时间最小。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;$n,m \le 10^5,\ \ 0 \le a \le b \le 10^{12}$，边权 $\le 10^6$&lt;br&gt;&amp;emsp;&amp;emsp;保证每个点至少有一条出边，即总是可以无限游走的。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;6s&lt;/p&gt;</summary>
    
    
    
    <category term="OI/ACM" scheme="http://kqp.world/categories/OI-ACM/"/>
    
    
    <category term="算法_DP" scheme="http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"/>
    
    <category term="算法_最短路模型" scheme="http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>【2021 Multi-University 4 E】Didn‘t I Say to Make My Abilities Average in the Next Life?! 题解</title>
    <link href="http://kqp.world/%E3%80%902021%20Multi-University%204%20E%E3%80%91Didn%E2%80%98t%20I%20Say%20to%20Make%20My%20Abilities%20Average%20in%20the%20Next%20Life!%20%E9%A2%98%E8%A7%A3/"/>
    <id>http://kqp.world/%E3%80%902021%20Multi-University%204%20E%E3%80%91Didn%E2%80%98t%20I%20Say%20to%20Make%20My%20Abilities%20Average%20in%20the%20Next%20Life!%20%E9%A2%98%E8%A7%A3/</id>
    <published>2021-08-14T06:11:29.000Z</published>
    <updated>2022-01-26T09:46:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>&emsp;&emsp;定义一个序列的 average 为 $\frac{最大值+最小值}{2}$。<br>&emsp;&emsp;给定一个序列 $a_1,\cdots,a_n$，有 $m$ 次询问，每次问这个区间的所有子区间的 average 期望。</p><p>&emsp;&emsp;$n,m \le 2 \times 10^5,\ 1 \le a_i \le 10^9$<br>&emsp;&emsp;多测，$\sum n,\sum m \le 3 \times 10^5$<br>&emsp;&emsp;8s</p><span id="more"></span><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><h2 id="扯淡"><a href="#扯淡" class="headerlink" title="扯淡"></a>扯淡</h2><p>&emsp;&emsp;考场上脑补了个 $O(m \sqrt n)$ 的只增莫队巨难写，写到最后又 WA 又 T。<br>&emsp;&emsp;第二天牛爷爷说这是个原题，上网搜了一下大家说这个题是【HNOI2016 序列】，于是就去学习了一下，老年选手被这个神奇的技巧秀得头皮发麻。。。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>&emsp;&emsp;首先 $\mathbb E[\frac{\max+\min}{2}]=\frac{\mathbb E[\max]+\mathbb E[\min]}{2}$，所以问题变成每次求一个区间所有子区间的 $\max$ 和以及 $\min$ 和。这就是【HNOI2016 序列】了。</p><p>&emsp;&emsp;做法多种多样，莫队和在线 $O(n \log n+m)$ 的都有，但其实本质相同的，莫队到在线也就多一步小转化而已。下面就讲在线的。<br>&emsp;&emsp;考虑这样一个数组：$f_i$ 表示右端点为 $i$、左端点 $\in [1,i]$ 的所有区间的 $\max$ 和。它的转移很简单，就是找到 $i$ 上一个比它大的数 $L_i$，那么左端点 $\le L_i$ 的区间的 $\max$ 都保持不变，左端点 $\in (L_i,i]$ 的区间的 $\max$ 等于 $a_i$，因此</p><script type="math/tex; mode=display">f_i=f_{L_i}+a_i(i-L_i)</script><p>&emsp;&emsp;这东西怎么用呢？变形得到 $f_i-f_{L_i}=a_i(i-L_i)$，也就是说，知道了 $i$ 的转移点 $L_i$，那么就知道了左端点 $\in(L_i,i]$、右端点为 $i$ 的所有区间的 $\max$ 和。<br>&emsp;&emsp;更进一步，$i$ 从 $L_i$ 转移来，$L_i$ 从 $L_{L_i}$ 转移来……这样形成一个转移路径（实际上就是以 $i$ 结尾的单调栈），在这条路径上的任何一个 $j$，都满足 $f_i-f_j$ 等于左端点 $\in(j,i]$、右端点为 $i$ 的所有区间的 $\max$ 和。</p><p>&emsp;&emsp;接下来就可以做这题了。<br>&emsp;&emsp;询问一个区间 $[l,r]$ 的所有子区间的 $\max$ 和，先找到这个区间的最大值所在位置 $mx$，那么凡是左端点 $\in [l,mx]$、右端点 $\in (mx,r]$ 的子区间，最大值都是 $a_{mx}$。因此问题转化成 $[l,mx)$、$(mx,r]$ 的子问题。<br>&emsp;&emsp;考虑 $(mx,r]$，重要的性质是，$mx$ 一定在 $r$ 的转移路径上，因此 $f_r-f_{mx}$ 就是左端点 $\in (mx,r]$、右端点为 $r$ 的子区间的 $\max$ 和；同理，$mx$ 一定也在 $r-1$ 的转移路径上，所以 $f_{r-1}-f_{mx}$ 就是左端点 $\in (mx,r-1]$、右端点为 $r-1$ 的子区间的 $\max$ 和……<br>&emsp;&emsp;因此 $(mx,r]$ 的贡献就是</p><script type="math/tex; mode=display">(f_r-f_{mx})+(f_{r-1}-f_{mx})+\cdots+(f_{mx+1}-f_{mx})=\left(\sum_{i=mx+1}^rf_i\right)-f_{mx}(r-mx)</script><p>&emsp;&emsp;所以求个 $f$ 的前缀和就做好了。<br>&emsp;&emsp;同理可求 $[l,mx)$ 的贡献，以及 $\min$ 和。</p><p>&emsp;&emsp;时间复杂度，预处理 rmq 需要 $O(n \log n)$，预处理 $f$ 需要 $O(n)$，每个询问是 $O(1)$ 的，因此是 $O(n \log n + m)$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,a,b) for(int i=a;i&gt;=b;i--)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">2e5</span>+<span class="number">5</span>, MX=<span class="number">17</span>;</span><br><span class="line"><span class="type">const</span> LL mo=<span class="number">1e9</span>+<span class="number">7</span>, inv2=(mo+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> st_mx[MX+<span class="number">2</span>][maxn],st_mn[MX+<span class="number">2</span>][maxn],Log[maxn];</span><br><span class="line"><span class="type">void</span> <span class="title function_">rmq_pre</span><span class="params">()</span> &#123;</span><br><span class="line">fo(i,<span class="number">1</span>,n) st_mx[<span class="number">0</span>][i]=st_mn[<span class="number">0</span>][i]=i;</span><br><span class="line">fo(i,<span class="number">2</span>,n) Log[i]=Log[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">fo(j,<span class="number">1</span>,MX)</span><br><span class="line">fo(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">st_mx[j][i]=st_mx[j<span class="number">-1</span>][i];</span><br><span class="line">st_mn[j][i]=st_mn[j<span class="number">-1</span>][i];</span><br><span class="line"><span class="type">int</span> t=i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">if</span> (t&lt;=n) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[st_mx[j][i]]&lt;a[st_mx[j<span class="number">-1</span>][t]]) st_mx[j][i]=st_mx[j<span class="number">-1</span>][t];</span><br><span class="line"><span class="keyword">if</span> (a[st_mn[j][i]]&gt;=a[st_mn[j<span class="number">-1</span>][t]]) st_mn[j][i]=st_mn[j<span class="number">-1</span>][t];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title function_">rmq</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> &#123;</span><br><span class="line"><span class="type">int</span> t=Log[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> mx=(a[st_mx[t][l]]&gt;=a[st_mx[t][r-(<span class="number">1</span>&lt;&lt;t)+<span class="number">1</span>]]) ?st_mx[t][l] :st_mx[t][r-(<span class="number">1</span>&lt;&lt;t)+<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> mn=(a[st_mn[t][l]]&lt;a[st_mn[t][r-(<span class="number">1</span>&lt;&lt;t)+<span class="number">1</span>]]) ?st_mn[t][l] :st_mn[t][r-(<span class="number">1</span>&lt;&lt;t)+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_pair</span>(mx,mn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL f_l_mx[maxn],f_l_mn[maxn],f_r_mx[maxn],f_r_mn[maxn];</span><br><span class="line">LL s_l_mx[maxn],s_l_mn[maxn],s_r_mx[maxn],s_r_mn[maxn];</span><br><span class="line"><span class="type">int</span> z0,z[maxn];</span><br><span class="line"><span class="type">void</span> <span class="title function_">f_pre</span><span class="params">()</span> &#123;</span><br><span class="line">z0=<span class="number">0</span>;</span><br><span class="line">fo(i,<span class="number">1</span>,n) &#123;</span><br><span class="line"><span class="keyword">while</span> (z0 &amp;&amp; a[z[z0]]&lt;a[i]) z0--;</span><br><span class="line">f_l_mx[i]=(f_l_mx[z[z0]]+(LL)a[i]*(i-z[z0]))%mo;</span><br><span class="line">s_l_mx[i]=(s_l_mx[i<span class="number">-1</span>]+f_l_mx[i])%mo;</span><br><span class="line">z[++z0]=i;</span><br><span class="line">&#125;</span><br><span class="line">z0=<span class="number">0</span>;</span><br><span class="line">fo(i,<span class="number">1</span>,n) &#123;</span><br><span class="line"><span class="keyword">while</span> (z0 &amp;&amp; a[z[z0]]&gt;=a[i]) z0--;</span><br><span class="line">f_l_mn[i]=(f_l_mn[z[z0]]+(LL)a[i]*(i-z[z0]))%mo;</span><br><span class="line">s_l_mn[i]=(s_l_mn[i<span class="number">-1</span>]+f_l_mn[i])%mo;</span><br><span class="line">z[++z0]=i;</span><br><span class="line">&#125;</span><br><span class="line">z0=<span class="number">0</span>;</span><br><span class="line">s_r_mx[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">fd(i,n,<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (z0 &amp;&amp; a[z[z0]]&lt;=a[i]) z0--;</span><br><span class="line">f_r_mx[i]=(f_r_mx[z[z0]]+(LL)a[i]*(z[z0]-i))%mo;</span><br><span class="line">s_r_mx[i]=(s_r_mx[i+<span class="number">1</span>]+f_r_mx[i])%mo;</span><br><span class="line">z[++z0]=i;</span><br><span class="line">&#125;</span><br><span class="line">z0=<span class="number">0</span>;</span><br><span class="line">s_r_mn[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">fd(i,n,<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (z0 &amp;&amp; a[z[z0]]&gt;a[i]) z0--;</span><br><span class="line">f_r_mn[i]=(f_r_mn[z[z0]]+(LL)a[i]*(z[z0]-i))%mo;</span><br><span class="line">s_r_mn[i]=(s_r_mn[i+<span class="number">1</span>]+f_r_mn[i])%mo;</span><br><span class="line">z[++z0]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL <span class="title function_">Pow</span><span class="params">(LL x,LL y)</span> &#123;</span><br><span class="line">LL re=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; y; y&gt;&gt;=<span class="number">1</span>, x=x*x%mo) <span class="keyword">if</span> (y&amp;<span class="number">1</span>) re=re*x%mo;</span><br><span class="line"><span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL <span class="title function_">sum</span><span class="params">(LL x)</span> &#123;<span class="keyword">return</span> x*(x+<span class="number">1</span>)%mo*inv2%mo;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">fo(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"></span><br><span class="line">rmq_pre();</span><br><span class="line">f_pre();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line"></span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; p=rmq(l,r);</span><br><span class="line"><span class="type">int</span> mx=p.first, mn=p.second;</span><br><span class="line">LL ans_mx=a[mx]*(LL)(mx-l+<span class="number">1</span>)%mo*(r-mx+<span class="number">1</span>)%mo;</span><br><span class="line">(ans_mx+=s_l_mx[r]-s_l_mx[mx]+mo-f_l_mx[mx]*(r-mx)%mo+mo)%=mo;</span><br><span class="line">(ans_mx+=s_r_mx[l]-s_r_mx[mx]+mo-f_r_mx[mx]*(mx-l)%mo+mo)%=mo;</span><br><span class="line">LL ans_mn=a[mn]*(LL)(mn-l+<span class="number">1</span>)%mo*(r-mn+<span class="number">1</span>)%mo;</span><br><span class="line">(ans_mn+=s_l_mn[r]-s_l_mn[mn]+mo-f_l_mn[mn]*(r-mn)%mo+mo)%=mo;</span><br><span class="line">(ans_mn+=s_r_mn[l]-s_r_mn[mn]+mo-f_r_mn[mn]*(mn-l)%mo+mo)%=mo;</span><br><span class="line">LL ans=(ans_mx+ans_mn)%mo*inv2%mo*Pow(sum(r-l+<span class="number">1</span>),mo<span class="number">-2</span>)%mo;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;定义一个序列的 average 为 $\frac{最大值+最小值}{2}$。&lt;br&gt;&amp;emsp;&amp;emsp;给定一个序列 $a_1,\cdots,a_n$，有 $m$ 次询问，每次问这个区间的所有子区间的 average 期望。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;$n,m \le 2 \times 10^5,\ 1 \le a_i \le 10^9$&lt;br&gt;&amp;emsp;&amp;emsp;多测，$\sum n,\sum m \le 3 \times 10^5$&lt;br&gt;&amp;emsp;&amp;emsp;8s&lt;/p&gt;</summary>
    
    
    
    <category term="OI/ACM" scheme="http://kqp.world/categories/OI-ACM/"/>
    
    
    <category term="算法_神奇的脑洞" scheme="http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"/>
    
    <category term="算法_莫队/分块" scheme="http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E8%8E%AB%E9%98%9F-%E5%88%86%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>【2021 Multi-University 4 G】Increasing Subsequence 题解</title>
    <link href="http://kqp.world/%E3%80%902021%20Multi-University%204%20G%E3%80%91Increasing%20Subsequence%20%E9%A2%98%E8%A7%A3/"/>
    <id>http://kqp.world/%E3%80%902021%20Multi-University%204%20G%E3%80%91Increasing%20Subsequence%20%E9%A2%98%E8%A7%A3/</id>
    <published>2021-08-13T02:54:40.000Z</published>
    <updated>2022-01-26T09:46:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>&emsp;&emsp;给定一个排列 $a_1,\cdots,a_n$，求极长上升子序列的数量。</p><p>&emsp;&emsp;$n \le 10^5$</p><span id="more"></span><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><script type="math/tex; mode=display">\\</script><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>&emsp;&emsp;设 $dp_i$ 表示以 $i$ 结尾的极长上升子序列数量，那么关键就是找到 $dp_i$ 能从哪些 $dp_j$ 转移过来，需要满足 $a_i&gt;a_j$ 且 $j$ 到 $i$ 之间没有 $\in [a_j,a_i]$ 的数了。<br>&emsp;&emsp;这种前面的数贡献到后面的数的模型，还要想到 cdq 这种！<br>&emsp;&emsp;假设当前分治区间 $[l,r]$，中间是 $mid$。把 $a_l,\cdots,a_r$ 从小到大排序，然后左半边维护一个位置单调递减的栈，右半边维护一个位置单调递增的栈，大概长这样：</p><script type="math/tex; mode=display">7\ 6\ 3\ 1\ |\ 2\ 4\ 5\ 8</script><p>&emsp;&emsp;（中线代表 $mid$，两边分别是向左向右增长的栈，数字是 $a$ 值，保持了原序列的相对位置关系）<br>&emsp;&emsp;左边的单调栈的含义是，如果有一个很大的数放在了很右的位置，显然它左边的小的数都不再能转移出去了；右边的单调栈的含义是，因为右边是代表询问的，因此如果有一个很大的数放在了很左的位置，那么它会对以后的询问构成更紧的限制，它右边的小的数就没用了。<br>&emsp;&emsp;那么比如 $8$ 插入到右边的栈，它的栈里下一个元素是 $5$，意思就是左边 $5$ 及以下的数都不能转移到 $8$，因此能转移到 $8$ 的只有 $6,7$。那么这就是个在左边栈里二分的过程。<br>&emsp;&emsp;复杂度 $O(n \log ^2 n)$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,a,b) for(int i=a;i&gt;=b;i--)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> LL mo=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,a[maxn];</span><br><span class="line"><span class="type">bool</span> canBeInit[maxn];</span><br><span class="line"></span><br><span class="line">LL dp[maxn],Sl[maxn];</span><br><span class="line"><span class="type">int</span> b0,zl0,zl[maxn],zr0,zr[maxn];</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; b[maxn];</span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line"><span class="type">int</span> l=<span class="number">1</span>, r=zl0;</span><br><span class="line"><span class="keyword">while</span> (l&lt;=r) &#123;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (a[zl[mid]]&lt;x) l=mid+<span class="number">1</span>; <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">cdq</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (l==r) &#123;</span><br><span class="line">(dp[l]+=canBeInit[l])%=mo;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">cdq(l,mid);</span><br><span class="line"></span><br><span class="line">b0=<span class="number">0</span>;</span><br><span class="line">fo(i,l,r) b[++b0]=<span class="built_in">make_pair</span>(a[i],i);</span><br><span class="line">sort(b+<span class="number">1</span>,b+<span class="number">1</span>+b0);</span><br><span class="line">zl0=zr0=<span class="number">0</span>;</span><br><span class="line">fo(i,<span class="number">1</span>,b0) <span class="keyword">if</span> (b[i].second&lt;=mid) &#123;</span><br><span class="line"><span class="keyword">while</span> (zl0 &amp;&amp; zl[zl0]&lt;b[i].second) zl0--;</span><br><span class="line">zl[++zl0]=b[i].second;</span><br><span class="line">Sl[zl0]=(Sl[zl0<span class="number">-1</span>]+dp[b[i].second])%mo;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (zr0 &amp;&amp; zr[zr0]&gt;b[i].second) zr0--;</span><br><span class="line"><span class="type">int</span> t=find(a[zr[zr0]]);</span><br><span class="line">(dp[b[i].second]+=Sl[zl0]-Sl[t]+mo)%=mo;</span><br><span class="line">zr[++zr0]=b[i].second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cdq(mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">fo(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> last=n+<span class="number">1</span>;</span><br><span class="line">fo(i,<span class="number">1</span>,n) <span class="keyword">if</span> (a[i]&lt;last) &#123;</span><br><span class="line">canBeInit[i]=<span class="number">1</span>;</span><br><span class="line">last=a[i];</span><br><span class="line">&#125; <span class="keyword">else</span> canBeInit[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(LL)*(n+<span class="number">2</span>));</span><br><span class="line">cdq(<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">last=<span class="number">0</span>;</span><br><span class="line">LL ans=<span class="number">0</span>;</span><br><span class="line">fd(i,n,<span class="number">1</span>) <span class="keyword">if</span> (a[i]&gt;last) &#123;</span><br><span class="line">last=a[i];</span><br><span class="line">(ans+=dp[i])%=mo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;给定一个排列 $a_1,\cdots,a_n$，求极长上升子序列的数量。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;$n \le 10^5$&lt;/p&gt;</summary>
    
    
    
    <category term="OI/ACM" scheme="http://kqp.world/categories/OI-ACM/"/>
    
    
    <category term="算法_分治" scheme="http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
</feed>
